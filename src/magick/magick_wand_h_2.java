// Generated by jextract

package magick;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class magick_wand_h_2 {

    magick_wand_h_2() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup("/usr/lib/libGraphicsMagick.so", LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int HasX11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HasX11 1
     * }
     */
    public static int HasX11() {
        return HasX11;
    }
    private static final int QuantumDepth = (int)16L;
    /**
     * {@snippet lang=c :
     * #define QuantumDepth 16
     * }
     */
    public static int QuantumDepth() {
        return QuantumDepth;
    }
    private static final int _STDIO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDIO_H 1
     * }
     */
    public static int _STDIO_H() {
        return _STDIO_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2Y = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2Y 0
     * }
     */
    public static int __GLIBC_USE_ISOC2Y() {
        return __GLIBC_USE_ISOC2Y;
    }
    private static final int __GLIBC_USE_ISOC23 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC23 0
     * }
     */
    public static int __GLIBC_USE_ISOC23() {
        return __GLIBC_USE_ISOC23;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_TIME_BITS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_TIME_BITS64 1
     * }
     */
    public static int __USE_TIME_BITS64() {
        return __USE_TIME_BITS64;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int __GLIBC_USE_C23_STRTOL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_C23_STRTOL 0
     * }
     */
    public static int __GLIBC_USE_C23_STRTOL() {
        return __GLIBC_USE_C23_STRTOL;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)42L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 42
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C23 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C23 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C23() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C23;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C23 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C23 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C23() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C23;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int _____fpos_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos_t_defined 1
     * }
     */
    public static int _____fpos_t_defined() {
        return _____fpos_t_defined;
    }
    private static final int ____mbstate_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____mbstate_t_defined 1
     * }
     */
    public static int ____mbstate_t_defined() {
        return ____mbstate_t_defined;
    }
    private static final int _____fpos64_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos64_t_defined 1
     * }
     */
    public static int _____fpos64_t_defined() {
        return _____fpos64_t_defined;
    }
    private static final int ____FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____FILE_defined 1
     * }
     */
    public static int ____FILE_defined() {
        return ____FILE_defined;
    }
    private static final int __FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __FILE_defined 1
     * }
     */
    public static int __FILE_defined() {
        return __FILE_defined;
    }
    private static final int __struct_FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_FILE_defined 1
     * }
     */
    public static int __struct_FILE_defined() {
        return __struct_FILE_defined;
    }
    private static final int _IO_EOF_SEEN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _IO_EOF_SEEN 16
     * }
     */
    public static int _IO_EOF_SEEN() {
        return _IO_EOF_SEEN;
    }
    private static final int _IO_ERR_SEEN = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _IO_ERR_SEEN 32
     * }
     */
    public static int _IO_ERR_SEEN() {
        return _IO_ERR_SEEN;
    }
    private static final int _IO_USER_LOCK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _IO_USER_LOCK 32768
     * }
     */
    public static int _IO_USER_LOCK() {
        return _IO_USER_LOCK;
    }
    private static final int __cookie_io_functions_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __cookie_io_functions_t_defined 1
     * }
     */
    public static int __cookie_io_functions_t_defined() {
        return __cookie_io_functions_t_defined;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 1
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 2
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int BUFSIZ = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 8192
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int L_tmpnam = (int)20L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 20
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int TMP_MAX = (int)238328L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 238328
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int _BITS_STDIO_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDIO_LIM_H 1
     * }
     */
    public static int _BITS_STDIO_LIM_H() {
        return _BITS_STDIO_LIM_H;
    }
    private static final int FILENAME_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 4096
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int L_ctermid = (int)9L;
    /**
     * {@snippet lang=c :
     * #define L_ctermid 9
     * }
     */
    public static int L_ctermid() {
        return L_ctermid;
    }
    private static final int FOPEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 16
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int __HAVE_FLOAT128 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128 1
     * }
     */
    public static int __HAVE_FLOAT128() {
        return __HAVE_FLOAT128;
    }
    private static final int __HAVE_DISTINCT_FLOAT128 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128 1
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128() {
        return __HAVE_DISTINCT_FLOAT128;
    }
    private static final int __HAVE_FLOAT64X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X 1
     * }
     */
    public static int __HAVE_FLOAT64X() {
        return __HAVE_FLOAT64X;
    }
    private static final int __HAVE_FLOAT64X_LONG_DOUBLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X_LONG_DOUBLE 1
     * }
     */
    public static int __HAVE_FLOAT64X_LONG_DOUBLE() {
        return __HAVE_FLOAT64X_LONG_DOUBLE;
    }
    private static final int __HAVE_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT16 0
     * }
     */
    public static int __HAVE_FLOAT16() {
        return __HAVE_FLOAT16;
    }
    private static final int __HAVE_FLOAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32 1
     * }
     */
    public static int __HAVE_FLOAT32() {
        return __HAVE_FLOAT32;
    }
    private static final int __HAVE_FLOAT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64 1
     * }
     */
    public static int __HAVE_FLOAT64() {
        return __HAVE_FLOAT64;
    }
    private static final int __HAVE_FLOAT32X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32X 1
     * }
     */
    public static int __HAVE_FLOAT32X() {
        return __HAVE_FLOAT32X;
    }
    private static final int __HAVE_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128X 0
     * }
     */
    public static int __HAVE_FLOAT128X() {
        return __HAVE_FLOAT128X;
    }
    private static final int __HAVE_DISTINCT_FLOAT32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32() {
        return __HAVE_DISTINCT_FLOAT32;
    }
    private static final int __HAVE_DISTINCT_FLOAT64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64() {
        return __HAVE_DISTINCT_FLOAT64;
    }
    private static final int __HAVE_DISTINCT_FLOAT32X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32X() {
        return __HAVE_DISTINCT_FLOAT32X;
    }
    private static final int __HAVE_DISTINCT_FLOAT64X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64X() {
        return __HAVE_DISTINCT_FLOAT64X;
    }
    private static final int __HAVE_FLOATN_NOT_TYPEDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOATN_NOT_TYPEDEF 0
     * }
     */
    public static int __HAVE_FLOATN_NOT_TYPEDEF() {
        return __HAVE_FLOATN_NOT_TYPEDEF;
    }
    private static final int _STDLIB_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDLIB_H 1
     * }
     */
    public static int _STDLIB_H() {
        return _STDLIB_H;
    }
    private static final int WNOHANG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WNOHANG 1
     * }
     */
    public static int WNOHANG() {
        return WNOHANG;
    }
    private static final int WUNTRACED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WUNTRACED 2
     * }
     */
    public static int WUNTRACED() {
        return WUNTRACED;
    }
    private static final int WSTOPPED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WSTOPPED 2
     * }
     */
    public static int WSTOPPED() {
        return WSTOPPED;
    }
    private static final int WEXITED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WEXITED 4
     * }
     */
    public static int WEXITED() {
        return WEXITED;
    }
    private static final int WCONTINUED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WCONTINUED 8
     * }
     */
    public static int WCONTINUED() {
        return WCONTINUED;
    }
    private static final int WNOWAIT = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define WNOWAIT 16777216
     * }
     */
    public static int WNOWAIT() {
        return WNOWAIT;
    }
    private static final int __WNOTHREAD = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define __WNOTHREAD 536870912
     * }
     */
    public static int __WNOTHREAD() {
        return __WNOTHREAD;
    }
    private static final int __WALL = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define __WALL 1073741824
     * }
     */
    public static int __WALL() {
        return __WALL;
    }
    private static final int __W_CONTINUED = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define __W_CONTINUED 65535
     * }
     */
    public static int __W_CONTINUED() {
        return __W_CONTINUED;
    }
    private static final int __WCOREFLAG = (int)128L;
    /**
     * {@snippet lang=c :
     * #define __WCOREFLAG 128
     * }
     */
    public static int __WCOREFLAG() {
        return __WCOREFLAG;
    }
    private static final int __ldiv_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __ldiv_t_defined 1
     * }
     */
    public static int __ldiv_t_defined() {
        return __ldiv_t_defined;
    }
    private static final int __lldiv_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __lldiv_t_defined 1
     * }
     */
    public static int __lldiv_t_defined() {
        return __lldiv_t_defined;
    }
    private static final int RAND_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 2147483647
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int _SYS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_TYPES_H 1
     * }
     */
    public static int _SYS_TYPES_H() {
        return _SYS_TYPES_H;
    }
    private static final int __clock_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clock_t_defined 1
     * }
     */
    public static int __clock_t_defined() {
        return __clock_t_defined;
    }
    private static final int __clockid_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clockid_t_defined 1
     * }
     */
    public static int __clockid_t_defined() {
        return __clockid_t_defined;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int __timer_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timer_t_defined 1
     * }
     */
    public static int __timer_t_defined() {
        return __timer_t_defined;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int __BIT_TYPES_DEFINED__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __BIT_TYPES_DEFINED__ 1
     * }
     */
    public static int __BIT_TYPES_DEFINED__() {
        return __BIT_TYPES_DEFINED__;
    }
    private static final int _ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ENDIAN_H 1
     * }
     */
    public static int _ENDIAN_H() {
        return _ENDIAN_H;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int _BITS_BYTESWAP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_BYTESWAP_H 1
     * }
     */
    public static int _BITS_BYTESWAP_H() {
        return _BITS_BYTESWAP_H;
    }
    private static final int _BITS_UINTN_IDENTITY_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_UINTN_IDENTITY_H 1
     * }
     */
    public static int _BITS_UINTN_IDENTITY_H() {
        return _BITS_UINTN_IDENTITY_H;
    }
    private static final int _SYS_SELECT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SELECT_H 1
     * }
     */
    public static int _SYS_SELECT_H() {
        return _SYS_SELECT_H;
    }
    private static final int __sigset_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __sigset_t_defined 1
     * }
     */
    public static int __sigset_t_defined() {
        return __sigset_t_defined;
    }
    private static final int __timeval_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timeval_defined 1
     * }
     */
    public static int __timeval_defined() {
        return __timeval_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_PTHREADTYPES_COMMON_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_COMMON_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_COMMON_H() {
        return _BITS_PTHREADTYPES_COMMON_H;
    }
    private static final int _THREAD_SHARED_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_SHARED_TYPES_H 1
     * }
     */
    public static int _THREAD_SHARED_TYPES_H() {
        return _THREAD_SHARED_TYPES_H;
    }
    private static final int _BITS_PTHREADTYPES_ARCH_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_ARCH_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_ARCH_H() {
        return _BITS_PTHREADTYPES_ARCH_H;
    }
    private static final int __SIZEOF_PTHREAD_MUTEX_T = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEX_T 40
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEX_T() {
        return __SIZEOF_PTHREAD_MUTEX_T;
    }
    private static final int __SIZEOF_PTHREAD_ATTR_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_ATTR_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_ATTR_T() {
        return __SIZEOF_PTHREAD_ATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCK_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCK_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCK_T() {
        return __SIZEOF_PTHREAD_RWLOCK_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIER_T = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIER_T 32
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIER_T() {
        return __SIZEOF_PTHREAD_BARRIER_T;
    }
    private static final int __SIZEOF_PTHREAD_MUTEXATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEXATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEXATTR_T() {
        return __SIZEOF_PTHREAD_MUTEXATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_COND_T = (int)48L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_COND_T 48
     * }
     */
    public static int __SIZEOF_PTHREAD_COND_T() {
        return __SIZEOF_PTHREAD_COND_T;
    }
    private static final int __SIZEOF_PTHREAD_CONDATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_CONDATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_CONDATTR_T() {
        return __SIZEOF_PTHREAD_CONDATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCKATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCKATTR_T() {
        return __SIZEOF_PTHREAD_RWLOCKATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIERATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIERATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIERATTR_T() {
        return __SIZEOF_PTHREAD_BARRIERATTR_T;
    }
    private static final int _THREAD_MUTEX_INTERNAL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_MUTEX_INTERNAL_H 1
     * }
     */
    public static int _THREAD_MUTEX_INTERNAL_H() {
        return _THREAD_MUTEX_INTERNAL_H;
    }
    private static final int __PTHREAD_MUTEX_HAVE_PREV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_HAVE_PREV 1
     * }
     */
    public static int __PTHREAD_MUTEX_HAVE_PREV() {
        return __PTHREAD_MUTEX_HAVE_PREV;
    }
    private static final int __have_pthread_attr_t = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __have_pthread_attr_t 1
     * }
     */
    public static int __have_pthread_attr_t() {
        return __have_pthread_attr_t;
    }
    private static final int _ALLOCA_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ALLOCA_H 1
     * }
     */
    public static int _ALLOCA_H() {
        return _ALLOCA_H;
    }
    private static final int MaxTextExtent = (int)2053L;
    /**
     * {@snippet lang=c :
     * #define MaxTextExtent 2053
     * }
     */
    public static int MaxTextExtent() {
        return MaxTextExtent;
    }
    private static final int MagickPass = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MagickPass 1
     * }
     */
    public static int MagickPass() {
        return MagickPass;
    }
    private static final int MagickFail = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MagickFail 0
     * }
     */
    public static int MagickFail() {
        return MagickFail;
    }
    private static final int MagickTrue = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MagickTrue 1
     * }
     */
    public static int MagickTrue() {
        return MagickTrue;
    }
    private static final int MagickFalse = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MagickFalse 0
     * }
     */
    public static int MagickFalse() {
        return MagickFalse;
    }
    private static final int MaxMapDepth = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MaxMapDepth 16
     * }
     */
    public static int MaxMapDepth() {
        return MaxMapDepth;
    }
    private static final int MAGICK_PIXELS_BGRA = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MAGICK_PIXELS_BGRA 1
     * }
     */
    public static int MAGICK_PIXELS_BGRA() {
        return MAGICK_PIXELS_BGRA;
    }
    private static final int MAGICK_OPT_NO_SIGNAL_HANDER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MAGICK_OPT_NO_SIGNAL_HANDER 1
     * }
     */
    public static int MAGICK_OPT_NO_SIGNAL_HANDER() {
        return MAGICK_OPT_NO_SIGNAL_HANDER;
    }
    private static final int MaxTreeDepth = (int)8L;
    /**
     * {@snippet lang=c :
     * #define MaxTreeDepth 8
     * }
     */
    public static int MaxTreeDepth() {
        return MaxTreeDepth;
    }
    private static final int NodesInAList = (int)1536L;
    /**
     * {@snippet lang=c :
     * #define NodesInAList 1536
     * }
     */
    public static int NodesInAList() {
        return NodesInAList;
    }
    private static final int MagickLibVersion = (int)2630914L;
    /**
     * {@snippet lang=c :
     * #define MagickLibVersion 2630914
     * }
     */
    public static int MagickLibVersion() {
        return MagickLibVersion;
    }
    private static final int MagickLibInterfaceNewest = (int)28L;
    /**
     * {@snippet lang=c :
     * #define MagickLibInterfaceNewest 28
     * }
     */
    public static int MagickLibInterfaceNewest() {
        return MagickLibInterfaceNewest;
    }
    private static final int MagickLibInterfaceOldest = (int)3L;
    /**
     * {@snippet lang=c :
     * #define MagickLibInterfaceOldest 3
     * }
     */
    public static int MagickLibInterfaceOldest() {
        return MagickLibInterfaceOldest;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = magick_wand_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = magick_wand_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = magick_wand_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = magick_wand_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = magick_wand_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = magick_wand_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = magick_wand_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = magick_wand_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = magick_wand_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = magick_wand_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = magick_wand_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = magick_wand_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = magick_wand_h.C_LONG;

    private static class stdin$constants {
        public static final AddressLayout LAYOUT = magick_wand_h.C_POINTER;
        public static final MemorySegment SEGMENT = magick_wand_h.findOrThrow("stdin").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static AddressLayout stdin$layout() {
        return stdin$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin$segment() {
        return stdin$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin() {
        return stdin$constants.SEGMENT.get(stdin$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static void stdin(MemorySegment varValue) {
        stdin$constants.SEGMENT.set(stdin$constants.LAYOUT, 0L, varValue);
    }

    private static class stdout$constants {
        public static final AddressLayout LAYOUT = magick_wand_h.C_POINTER;
        public static final MemorySegment SEGMENT = magick_wand_h.findOrThrow("stdout").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static AddressLayout stdout$layout() {
        return stdout$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout$segment() {
        return stdout$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout() {
        return stdout$constants.SEGMENT.get(stdout$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static void stdout(MemorySegment varValue) {
        stdout$constants.SEGMENT.set(stdout$constants.LAYOUT, 0L, varValue);
    }

    private static class stderr$constants {
        public static final AddressLayout LAYOUT = magick_wand_h.C_POINTER;
        public static final MemorySegment SEGMENT = magick_wand_h.findOrThrow("stderr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static AddressLayout stderr$layout() {
        return stderr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr$segment() {
        return stderr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr() {
        return stderr$constants.SEGMENT.get(stderr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static void stderr(MemorySegment varValue) {
        stderr$constants.SEGMENT.set(stderr$constants.LAYOUT, 0L, varValue);
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static int remove(MemorySegment __filename) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", __filename);
            }
            return (int)mh$.invokeExact(__filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static int renameat(int __oldfd, MemorySegment __old, int __newfd, MemorySegment __new) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", __oldfd, __old, __newfd, __new);
            }
            return (int)mh$.invokeExact(__oldfd, __old, __newfd, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static int fclose(MemorySegment __stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("tmpnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static FunctionDescriptor tmpnam_r$descriptor() {
        return tmpnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MethodHandle tmpnam_r$handle() {
        return tmpnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r$address() {
        return tmpnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r(MemorySegment __s) {
        var mh$ = tmpnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_r", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __pfx) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __pfx);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __pfx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static int fflush(MemorySegment __stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fflush_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush_unlocked$descriptor() {
        return fflush_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fflush_unlocked$handle() {
        return fflush_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fflush_unlocked$address() {
        return fflush_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static int fflush_unlocked(MemorySegment __stream) {
        var mh$ = fflush_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __modes) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment __filename, MemorySegment __modes, MemorySegment __stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", __filename, __modes, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen(int __fd, MemorySegment __modes) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", __fd, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__fd, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopencookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            _IO_cookie_io_functions_t.layout()
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fopencookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static FunctionDescriptor fopencookie$descriptor() {
        return fopencookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MethodHandle fopencookie$handle() {
        return fopencookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MemorySegment fopencookie$address() {
        return fopencookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MemorySegment fopencookie(MemorySegment __magic_cookie, MemorySegment __modes, MemorySegment __io_funcs) {
        var mh$ = fopencookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopencookie", __magic_cookie, __modes, __io_funcs);
            }
            return (MemorySegment)mh$.invokeExact(__magic_cookie, __modes, __io_funcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __s, long __len, MemorySegment __modes) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __s, __len, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__s, __len, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufloc, MemorySegment __sizeloc) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufloc, __sizeloc);
            }
            return (MemorySegment)mh$.invokeExact(__bufloc, __sizeloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static void setbuf(MemorySegment __stream, MemorySegment __buf) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", __stream, __buf);
            }
            mh$.invokeExact(__stream, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static int setvbuf(MemorySegment __stream, MemorySegment __buf, int __modes, long __n) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", __stream, __buf, __modes, __n);
            }
            return (int)mh$.invokeExact(__stream, __buf, __modes, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static void setbuffer(MemorySegment __stream, MemorySegment __buf, long __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", __stream, __buf, __size);
            }
            mh$.invokeExact(__stream, __buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static void setlinebuf(MemorySegment __stream) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                magick_wand_h.C_INT,
                magick_wand_h.C_POINTER,
                magick_wand_h.C_POINTER
            );
        private static final MemorySegment ADDR = magick_wand_h.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int printf(const char *restrict __format, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                magick_wand_h.C_INT,
                magick_wand_h.C_POINTER
            );
        private static final MemorySegment ADDR = magick_wand_h.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int printf(const char *restrict __format, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                magick_wand_h.C_INT,
                magick_wand_h.C_POINTER,
                magick_wand_h.C_POINTER
            );
        private static final MemorySegment ADDR = magick_wand_h.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vprintf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                magick_wand_h.C_INT,
                magick_wand_h.C_POINTER,
                magick_wand_h.C_LONG,
                magick_wand_h.C_POINTER
            );
        private static final MemorySegment ADDR = magick_wand_h.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, long __maxlen, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __s, __maxlen, __format, x3);
                }
                return (int) spreader.invokeExact(__s, __maxlen, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsnprintf(MemorySegment __s, long __maxlen, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __s, __maxlen, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __maxlen, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vasprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("vasprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vasprintf$descriptor() {
        return vasprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vasprintf$handle() {
        return vasprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vasprintf$address() {
        return vasprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static int vasprintf(MemorySegment __ptr, MemorySegment __f, MemorySegment __arg) {
        var mh$ = vasprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vasprintf", __ptr, __f, __arg);
            }
            return (int)mh$.invokeExact(__ptr, __f, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
     * }
     */
    public static class __asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                magick_wand_h.C_INT,
                magick_wand_h.C_POINTER,
                magick_wand_h.C_POINTER
            );
        private static final MemorySegment ADDR = magick_wand_h.findOrThrow("__asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
         * }
         */
        public static __asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __ptr, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__asprintf", __ptr, __fmt, x2);
                }
                return (int) spreader.invokeExact(__ptr, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
     * }
     */
    public static class asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                magick_wand_h.C_INT,
                magick_wand_h.C_POINTER,
                magick_wand_h.C_POINTER
            );
        private static final MemorySegment ADDR = magick_wand_h.findOrThrow("asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
         * }
         */
        public static asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __ptr, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("asprintf", __ptr, __fmt, x2);
                }
                return (int) spreader.invokeExact(__ptr, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static int vdprintf(int __fd, MemorySegment __fmt, MemorySegment __arg) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", __fd, __fmt, __arg);
            }
            return (int)mh$.invokeExact(__fd, __fmt, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int dprintf(int __fd, const char *restrict __fmt, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                magick_wand_h.C_INT,
                magick_wand_h.C_INT,
                magick_wand_h.C_POINTER
            );
        private static final MemorySegment ADDR = magick_wand_h.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int dprintf(int __fd, const char *restrict __fmt, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", __fd, __fmt, x2);
                }
                return (int) spreader.invokeExact(__fd, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                magick_wand_h.C_INT,
                magick_wand_h.C_POINTER,
                magick_wand_h.C_POINTER
            );
        private static final MemorySegment ADDR = magick_wand_h.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int scanf(const char *restrict __format, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                magick_wand_h.C_INT,
                magick_wand_h.C_POINTER
            );
        private static final MemorySegment ADDR = magick_wand_h.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int scanf(const char *restrict __format, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                magick_wand_h.C_INT,
                magick_wand_h.C_POINTER,
                magick_wand_h.C_POINTER
            );
        private static final MemorySegment ADDR = magick_wand_h.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = magick_wand_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = magick_wand_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = magick_wand_h.C_DOUBLE;

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static int fgetc(MemorySegment __stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static int getc(MemorySegment __stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static int getc_unlocked(MemorySegment __stream) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fgetc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc_unlocked$descriptor() {
        return fgetc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc_unlocked$handle() {
        return fgetc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc_unlocked$address() {
        return fgetc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static int fgetc_unlocked(MemorySegment __stream) {
        var mh$ = fgetc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static int fputc(int __c, MemorySegment __stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static int putc(int __c, MemorySegment __stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static int putchar(int __c) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fputc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc_unlocked$descriptor() {
        return fputc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc_unlocked$handle() {
        return fputc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc_unlocked$address() {
        return fputc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int fputc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = fputc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int putc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static int putchar_unlocked(int __c) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static int getw(MemorySegment __stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static int putw(int __w, MemorySegment __stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", __w, __stream);
            }
            return (int)mh$.invokeExact(__w, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment __s, int __n, MemorySegment __stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", __s, __n, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__s, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("__getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor __getdelim$descriptor() {
        return __getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle __getdelim$handle() {
        return __getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment __getdelim$address() {
        return __getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long __getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = __getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __lineptr, MemorySegment __n, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __lineptr, __n, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static int fputs(MemorySegment __s, MemorySegment __stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", __s, __stream);
            }
            return (int)mh$.invokeExact(__s, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static int puts(MemorySegment __s) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", __s);
            }
            return (int)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static int ungetc(int __c, MemorySegment __stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __n, MemorySegment __s) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __n, __s);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fread_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread_unlocked$descriptor() {
        return fread_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread_unlocked$handle() {
        return fread_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread_unlocked$address() {
        return fread_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fwrite_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite_unlocked$descriptor() {
        return fwrite_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite_unlocked$handle() {
        return fwrite_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite_unlocked$address() {
        return fwrite_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fwrite_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fwrite_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static int fseek(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static long ftell(MemorySegment __stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static void rewind(MemorySegment __stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static int fgetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static int fsetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static void clearerr(MemorySegment __stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static int feof(MemorySegment __stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static int ferror(MemorySegment __stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("clearerr_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr_unlocked$descriptor() {
        return clearerr_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr_unlocked$handle() {
        return clearerr_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr_unlocked$address() {
        return clearerr_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static void clearerr_unlocked(MemorySegment __stream) {
        var mh$ = clearerr_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_unlocked", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("feof_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof_unlocked$descriptor() {
        return feof_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle feof_unlocked$handle() {
        return feof_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment feof_unlocked$address() {
        return feof_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static int feof_unlocked(MemorySegment __stream) {
        var mh$ = feof_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ferror_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror_unlocked$descriptor() {
        return ferror_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle ferror_unlocked$handle() {
        return ferror_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment ferror_unlocked$address() {
        return ferror_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static int ferror_unlocked(MemorySegment __stream) {
        var mh$ = ferror_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static void perror(MemorySegment __s) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", __s);
            }
            mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static int fileno(MemorySegment __stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fileno_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno_unlocked$descriptor() {
        return fileno_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fileno_unlocked$handle() {
        return fileno_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fileno_unlocked$address() {
        return fileno_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static int fileno_unlocked(MemorySegment __stream) {
        var mh$ = fileno_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static int pclose(MemorySegment __stream) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen(MemorySegment __command, MemorySegment __modes) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", __command, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__command, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid(MemorySegment __s) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static void flockfile(MemorySegment __stream) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static int ftrylockfile(MemorySegment __stream) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static void funlockfile(MemorySegment __stream) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __uflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("__uflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static FunctionDescriptor __uflow$descriptor() {
        return __uflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MethodHandle __uflow$handle() {
        return __uflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MemorySegment __uflow$address() {
        return __uflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static int __uflow(MemorySegment x0) {
        var mh$ = __uflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__uflow", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("__overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static FunctionDescriptor __overflow$descriptor() {
        return __overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MethodHandle __overflow$handle() {
        return __overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MemorySegment __overflow$address() {
        return __overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static int __overflow(MemorySegment x0, int x1) {
        var mh$ = __overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__overflow", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = magick_wand_h.C_INT;

    private static class __ctype_get_mb_cur_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("__ctype_get_mb_cur_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static FunctionDescriptor __ctype_get_mb_cur_max$descriptor() {
        return __ctype_get_mb_cur_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MethodHandle __ctype_get_mb_cur_max$handle() {
        return __ctype_get_mb_cur_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MemorySegment __ctype_get_mb_cur_max$address() {
        return __ctype_get_mb_cur_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static long __ctype_get_mb_cur_max() {
        var mh$ = __ctype_get_mb_cur_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctype_get_mb_cur_max");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static double atof(MemorySegment __nptr) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", __nptr);
            }
            return (double)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static int atoi(MemorySegment __nptr) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", __nptr);
            }
            return (int)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static long atol(MemorySegment __nptr) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static long atoll(MemorySegment __nptr) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static double strtod(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", __nptr, __endptr);
            }
            return (double)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_FLOAT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static float strtof(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", __nptr, __endptr);
            }
            return (float)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a(long __n) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", __n);
            }
            return (MemorySegment)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static long a64l(MemorySegment __s) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = magick_wand_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = magick_wand_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfLong nlink_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = magick_wand_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = magick_wand_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = magick_wand_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = magick_wand_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = magick_wand_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = magick_wand_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = magick_wand_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = magick_wand_h.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfLong blksize_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = magick_wand_h.C_INT;

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static void srandom(int __seed) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate(int __seed, MemorySegment __statebuf, long __statelen) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", __seed, __statebuf, __statelen);
            }
            return (MemorySegment)mh$.invokeExact(__seed, __statebuf, __statelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate(MemorySegment __statebuf) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", __statebuf);
            }
            return (MemorySegment)mh$.invokeExact(__statebuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("random_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static FunctionDescriptor random_r$descriptor() {
        return random_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MethodHandle random_r$handle() {
        return random_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MemorySegment random_r$address() {
        return random_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static int random_r(MemorySegment __buf, MemorySegment __result) {
        var mh$ = random_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random_r", __buf, __result);
            }
            return (int)mh$.invokeExact(__buf, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("srandom_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static FunctionDescriptor srandom_r$descriptor() {
        return srandom_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MethodHandle srandom_r$handle() {
        return srandom_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MemorySegment srandom_r$address() {
        return srandom_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static int srandom_r(int __seed, MemorySegment __buf) {
        var mh$ = srandom_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom_r", __seed, __buf);
            }
            return (int)mh$.invokeExact(__seed, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("initstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor initstate_r$descriptor() {
        return initstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle initstate_r$handle() {
        return initstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment initstate_r$address() {
        return initstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static int initstate_r(int __seed, MemorySegment __statebuf, long __statelen, MemorySegment __buf) {
        var mh$ = initstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate_r", __seed, __statebuf, __statelen, __buf);
            }
            return (int)mh$.invokeExact(__seed, __statebuf, __statelen, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("setstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor setstate_r$descriptor() {
        return setstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle setstate_r$handle() {
        return setstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment setstate_r$address() {
        return setstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static int setstate_r(MemorySegment __statebuf, MemorySegment __buf) {
        var mh$ = setstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate_r", __statebuf, __buf);
            }
            return (int)mh$.invokeExact(__statebuf, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static void srand(int __seed) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static int rand_r(MemorySegment __seed) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", __seed);
            }
            return (int)mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static double erand48(MemorySegment __xsubi) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", __xsubi);
            }
            return (double)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static long nrand48(MemorySegment __xsubi) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static long jrand48(MemorySegment __xsubi) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static void srand48(long __seedval) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", __seedval);
            }
            mh$.invokeExact(__seedval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48(MemorySegment __seed16v) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", __seed16v);
            }
            return (MemorySegment)mh$.invokeExact(__seed16v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static void lcong48(MemorySegment __param) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", __param);
            }
            mh$.invokeExact(__param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("drand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor drand48_r$descriptor() {
        return drand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle drand48_r$handle() {
        return drand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment drand48_r$address() {
        return drand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int drand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = drand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("erand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor erand48_r$descriptor() {
        return erand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle erand48_r$handle() {
        return erand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment erand48_r$address() {
        return erand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int erand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = erand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("lrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor lrand48_r$descriptor() {
        return lrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle lrand48_r$handle() {
        return lrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment lrand48_r$address() {
        return lrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int lrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = lrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("nrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor nrand48_r$descriptor() {
        return nrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle nrand48_r$handle() {
        return nrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment nrand48_r$address() {
        return nrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int nrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = nrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("mrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor mrand48_r$descriptor() {
        return mrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle mrand48_r$handle() {
        return mrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment mrand48_r$address() {
        return mrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int mrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = mrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("jrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor jrand48_r$descriptor() {
        return jrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle jrand48_r$handle() {
        return jrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment jrand48_r$address() {
        return jrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int jrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = jrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("srand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor srand48_r$descriptor() {
        return srand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle srand48_r$handle() {
        return srand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment srand48_r$address() {
        return srand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static int srand48_r(long __seedval, MemorySegment __buffer) {
        var mh$ = srand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48_r", __seedval, __buffer);
            }
            return (int)mh$.invokeExact(__seedval, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("seed48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor seed48_r$descriptor() {
        return seed48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle seed48_r$handle() {
        return seed48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment seed48_r$address() {
        return seed48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static int seed48_r(MemorySegment __seed16v, MemorySegment __buffer) {
        var mh$ = seed48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48_r", __seed16v, __buffer);
            }
            return (int)mh$.invokeExact(__seed16v, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("lcong48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor lcong48_r$descriptor() {
        return lcong48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle lcong48_r$handle() {
        return lcong48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment lcong48_r$address() {
        return lcong48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static int lcong48_r(MemorySegment __param, MemorySegment __buffer) {
        var mh$ = lcong48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48_r", __param, __buffer);
            }
            return (int)mh$.invokeExact(__param, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __size) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __size);
            }
            mh$.invokeExact(__buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __nmemb, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static void free(MemorySegment __ptr) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", __ptr);
            }
            mh$.invokeExact(__ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("reallocarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocarray$descriptor() {
        return reallocarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle reallocarray$handle() {
        return reallocarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray$address() {
        return reallocarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray(MemorySegment __ptr, long __nmemb, long __size) {
        var mh$ = reallocarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocarray", __ptr, __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca(long __size) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static int atexit(MemorySegment __func) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment __func) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class on_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("on_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static FunctionDescriptor on_exit$descriptor() {
        return on_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MethodHandle on_exit$handle() {
        return on_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MemorySegment on_exit$address() {
        return on_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static int on_exit(MemorySegment __func, MemorySegment __arg) {
        var mh$ = on_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("on_exit", __func, __arg);
            }
            return (int)mh$.invokeExact(__func, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static void exit(int __status) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static void quick_exit(int __status) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static void _Exit(int __status) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv(MemorySegment __name) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static int putenv(MemorySegment __string) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", __string);
            }
            return (int)mh$.invokeExact(__string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __replace) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __replace);
            }
            return (int)mh$.invokeExact(__name, __value, __replace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static int unsetenv(MemorySegment __name) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("clearenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static FunctionDescriptor clearenv$descriptor() {
        return clearenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MethodHandle clearenv$handle() {
        return clearenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MemorySegment clearenv$address() {
        return clearenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static int clearenv() {
        var mh$ = clearenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearenv");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp(MemorySegment __template) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static int mkstemp(MemorySegment __template) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", __template);
            }
            return (int)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("mkstemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MemorySegment mkstemps$address() {
        return mkstemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static int mkstemps(MemorySegment __template, int __suffixlen) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", __template, __suffixlen);
            }
            return (int)mh$.invokeExact(__template, __suffixlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("mkdtemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp$address() {
        return mkdtemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment __template) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static int system(MemorySegment __command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", __command);
            }
            return (int)mh$.invokeExact(__command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("realpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath(MemorySegment __name, MemorySegment __resolved) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", __name, __resolved);
            }
            return (MemorySegment)mh$.invokeExact(__name, __resolved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nmemb, __size, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static void qsort(MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nmemb, __size, __compar);
            }
            mh$.invokeExact(__base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static int abs(int __x) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static long labs(long __x) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG_LONG,
            magick_wand_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static long llabs(long __x) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            magick_wand_h.C_INT,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int __numer, int __denom) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            magick_wand_h.C_LONG_LONG,
            magick_wand_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt(double __value, int __ndigit, MemorySegment __buf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", __value, __ndigit, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ecvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor ecvt_r$descriptor() {
        return ecvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle ecvt_r$handle() {
        return ecvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment ecvt_r$address() {
        return ecvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int ecvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = ecvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("fcvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor fcvt_r$descriptor() {
        return fcvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle fcvt_r$handle() {
        return fcvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment fcvt_r$address() {
        return fcvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int fcvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = fcvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static int mbtowc(MemorySegment __pwc, MemorySegment __s, long __n) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", __pwc, __s, __n);
            }
            return (int)mh$.invokeExact(__pwc, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static int wctomb(MemorySegment __s, int __wchar) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", __s, __wchar);
            }
            return (int)mh$.invokeExact(__s, __wchar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static long mbstowcs(MemorySegment __pwcs, MemorySegment __s, long __n) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", __pwcs, __s, __n);
            }
            return (long)mh$.invokeExact(__pwcs, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static long wcstombs(MemorySegment __s, MemorySegment __pwcs, long __n) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", __s, __pwcs, __n);
            }
            return (long)mh$.invokeExact(__s, __pwcs, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static int rpmatch(MemorySegment __response) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", __response);
            }
            return (int)mh$.invokeExact(__response);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static int getsubopt(MemorySegment __optionp, MemorySegment __tokens, MemorySegment __valuep) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", __optionp, __tokens, __valuep);
            }
            return (int)mh$.invokeExact(__optionp, __tokens, __valuep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static int getloadavg(MemorySegment __loadavg, int __nelem) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", __loadavg, __nelem);
            }
            return (int)mh$.invokeExact(__loadavg, __nelem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef signed char magick_int8_t
     * }
     */
    public static final OfByte magick_int8_t = magick_wand_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char magick_uint8_t
     * }
     */
    public static final OfByte magick_uint8_t = magick_wand_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short magick_int16_t
     * }
     */
    public static final OfShort magick_int16_t = magick_wand_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short magick_uint16_t
     * }
     */
    public static final OfShort magick_uint16_t = magick_wand_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int magick_int32_t
     * }
     */
    public static final OfInt magick_int32_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int magick_uint32_t
     * }
     */
    public static final OfInt magick_uint32_t = magick_wand_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long magick_int64_t
     * }
     */
    public static final OfLong magick_int64_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long magick_uint64_t
     * }
     */
    public static final OfLong magick_uint64_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef magick_int64_t magick_off_t
     * }
     */
    public static final OfLong magick_off_t = magick_wand_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _Image *ImagePtr
     * }
     */
    public static final AddressLayout ImagePtr = magick_wand_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _Ascii85Info *_Ascii85InfoPtr_
     * }
     */
    public static final AddressLayout _Ascii85InfoPtr_ = magick_wand_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BlobInfo *_BlobInfoPtr_
     * }
     */
    public static final AddressLayout _BlobInfoPtr_ = magick_wand_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CacheInfo *_CacheInfoPtr_
     * }
     */
    public static final AddressLayout _CacheInfoPtr_ = magick_wand_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ImageAttribute *_ImageAttributePtr_
     * }
     */
    public static final AddressLayout _ImageAttributePtr_ = magick_wand_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SemaphoreInfo *_SemaphoreInfoPtr_
     * }
     */
    public static final AddressLayout _SemaphoreInfoPtr_ = magick_wand_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ThreadViewSet *_ThreadViewSetPtr_
     * }
     */
    public static final AddressLayout _ThreadViewSetPtr_ = magick_wand_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *ViewInfo
     * }
     */
    public static final AddressLayout ViewInfo = magick_wand_h.C_POINTER;
    private static final int UndefinedColorspace = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedColorspace = 0
     * }
     */
    public static int UndefinedColorspace() {
        return UndefinedColorspace;
    }
    private static final int RGBColorspace = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RGBColorspace = 1
     * }
     */
    public static int RGBColorspace() {
        return RGBColorspace;
    }
    private static final int GRAYColorspace = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GRAYColorspace = 2
     * }
     */
    public static int GRAYColorspace() {
        return GRAYColorspace;
    }
    private static final int TransparentColorspace = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TransparentColorspace = 3
     * }
     */
    public static int TransparentColorspace() {
        return TransparentColorspace;
    }
    private static final int OHTAColorspace = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OHTAColorspace = 4
     * }
     */
    public static int OHTAColorspace() {
        return OHTAColorspace;
    }
    private static final int XYZColorspace = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.XYZColorspace = 5
     * }
     */
    public static int XYZColorspace() {
        return XYZColorspace;
    }
    private static final int YCCColorspace = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.YCCColorspace = 6
     * }
     */
    public static int YCCColorspace() {
        return YCCColorspace;
    }
    private static final int YIQColorspace = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.YIQColorspace = 7
     * }
     */
    public static int YIQColorspace() {
        return YIQColorspace;
    }
    private static final int YPbPrColorspace = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.YPbPrColorspace = 8
     * }
     */
    public static int YPbPrColorspace() {
        return YPbPrColorspace;
    }
    private static final int YUVColorspace = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.YUVColorspace = 9
     * }
     */
    public static int YUVColorspace() {
        return YUVColorspace;
    }
    private static final int CMYKColorspace = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CMYKColorspace = 10
     * }
     */
    public static int CMYKColorspace() {
        return CMYKColorspace;
    }
    private static final int sRGBColorspace = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.sRGBColorspace = 11
     * }
     */
    public static int sRGBColorspace() {
        return sRGBColorspace;
    }
    private static final int HSLColorspace = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HSLColorspace = 12
     * }
     */
    public static int HSLColorspace() {
        return HSLColorspace;
    }
    private static final int HWBColorspace = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HWBColorspace = 13
     * }
     */
    public static int HWBColorspace() {
        return HWBColorspace;
    }
    private static final int LABColorspace = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LABColorspace = 14
     * }
     */
    public static int LABColorspace() {
        return LABColorspace;
    }
    private static final int CineonLogRGBColorspace = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CineonLogRGBColorspace = 15
     * }
     */
    public static int CineonLogRGBColorspace() {
        return CineonLogRGBColorspace;
    }
    private static final int Rec601LumaColorspace = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.Rec601LumaColorspace = 16
     * }
     */
    public static int Rec601LumaColorspace() {
        return Rec601LumaColorspace;
    }
    private static final int Rec601YCbCrColorspace = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.Rec601YCbCrColorspace = 17
     * }
     */
    public static int Rec601YCbCrColorspace() {
        return Rec601YCbCrColorspace;
    }
    private static final int Rec709LumaColorspace = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.Rec709LumaColorspace = 18
     * }
     */
    public static int Rec709LumaColorspace() {
        return Rec709LumaColorspace;
    }
    private static final int Rec709YCbCrColorspace = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.Rec709YCbCrColorspace = 19
     * }
     */
    public static int Rec709YCbCrColorspace() {
        return Rec709YCbCrColorspace;
    }

    private static class RGBTransformImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("RGBTransformImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int RGBTransformImage(ImagePtr, const ColorspaceType)
     * }
     */
    public static FunctionDescriptor RGBTransformImage$descriptor() {
        return RGBTransformImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int RGBTransformImage(ImagePtr, const ColorspaceType)
     * }
     */
    public static MethodHandle RGBTransformImage$handle() {
        return RGBTransformImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int RGBTransformImage(ImagePtr, const ColorspaceType)
     * }
     */
    public static MemorySegment RGBTransformImage$address() {
        return RGBTransformImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int RGBTransformImage(ImagePtr, const ColorspaceType)
     * }
     */
    public static int RGBTransformImage(MemorySegment x0, int x1) {
        var mh$ = RGBTransformImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RGBTransformImage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransformColorspace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("TransformColorspace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int TransformColorspace(ImagePtr, const ColorspaceType)
     * }
     */
    public static FunctionDescriptor TransformColorspace$descriptor() {
        return TransformColorspace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int TransformColorspace(ImagePtr, const ColorspaceType)
     * }
     */
    public static MethodHandle TransformColorspace$handle() {
        return TransformColorspace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int TransformColorspace(ImagePtr, const ColorspaceType)
     * }
     */
    public static MemorySegment TransformColorspace$address() {
        return TransformColorspace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int TransformColorspace(ImagePtr, const ColorspaceType)
     * }
     */
    public static int TransformColorspace(MemorySegment x0, int x1) {
        var mh$ = TransformColorspace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransformColorspace", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransformRGBImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("TransformRGBImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int TransformRGBImage(ImagePtr, const ColorspaceType)
     * }
     */
    public static FunctionDescriptor TransformRGBImage$descriptor() {
        return TransformRGBImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int TransformRGBImage(ImagePtr, const ColorspaceType)
     * }
     */
    public static MethodHandle TransformRGBImage$handle() {
        return TransformRGBImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int TransformRGBImage(ImagePtr, const ColorspaceType)
     * }
     */
    public static MemorySegment TransformRGBImage$address() {
        return TransformRGBImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int TransformRGBImage(ImagePtr, const ColorspaceType)
     * }
     */
    public static int TransformRGBImage(MemorySegment x0, int x1) {
        var mh$ = TransformRGBImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransformRGBImage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UndefinedExceptionBase = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedExceptionBase = 0
     * }
     */
    public static int UndefinedExceptionBase() {
        return UndefinedExceptionBase;
    }
    private static final int ExceptionBase = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ExceptionBase = 1
     * }
     */
    public static int ExceptionBase() {
        return ExceptionBase;
    }
    private static final int ResourceBase = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ResourceBase = 2
     * }
     */
    public static int ResourceBase() {
        return ResourceBase;
    }
    private static final int ResourceLimitBase = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ResourceLimitBase = 2
     * }
     */
    public static int ResourceLimitBase() {
        return ResourceLimitBase;
    }
    private static final int TypeBase = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TypeBase = 5
     * }
     */
    public static int TypeBase() {
        return TypeBase;
    }
    private static final int AnnotateBase = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AnnotateBase = 5
     * }
     */
    public static int AnnotateBase() {
        return AnnotateBase;
    }
    private static final int OptionBase = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OptionBase = 10
     * }
     */
    public static int OptionBase() {
        return OptionBase;
    }
    private static final int DelegateBase = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DelegateBase = 15
     * }
     */
    public static int DelegateBase() {
        return DelegateBase;
    }
    private static final int MissingDelegateBase = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MissingDelegateBase = 20
     * }
     */
    public static int MissingDelegateBase() {
        return MissingDelegateBase;
    }
    private static final int CorruptImageBase = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CorruptImageBase = 25
     * }
     */
    public static int CorruptImageBase() {
        return CorruptImageBase;
    }
    private static final int FileOpenBase = (int)30L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FileOpenBase = 30
     * }
     */
    public static int FileOpenBase() {
        return FileOpenBase;
    }
    private static final int BlobBase = (int)35L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BlobBase = 35
     * }
     */
    public static int BlobBase() {
        return BlobBase;
    }
    private static final int StreamBase = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.StreamBase = 40
     * }
     */
    public static int StreamBase() {
        return StreamBase;
    }
    private static final int CacheBase = (int)45L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CacheBase = 45
     * }
     */
    public static int CacheBase() {
        return CacheBase;
    }
    private static final int CoderBase = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CoderBase = 50
     * }
     */
    public static int CoderBase() {
        return CoderBase;
    }
    private static final int ModuleBase = (int)55L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ModuleBase = 55
     * }
     */
    public static int ModuleBase() {
        return ModuleBase;
    }
    private static final int DrawBase = (int)60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DrawBase = 60
     * }
     */
    public static int DrawBase() {
        return DrawBase;
    }
    private static final int RenderBase = (int)60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RenderBase = 60
     * }
     */
    public static int RenderBase() {
        return RenderBase;
    }
    private static final int ImageBase = (int)65L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ImageBase = 65
     * }
     */
    public static int ImageBase() {
        return ImageBase;
    }
    private static final int WandBase = (int)67L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WandBase = 67
     * }
     */
    public static int WandBase() {
        return WandBase;
    }
    private static final int TemporaryFileBase = (int)70L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TemporaryFileBase = 70
     * }
     */
    public static int TemporaryFileBase() {
        return TemporaryFileBase;
    }
    private static final int TransformBase = (int)75L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TransformBase = 75
     * }
     */
    public static int TransformBase() {
        return TransformBase;
    }
    private static final int XServerBase = (int)80L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.XServerBase = 80
     * }
     */
    public static int XServerBase() {
        return XServerBase;
    }
    private static final int X11Base = (int)81L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.X11Base = 81
     * }
     */
    public static int X11Base() {
        return X11Base;
    }
    private static final int UserBase = (int)82L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UserBase = 82
     * }
     */
    public static int UserBase() {
        return UserBase;
    }
    private static final int MonitorBase = (int)85L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MonitorBase = 85
     * }
     */
    public static int MonitorBase() {
        return MonitorBase;
    }
    private static final int LocaleBase = (int)86L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LocaleBase = 86
     * }
     */
    public static int LocaleBase() {
        return LocaleBase;
    }
    private static final int DeprecateBase = (int)87L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DeprecateBase = 87
     * }
     */
    public static int DeprecateBase() {
        return DeprecateBase;
    }
    private static final int RegistryBase = (int)90L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RegistryBase = 90
     * }
     */
    public static int RegistryBase() {
        return RegistryBase;
    }
    private static final int ConfigureBase = (int)95L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ConfigureBase = 95
     * }
     */
    public static int ConfigureBase() {
        return ConfigureBase;
    }
    private static final int UndefinedException = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedException = 0
     * }
     */
    public static int UndefinedException() {
        return UndefinedException;
    }
    private static final int EventException = (int)100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EventException = 100
     * }
     */
    public static int EventException() {
        return EventException;
    }
    private static final int ExceptionEvent = (int)101L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ExceptionEvent = 101
     * }
     */
    public static int ExceptionEvent() {
        return ExceptionEvent;
    }
    private static final int ResourceEvent = (int)102L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ResourceEvent = 102
     * }
     */
    public static int ResourceEvent() {
        return ResourceEvent;
    }
    private static final int ResourceLimitEvent = (int)102L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ResourceLimitEvent = 102
     * }
     */
    public static int ResourceLimitEvent() {
        return ResourceLimitEvent;
    }
    private static final int TypeEvent = (int)105L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TypeEvent = 105
     * }
     */
    public static int TypeEvent() {
        return TypeEvent;
    }
    private static final int AnnotateEvent = (int)105L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AnnotateEvent = 105
     * }
     */
    public static int AnnotateEvent() {
        return AnnotateEvent;
    }
    private static final int OptionEvent = (int)110L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OptionEvent = 110
     * }
     */
    public static int OptionEvent() {
        return OptionEvent;
    }
    private static final int DelegateEvent = (int)115L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DelegateEvent = 115
     * }
     */
    public static int DelegateEvent() {
        return DelegateEvent;
    }
    private static final int MissingDelegateEvent = (int)120L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MissingDelegateEvent = 120
     * }
     */
    public static int MissingDelegateEvent() {
        return MissingDelegateEvent;
    }
    private static final int CorruptImageEvent = (int)125L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CorruptImageEvent = 125
     * }
     */
    public static int CorruptImageEvent() {
        return CorruptImageEvent;
    }
    private static final int FileOpenEvent = (int)130L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FileOpenEvent = 130
     * }
     */
    public static int FileOpenEvent() {
        return FileOpenEvent;
    }
    private static final int BlobEvent = (int)135L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BlobEvent = 135
     * }
     */
    public static int BlobEvent() {
        return BlobEvent;
    }
    private static final int StreamEvent = (int)140L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.StreamEvent = 140
     * }
     */
    public static int StreamEvent() {
        return StreamEvent;
    }
    private static final int CacheEvent = (int)145L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CacheEvent = 145
     * }
     */
    public static int CacheEvent() {
        return CacheEvent;
    }
    private static final int CoderEvent = (int)150L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CoderEvent = 150
     * }
     */
    public static int CoderEvent() {
        return CoderEvent;
    }
    private static final int ModuleEvent = (int)155L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ModuleEvent = 155
     * }
     */
    public static int ModuleEvent() {
        return ModuleEvent;
    }
    private static final int DrawEvent = (int)160L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DrawEvent = 160
     * }
     */
    public static int DrawEvent() {
        return DrawEvent;
    }
    private static final int RenderEvent = (int)160L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RenderEvent = 160
     * }
     */
    public static int RenderEvent() {
        return RenderEvent;
    }
    private static final int ImageEvent = (int)165L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ImageEvent = 165
     * }
     */
    public static int ImageEvent() {
        return ImageEvent;
    }
    private static final int WandEvent = (int)167L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WandEvent = 167
     * }
     */
    public static int WandEvent() {
        return WandEvent;
    }
    private static final int TemporaryFileEvent = (int)170L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TemporaryFileEvent = 170
     * }
     */
    public static int TemporaryFileEvent() {
        return TemporaryFileEvent;
    }
    private static final int TransformEvent = (int)175L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TransformEvent = 175
     * }
     */
    public static int TransformEvent() {
        return TransformEvent;
    }
    private static final int XServerEvent = (int)180L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.XServerEvent = 180
     * }
     */
    public static int XServerEvent() {
        return XServerEvent;
    }
    private static final int X11Event = (int)181L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.X11Event = 181
     * }
     */
    public static int X11Event() {
        return X11Event;
    }
    private static final int UserEvent = (int)182L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UserEvent = 182
     * }
     */
    public static int UserEvent() {
        return UserEvent;
    }
    private static final int MonitorEvent = (int)185L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MonitorEvent = 185
     * }
     */
    public static int MonitorEvent() {
        return MonitorEvent;
    }
    private static final int LocaleEvent = (int)186L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LocaleEvent = 186
     * }
     */
    public static int LocaleEvent() {
        return LocaleEvent;
    }
    private static final int DeprecateEvent = (int)187L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DeprecateEvent = 187
     * }
     */
    public static int DeprecateEvent() {
        return DeprecateEvent;
    }
    private static final int RegistryEvent = (int)190L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RegistryEvent = 190
     * }
     */
    public static int RegistryEvent() {
        return RegistryEvent;
    }
    private static final int ConfigureEvent = (int)195L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ConfigureEvent = 195
     * }
     */
    public static int ConfigureEvent() {
        return ConfigureEvent;
    }
    private static final int WarningException = (int)300L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WarningException = 300
     * }
     */
    public static int WarningException() {
        return WarningException;
    }
    private static final int ExceptionWarning = (int)301L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ExceptionWarning = 301
     * }
     */
    public static int ExceptionWarning() {
        return ExceptionWarning;
    }
    private static final int ResourceWarning = (int)302L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ResourceWarning = 302
     * }
     */
    public static int ResourceWarning() {
        return ResourceWarning;
    }
    private static final int ResourceLimitWarning = (int)302L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ResourceLimitWarning = 302
     * }
     */
    public static int ResourceLimitWarning() {
        return ResourceLimitWarning;
    }
    private static final int TypeWarning = (int)305L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TypeWarning = 305
     * }
     */
    public static int TypeWarning() {
        return TypeWarning;
    }
    private static final int AnnotateWarning = (int)305L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AnnotateWarning = 305
     * }
     */
    public static int AnnotateWarning() {
        return AnnotateWarning;
    }
    private static final int OptionWarning = (int)310L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OptionWarning = 310
     * }
     */
    public static int OptionWarning() {
        return OptionWarning;
    }
    private static final int DelegateWarning = (int)315L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DelegateWarning = 315
     * }
     */
    public static int DelegateWarning() {
        return DelegateWarning;
    }
    private static final int MissingDelegateWarning = (int)320L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MissingDelegateWarning = 320
     * }
     */
    public static int MissingDelegateWarning() {
        return MissingDelegateWarning;
    }
    private static final int CorruptImageWarning = (int)325L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CorruptImageWarning = 325
     * }
     */
    public static int CorruptImageWarning() {
        return CorruptImageWarning;
    }
    private static final int FileOpenWarning = (int)330L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FileOpenWarning = 330
     * }
     */
    public static int FileOpenWarning() {
        return FileOpenWarning;
    }
    private static final int BlobWarning = (int)335L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BlobWarning = 335
     * }
     */
    public static int BlobWarning() {
        return BlobWarning;
    }
    private static final int StreamWarning = (int)340L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.StreamWarning = 340
     * }
     */
    public static int StreamWarning() {
        return StreamWarning;
    }
    private static final int CacheWarning = (int)345L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CacheWarning = 345
     * }
     */
    public static int CacheWarning() {
        return CacheWarning;
    }
    private static final int CoderWarning = (int)350L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CoderWarning = 350
     * }
     */
    public static int CoderWarning() {
        return CoderWarning;
    }
    private static final int ModuleWarning = (int)355L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ModuleWarning = 355
     * }
     */
    public static int ModuleWarning() {
        return ModuleWarning;
    }
    private static final int DrawWarning = (int)360L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DrawWarning = 360
     * }
     */
    public static int DrawWarning() {
        return DrawWarning;
    }
    private static final int RenderWarning = (int)360L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RenderWarning = 360
     * }
     */
    public static int RenderWarning() {
        return RenderWarning;
    }
    private static final int ImageWarning = (int)365L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ImageWarning = 365
     * }
     */
    public static int ImageWarning() {
        return ImageWarning;
    }
    private static final int WandWarning = (int)367L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WandWarning = 367
     * }
     */
    public static int WandWarning() {
        return WandWarning;
    }
    private static final int TemporaryFileWarning = (int)370L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TemporaryFileWarning = 370
     * }
     */
    public static int TemporaryFileWarning() {
        return TemporaryFileWarning;
    }
    private static final int TransformWarning = (int)375L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TransformWarning = 375
     * }
     */
    public static int TransformWarning() {
        return TransformWarning;
    }
    private static final int XServerWarning = (int)380L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.XServerWarning = 380
     * }
     */
    public static int XServerWarning() {
        return XServerWarning;
    }
    private static final int X11Warning = (int)381L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.X11Warning = 381
     * }
     */
    public static int X11Warning() {
        return X11Warning;
    }
    private static final int UserWarning = (int)382L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UserWarning = 382
     * }
     */
    public static int UserWarning() {
        return UserWarning;
    }
    private static final int MonitorWarning = (int)385L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MonitorWarning = 385
     * }
     */
    public static int MonitorWarning() {
        return MonitorWarning;
    }
    private static final int LocaleWarning = (int)386L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LocaleWarning = 386
     * }
     */
    public static int LocaleWarning() {
        return LocaleWarning;
    }
    private static final int DeprecateWarning = (int)387L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DeprecateWarning = 387
     * }
     */
    public static int DeprecateWarning() {
        return DeprecateWarning;
    }
    private static final int RegistryWarning = (int)390L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RegistryWarning = 390
     * }
     */
    public static int RegistryWarning() {
        return RegistryWarning;
    }
    private static final int ConfigureWarning = (int)395L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ConfigureWarning = 395
     * }
     */
    public static int ConfigureWarning() {
        return ConfigureWarning;
    }
    private static final int ErrorException = (int)400L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ErrorException = 400
     * }
     */
    public static int ErrorException() {
        return ErrorException;
    }
    private static final int ExceptionError = (int)401L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ExceptionError = 401
     * }
     */
    public static int ExceptionError() {
        return ExceptionError;
    }
    private static final int ResourceError = (int)402L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ResourceError = 402
     * }
     */
    public static int ResourceError() {
        return ResourceError;
    }
    private static final int ResourceLimitError = (int)402L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ResourceLimitError = 402
     * }
     */
    public static int ResourceLimitError() {
        return ResourceLimitError;
    }
    private static final int TypeError = (int)405L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TypeError = 405
     * }
     */
    public static int TypeError() {
        return TypeError;
    }
    private static final int AnnotateError = (int)405L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AnnotateError = 405
     * }
     */
    public static int AnnotateError() {
        return AnnotateError;
    }
    private static final int OptionError = (int)410L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OptionError = 410
     * }
     */
    public static int OptionError() {
        return OptionError;
    }
    private static final int DelegateError = (int)415L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DelegateError = 415
     * }
     */
    public static int DelegateError() {
        return DelegateError;
    }
    private static final int MissingDelegateError = (int)420L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MissingDelegateError = 420
     * }
     */
    public static int MissingDelegateError() {
        return MissingDelegateError;
    }
    private static final int CorruptImageError = (int)425L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CorruptImageError = 425
     * }
     */
    public static int CorruptImageError() {
        return CorruptImageError;
    }
    private static final int FileOpenError = (int)430L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FileOpenError = 430
     * }
     */
    public static int FileOpenError() {
        return FileOpenError;
    }
    private static final int BlobError = (int)435L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BlobError = 435
     * }
     */
    public static int BlobError() {
        return BlobError;
    }
    private static final int StreamError = (int)440L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.StreamError = 440
     * }
     */
    public static int StreamError() {
        return StreamError;
    }
    private static final int CacheError = (int)445L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CacheError = 445
     * }
     */
    public static int CacheError() {
        return CacheError;
    }
    private static final int CoderError = (int)450L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CoderError = 450
     * }
     */
    public static int CoderError() {
        return CoderError;
    }
    private static final int ModuleError = (int)455L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ModuleError = 455
     * }
     */
    public static int ModuleError() {
        return ModuleError;
    }
    private static final int DrawError = (int)460L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DrawError = 460
     * }
     */
    public static int DrawError() {
        return DrawError;
    }
    private static final int RenderError = (int)460L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RenderError = 460
     * }
     */
    public static int RenderError() {
        return RenderError;
    }
    private static final int ImageError = (int)465L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ImageError = 465
     * }
     */
    public static int ImageError() {
        return ImageError;
    }
    private static final int WandError = (int)467L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WandError = 467
     * }
     */
    public static int WandError() {
        return WandError;
    }
    private static final int TemporaryFileError = (int)470L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TemporaryFileError = 470
     * }
     */
    public static int TemporaryFileError() {
        return TemporaryFileError;
    }
    private static final int TransformError = (int)475L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TransformError = 475
     * }
     */
    public static int TransformError() {
        return TransformError;
    }
    private static final int XServerError = (int)480L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.XServerError = 480
     * }
     */
    public static int XServerError() {
        return XServerError;
    }
    private static final int X11Error = (int)481L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.X11Error = 481
     * }
     */
    public static int X11Error() {
        return X11Error;
    }
    private static final int UserError = (int)482L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UserError = 482
     * }
     */
    public static int UserError() {
        return UserError;
    }
    private static final int MonitorError = (int)485L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MonitorError = 485
     * }
     */
    public static int MonitorError() {
        return MonitorError;
    }
    private static final int LocaleError = (int)486L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LocaleError = 486
     * }
     */
    public static int LocaleError() {
        return LocaleError;
    }
    private static final int DeprecateError = (int)487L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DeprecateError = 487
     * }
     */
    public static int DeprecateError() {
        return DeprecateError;
    }
    private static final int RegistryError = (int)490L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RegistryError = 490
     * }
     */
    public static int RegistryError() {
        return RegistryError;
    }
    private static final int ConfigureError = (int)495L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ConfigureError = 495
     * }
     */
    public static int ConfigureError() {
        return ConfigureError;
    }
    private static final int FatalErrorException = (int)700L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FatalErrorException = 700
     * }
     */
    public static int FatalErrorException() {
        return FatalErrorException;
    }
    private static final int ExceptionFatalError = (int)701L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ExceptionFatalError = 701
     * }
     */
    public static int ExceptionFatalError() {
        return ExceptionFatalError;
    }
    private static final int ResourceFatalError = (int)702L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ResourceFatalError = 702
     * }
     */
    public static int ResourceFatalError() {
        return ResourceFatalError;
    }
    private static final int ResourceLimitFatalError = (int)702L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ResourceLimitFatalError = 702
     * }
     */
    public static int ResourceLimitFatalError() {
        return ResourceLimitFatalError;
    }
    private static final int TypeFatalError = (int)705L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TypeFatalError = 705
     * }
     */
    public static int TypeFatalError() {
        return TypeFatalError;
    }
    private static final int AnnotateFatalError = (int)705L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AnnotateFatalError = 705
     * }
     */
    public static int AnnotateFatalError() {
        return AnnotateFatalError;
    }
    private static final int OptionFatalError = (int)710L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OptionFatalError = 710
     * }
     */
    public static int OptionFatalError() {
        return OptionFatalError;
    }
    private static final int DelegateFatalError = (int)715L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DelegateFatalError = 715
     * }
     */
    public static int DelegateFatalError() {
        return DelegateFatalError;
    }
    private static final int MissingDelegateFatalError = (int)720L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MissingDelegateFatalError = 720
     * }
     */
    public static int MissingDelegateFatalError() {
        return MissingDelegateFatalError;
    }
    private static final int CorruptImageFatalError = (int)725L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CorruptImageFatalError = 725
     * }
     */
    public static int CorruptImageFatalError() {
        return CorruptImageFatalError;
    }
    private static final int FileOpenFatalError = (int)730L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FileOpenFatalError = 730
     * }
     */
    public static int FileOpenFatalError() {
        return FileOpenFatalError;
    }
    private static final int BlobFatalError = (int)735L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BlobFatalError = 735
     * }
     */
    public static int BlobFatalError() {
        return BlobFatalError;
    }
    private static final int StreamFatalError = (int)740L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.StreamFatalError = 740
     * }
     */
    public static int StreamFatalError() {
        return StreamFatalError;
    }
    private static final int CacheFatalError = (int)745L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CacheFatalError = 745
     * }
     */
    public static int CacheFatalError() {
        return CacheFatalError;
    }
    private static final int CoderFatalError = (int)750L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CoderFatalError = 750
     * }
     */
    public static int CoderFatalError() {
        return CoderFatalError;
    }
    private static final int ModuleFatalError = (int)755L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ModuleFatalError = 755
     * }
     */
    public static int ModuleFatalError() {
        return ModuleFatalError;
    }
    private static final int DrawFatalError = (int)760L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DrawFatalError = 760
     * }
     */
    public static int DrawFatalError() {
        return DrawFatalError;
    }
    private static final int RenderFatalError = (int)760L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RenderFatalError = 760
     * }
     */
    public static int RenderFatalError() {
        return RenderFatalError;
    }
    private static final int ImageFatalError = (int)765L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ImageFatalError = 765
     * }
     */
    public static int ImageFatalError() {
        return ImageFatalError;
    }
    private static final int WandFatalError = (int)767L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WandFatalError = 767
     * }
     */
    public static int WandFatalError() {
        return WandFatalError;
    }
    private static final int TemporaryFileFatalError = (int)770L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TemporaryFileFatalError = 770
     * }
     */
    public static int TemporaryFileFatalError() {
        return TemporaryFileFatalError;
    }
    private static final int TransformFatalError = (int)775L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TransformFatalError = 775
     * }
     */
    public static int TransformFatalError() {
        return TransformFatalError;
    }
    private static final int XServerFatalError = (int)780L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.XServerFatalError = 780
     * }
     */
    public static int XServerFatalError() {
        return XServerFatalError;
    }
    private static final int X11FatalError = (int)781L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.X11FatalError = 781
     * }
     */
    public static int X11FatalError() {
        return X11FatalError;
    }
    private static final int UserFatalError = (int)782L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UserFatalError = 782
     * }
     */
    public static int UserFatalError() {
        return UserFatalError;
    }
    private static final int MonitorFatalError = (int)785L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MonitorFatalError = 785
     * }
     */
    public static int MonitorFatalError() {
        return MonitorFatalError;
    }
    private static final int LocaleFatalError = (int)786L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LocaleFatalError = 786
     * }
     */
    public static int LocaleFatalError() {
        return LocaleFatalError;
    }
    private static final int DeprecateFatalError = (int)787L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DeprecateFatalError = 787
     * }
     */
    public static int DeprecateFatalError() {
        return DeprecateFatalError;
    }
    private static final int RegistryFatalError = (int)790L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RegistryFatalError = 790
     * }
     */
    public static int RegistryFatalError() {
        return RegistryFatalError;
    }
    private static final int ConfigureFatalError = (int)795L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ConfigureFatalError = 795
     * }
     */
    public static int ConfigureFatalError() {
        return ConfigureFatalError;
    }

    private static class GetLocaleExceptionMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetLocaleExceptionMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *GetLocaleExceptionMessage(const ExceptionType severity, const char *tag)
     * }
     */
    public static FunctionDescriptor GetLocaleExceptionMessage$descriptor() {
        return GetLocaleExceptionMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *GetLocaleExceptionMessage(const ExceptionType severity, const char *tag)
     * }
     */
    public static MethodHandle GetLocaleExceptionMessage$handle() {
        return GetLocaleExceptionMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *GetLocaleExceptionMessage(const ExceptionType severity, const char *tag)
     * }
     */
    public static MemorySegment GetLocaleExceptionMessage$address() {
        return GetLocaleExceptionMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *GetLocaleExceptionMessage(const ExceptionType severity, const char *tag)
     * }
     */
    public static MemorySegment GetLocaleExceptionMessage(int severity, MemorySegment tag) {
        var mh$ = GetLocaleExceptionMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLocaleExceptionMessage", severity, tag);
            }
            return (MemorySegment)mh$.invokeExact(severity, tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLocaleMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetLocaleMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *GetLocaleMessage(const char *tag)
     * }
     */
    public static FunctionDescriptor GetLocaleMessage$descriptor() {
        return GetLocaleMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *GetLocaleMessage(const char *tag)
     * }
     */
    public static MethodHandle GetLocaleMessage$handle() {
        return GetLocaleMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *GetLocaleMessage(const char *tag)
     * }
     */
    public static MemorySegment GetLocaleMessage$address() {
        return GetLocaleMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *GetLocaleMessage(const char *tag)
     * }
     */
    public static MemorySegment GetLocaleMessage(MemorySegment tag) {
        var mh$ = GetLocaleMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLocaleMessage", tag);
            }
            return (MemorySegment)mh$.invokeExact(tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetErrorHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetErrorHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ErrorHandler SetErrorHandler(ErrorHandler handler)
     * }
     */
    public static FunctionDescriptor SetErrorHandler$descriptor() {
        return SetErrorHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ErrorHandler SetErrorHandler(ErrorHandler handler)
     * }
     */
    public static MethodHandle SetErrorHandler$handle() {
        return SetErrorHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ErrorHandler SetErrorHandler(ErrorHandler handler)
     * }
     */
    public static MemorySegment SetErrorHandler$address() {
        return SetErrorHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ErrorHandler SetErrorHandler(ErrorHandler handler)
     * }
     */
    public static MemorySegment SetErrorHandler(MemorySegment handler) {
        var mh$ = SetErrorHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetErrorHandler", handler);
            }
            return (MemorySegment)mh$.invokeExact(handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFatalErrorHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetFatalErrorHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FatalErrorHandler SetFatalErrorHandler(FatalErrorHandler handler)
     * }
     */
    public static FunctionDescriptor SetFatalErrorHandler$descriptor() {
        return SetFatalErrorHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FatalErrorHandler SetFatalErrorHandler(FatalErrorHandler handler)
     * }
     */
    public static MethodHandle SetFatalErrorHandler$handle() {
        return SetFatalErrorHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FatalErrorHandler SetFatalErrorHandler(FatalErrorHandler handler)
     * }
     */
    public static MemorySegment SetFatalErrorHandler$address() {
        return SetFatalErrorHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FatalErrorHandler SetFatalErrorHandler(FatalErrorHandler handler)
     * }
     */
    public static MemorySegment SetFatalErrorHandler(MemorySegment handler) {
        var mh$ = SetFatalErrorHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFatalErrorHandler", handler);
            }
            return (MemorySegment)mh$.invokeExact(handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CatchException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CatchException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void CatchException(const ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor CatchException$descriptor() {
        return CatchException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void CatchException(const ExceptionInfo *exception)
     * }
     */
    public static MethodHandle CatchException$handle() {
        return CatchException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void CatchException(const ExceptionInfo *exception)
     * }
     */
    public static MemorySegment CatchException$address() {
        return CatchException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void CatchException(const ExceptionInfo *exception)
     * }
     */
    public static void CatchException(MemorySegment exception) {
        var mh$ = CatchException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CatchException", exception);
            }
            mh$.invokeExact(exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CopyException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void CopyException(ExceptionInfo *copy, const ExceptionInfo *original)
     * }
     */
    public static FunctionDescriptor CopyException$descriptor() {
        return CopyException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void CopyException(ExceptionInfo *copy, const ExceptionInfo *original)
     * }
     */
    public static MethodHandle CopyException$handle() {
        return CopyException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void CopyException(ExceptionInfo *copy, const ExceptionInfo *original)
     * }
     */
    public static MemorySegment CopyException$address() {
        return CopyException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void CopyException(ExceptionInfo *copy, const ExceptionInfo *original)
     * }
     */
    public static void CopyException(MemorySegment copy, MemorySegment original) {
        var mh$ = CopyException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyException", copy, original);
            }
            mh$.invokeExact(copy, original);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyExceptionInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DestroyExceptionInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DestroyExceptionInfo(ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor DestroyExceptionInfo$descriptor() {
        return DestroyExceptionInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DestroyExceptionInfo(ExceptionInfo *exception)
     * }
     */
    public static MethodHandle DestroyExceptionInfo$handle() {
        return DestroyExceptionInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DestroyExceptionInfo(ExceptionInfo *exception)
     * }
     */
    public static MemorySegment DestroyExceptionInfo$address() {
        return DestroyExceptionInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DestroyExceptionInfo(ExceptionInfo *exception)
     * }
     */
    public static void DestroyExceptionInfo(MemorySegment exception) {
        var mh$ = DestroyExceptionInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyExceptionInfo", exception);
            }
            mh$.invokeExact(exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetExceptionInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetExceptionInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void GetExceptionInfo(ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetExceptionInfo$descriptor() {
        return GetExceptionInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void GetExceptionInfo(ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetExceptionInfo$handle() {
        return GetExceptionInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void GetExceptionInfo(ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetExceptionInfo$address() {
        return GetExceptionInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void GetExceptionInfo(ExceptionInfo *exception)
     * }
     */
    public static void GetExceptionInfo(MemorySegment exception) {
        var mh$ = GetExceptionInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetExceptionInfo", exception);
            }
            mh$.invokeExact(exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickError(const ExceptionType error, const char *reason, const char *description)
     * }
     */
    public static FunctionDescriptor MagickError$descriptor() {
        return MagickError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickError(const ExceptionType error, const char *reason, const char *description)
     * }
     */
    public static MethodHandle MagickError$handle() {
        return MagickError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickError(const ExceptionType error, const char *reason, const char *description)
     * }
     */
    public static MemorySegment MagickError$address() {
        return MagickError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickError(const ExceptionType error, const char *reason, const char *description)
     * }
     */
    public static void MagickError(int error, MemorySegment reason, MemorySegment description) {
        var mh$ = MagickError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickError", error, reason, description);
            }
            mh$.invokeExact(error, reason, description);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickFatalError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickFatalError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickFatalError(const ExceptionType error, const char *reason, const char *description)
     * }
     */
    public static FunctionDescriptor MagickFatalError$descriptor() {
        return MagickFatalError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickFatalError(const ExceptionType error, const char *reason, const char *description)
     * }
     */
    public static MethodHandle MagickFatalError$handle() {
        return MagickFatalError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickFatalError(const ExceptionType error, const char *reason, const char *description)
     * }
     */
    public static MemorySegment MagickFatalError$address() {
        return MagickFatalError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickFatalError(const ExceptionType error, const char *reason, const char *description)
     * }
     */
    public static void MagickFatalError(int error, MemorySegment reason, MemorySegment description) {
        var mh$ = MagickFatalError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickFatalError", error, reason, description);
            }
            mh$.invokeExact(error, reason, description);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickWarning {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickWarning");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickWarning(const ExceptionType severity, const char *reason, const char *description)
     * }
     */
    public static FunctionDescriptor MagickWarning$descriptor() {
        return MagickWarning.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickWarning(const ExceptionType severity, const char *reason, const char *description)
     * }
     */
    public static MethodHandle MagickWarning$handle() {
        return MagickWarning.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickWarning(const ExceptionType severity, const char *reason, const char *description)
     * }
     */
    public static MemorySegment MagickWarning$address() {
        return MagickWarning.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickWarning(const ExceptionType severity, const char *reason, const char *description)
     * }
     */
    public static void MagickWarning(int severity, MemorySegment reason, MemorySegment description) {
        var mh$ = MagickWarning.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickWarning", severity, reason, description);
            }
            mh$.invokeExact(severity, reason, description);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _MagickError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("_MagickError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _MagickError(const ExceptionType severity, const char *reason, const char *description)
     * }
     */
    public static FunctionDescriptor _MagickError$descriptor() {
        return _MagickError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _MagickError(const ExceptionType severity, const char *reason, const char *description)
     * }
     */
    public static MethodHandle _MagickError$handle() {
        return _MagickError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _MagickError(const ExceptionType severity, const char *reason, const char *description)
     * }
     */
    public static MemorySegment _MagickError$address() {
        return _MagickError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _MagickError(const ExceptionType severity, const char *reason, const char *description)
     * }
     */
    public static void _MagickError(int severity, MemorySegment reason, MemorySegment description) {
        var mh$ = _MagickError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_MagickError", severity, reason, description);
            }
            mh$.invokeExact(severity, reason, description);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _MagickFatalError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("_MagickFatalError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _MagickFatalError(const ExceptionType severity, const char *reason, const char *description)
     * }
     */
    public static FunctionDescriptor _MagickFatalError$descriptor() {
        return _MagickFatalError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _MagickFatalError(const ExceptionType severity, const char *reason, const char *description)
     * }
     */
    public static MethodHandle _MagickFatalError$handle() {
        return _MagickFatalError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _MagickFatalError(const ExceptionType severity, const char *reason, const char *description)
     * }
     */
    public static MemorySegment _MagickFatalError$address() {
        return _MagickFatalError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _MagickFatalError(const ExceptionType severity, const char *reason, const char *description)
     * }
     */
    public static void _MagickFatalError(int severity, MemorySegment reason, MemorySegment description) {
        var mh$ = _MagickFatalError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_MagickFatalError", severity, reason, description);
            }
            mh$.invokeExact(severity, reason, description);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _MagickWarning {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("_MagickWarning");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _MagickWarning(const ExceptionType warning, const char *reason, const char *description)
     * }
     */
    public static FunctionDescriptor _MagickWarning$descriptor() {
        return _MagickWarning.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _MagickWarning(const ExceptionType warning, const char *reason, const char *description)
     * }
     */
    public static MethodHandle _MagickWarning$handle() {
        return _MagickWarning.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _MagickWarning(const ExceptionType warning, const char *reason, const char *description)
     * }
     */
    public static MemorySegment _MagickWarning$address() {
        return _MagickWarning.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _MagickWarning(const ExceptionType warning, const char *reason, const char *description)
     * }
     */
    public static void _MagickWarning(int warning, MemorySegment reason, MemorySegment description) {
        var mh$ = _MagickWarning.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_MagickWarning", warning, reason, description);
            }
            mh$.invokeExact(warning, reason, description);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetExceptionInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetExceptionInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void SetExceptionInfo(ExceptionInfo *exception, ExceptionType severity)
     * }
     */
    public static FunctionDescriptor SetExceptionInfo$descriptor() {
        return SetExceptionInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void SetExceptionInfo(ExceptionInfo *exception, ExceptionType severity)
     * }
     */
    public static MethodHandle SetExceptionInfo$handle() {
        return SetExceptionInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void SetExceptionInfo(ExceptionInfo *exception, ExceptionType severity)
     * }
     */
    public static MemorySegment SetExceptionInfo$address() {
        return SetExceptionInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void SetExceptionInfo(ExceptionInfo *exception, ExceptionType severity)
     * }
     */
    public static void SetExceptionInfo(MemorySegment exception, int severity) {
        var mh$ = SetExceptionInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetExceptionInfo", exception, severity);
            }
            mh$.invokeExact(exception, severity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThrowException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ThrowException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ThrowException(ExceptionInfo *exception, const ExceptionType severity, const char *reason, const char *description)
     * }
     */
    public static FunctionDescriptor ThrowException$descriptor() {
        return ThrowException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ThrowException(ExceptionInfo *exception, const ExceptionType severity, const char *reason, const char *description)
     * }
     */
    public static MethodHandle ThrowException$handle() {
        return ThrowException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ThrowException(ExceptionInfo *exception, const ExceptionType severity, const char *reason, const char *description)
     * }
     */
    public static MemorySegment ThrowException$address() {
        return ThrowException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ThrowException(ExceptionInfo *exception, const ExceptionType severity, const char *reason, const char *description)
     * }
     */
    public static void ThrowException(MemorySegment exception, int severity, MemorySegment reason, MemorySegment description) {
        var mh$ = ThrowException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThrowException", exception, severity, reason, description);
            }
            mh$.invokeExact(exception, severity, reason, description);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThrowLoggedException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ThrowLoggedException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ThrowLoggedException(ExceptionInfo *exception, const ExceptionType severity, const char *reason, const char *description, const char *module, const char *function, const unsigned long line)
     * }
     */
    public static FunctionDescriptor ThrowLoggedException$descriptor() {
        return ThrowLoggedException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ThrowLoggedException(ExceptionInfo *exception, const ExceptionType severity, const char *reason, const char *description, const char *module, const char *function, const unsigned long line)
     * }
     */
    public static MethodHandle ThrowLoggedException$handle() {
        return ThrowLoggedException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ThrowLoggedException(ExceptionInfo *exception, const ExceptionType severity, const char *reason, const char *description, const char *module, const char *function, const unsigned long line)
     * }
     */
    public static MemorySegment ThrowLoggedException$address() {
        return ThrowLoggedException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ThrowLoggedException(ExceptionInfo *exception, const ExceptionType severity, const char *reason, const char *description, const char *module, const char *function, const unsigned long line)
     * }
     */
    public static void ThrowLoggedException(MemorySegment exception, int severity, MemorySegment reason, MemorySegment description, MemorySegment module, MemorySegment function, long line) {
        var mh$ = ThrowLoggedException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThrowLoggedException", exception, severity, reason, description, module, function, line);
            }
            mh$.invokeExact(exception, severity, reason, description, module, function, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWarningHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetWarningHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WarningHandler SetWarningHandler(WarningHandler handler)
     * }
     */
    public static FunctionDescriptor SetWarningHandler$descriptor() {
        return SetWarningHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WarningHandler SetWarningHandler(WarningHandler handler)
     * }
     */
    public static MethodHandle SetWarningHandler$handle() {
        return SetWarningHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WarningHandler SetWarningHandler(WarningHandler handler)
     * }
     */
    public static MemorySegment SetWarningHandler$address() {
        return SetWarningHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WarningHandler SetWarningHandler(WarningHandler handler)
     * }
     */
    public static MemorySegment SetWarningHandler(MemorySegment handler) {
        var mh$ = SetWarningHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWarningHandler", handler);
            }
            return (MemorySegment)mh$.invokeExact(handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UndefinedEventMask = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedEventMask = 0
     * }
     */
    public static int UndefinedEventMask() {
        return UndefinedEventMask;
    }
    private static final int NoEventsMask = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NoEventsMask = 0
     * }
     */
    public static int NoEventsMask() {
        return NoEventsMask;
    }
    private static final int ConfigureEventMask = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ConfigureEventMask = 1
     * }
     */
    public static int ConfigureEventMask() {
        return ConfigureEventMask;
    }
    private static final int AnnotateEventMask = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AnnotateEventMask = 2
     * }
     */
    public static int AnnotateEventMask() {
        return AnnotateEventMask;
    }
    private static final int RenderEventMask = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RenderEventMask = 4
     * }
     */
    public static int RenderEventMask() {
        return RenderEventMask;
    }
    private static final int TransformEventMask = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TransformEventMask = 8
     * }
     */
    public static int TransformEventMask() {
        return TransformEventMask;
    }
    private static final int LocaleEventMask = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LocaleEventMask = 16
     * }
     */
    public static int LocaleEventMask() {
        return LocaleEventMask;
    }
    private static final int CoderEventMask = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CoderEventMask = 32
     * }
     */
    public static int CoderEventMask() {
        return CoderEventMask;
    }
    private static final int X11EventMask = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.X11EventMask = 64
     * }
     */
    public static int X11EventMask() {
        return X11EventMask;
    }
    private static final int CacheEventMask = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CacheEventMask = 128
     * }
     */
    public static int CacheEventMask() {
        return CacheEventMask;
    }
    private static final int BlobEventMask = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BlobEventMask = 256
     * }
     */
    public static int BlobEventMask() {
        return BlobEventMask;
    }
    private static final int DeprecateEventMask = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DeprecateEventMask = 512
     * }
     */
    public static int DeprecateEventMask() {
        return DeprecateEventMask;
    }
    private static final int UserEventMask = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UserEventMask = 1024
     * }
     */
    public static int UserEventMask() {
        return UserEventMask;
    }
    private static final int ResourceEventMask = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ResourceEventMask = 2048
     * }
     */
    public static int ResourceEventMask() {
        return ResourceEventMask;
    }
    private static final int TemporaryFileEventMask = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TemporaryFileEventMask = 4096
     * }
     */
    public static int TemporaryFileEventMask() {
        return TemporaryFileEventMask;
    }
    private static final int ExceptionEventMask = (int)458752L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ExceptionEventMask = 458752
     * }
     */
    public static int ExceptionEventMask() {
        return ExceptionEventMask;
    }
    private static final int OptionEventMask = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OptionEventMask = 16384
     * }
     */
    public static int OptionEventMask() {
        return OptionEventMask;
    }
    private static final int InformationEventMask = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.InformationEventMask = 32768
     * }
     */
    public static int InformationEventMask() {
        return InformationEventMask;
    }
    private static final int WarningEventMask = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WarningEventMask = 65536
     * }
     */
    public static int WarningEventMask() {
        return WarningEventMask;
    }
    private static final int ErrorEventMask = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ErrorEventMask = 131072
     * }
     */
    public static int ErrorEventMask() {
        return ErrorEventMask;
    }
    private static final int FatalErrorEventMask = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FatalErrorEventMask = 262144
     * }
     */
    public static int FatalErrorEventMask() {
        return FatalErrorEventMask;
    }
    private static final int AllEventsMask = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AllEventsMask = 2147483647
     * }
     */
    public static int AllEventsMask() {
        return AllEventsMask;
    }
    private static final int DisabledOutput = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DisabledOutput = 0
     * }
     */
    public static int DisabledOutput() {
        return DisabledOutput;
    }
    private static final int UndefinedOutput = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedOutput = 0
     * }
     */
    public static int UndefinedOutput() {
        return UndefinedOutput;
    }
    private static final int StdoutOutput = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.StdoutOutput = 1
     * }
     */
    public static int StdoutOutput() {
        return StdoutOutput;
    }
    private static final int StderrOutput = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.StderrOutput = 2
     * }
     */
    public static int StderrOutput() {
        return StderrOutput;
    }
    private static final int XMLFileOutput = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.XMLFileOutput = 4
     * }
     */
    public static int XMLFileOutput() {
        return XMLFileOutput;
    }
    private static final int TXTFileOutput = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TXTFileOutput = 8
     * }
     */
    public static int TXTFileOutput() {
        return TXTFileOutput;
    }
    private static final int Win32DebugOutput = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.Win32DebugOutput = 16
     * }
     */
    public static int Win32DebugOutput() {
        return Win32DebugOutput;
    }
    private static final int Win32EventlogOutput = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.Win32EventlogOutput = 32
     * }
     */
    public static int Win32EventlogOutput() {
        return Win32EventlogOutput;
    }
    private static final int MethodOutput = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MethodOutput = 64
     * }
     */
    public static int MethodOutput() {
        return MethodOutput;
    }

    private static class IsEventLogging {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IsEventLogging");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IsEventLogging()
     * }
     */
    public static FunctionDescriptor IsEventLogging$descriptor() {
        return IsEventLogging.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IsEventLogging()
     * }
     */
    public static MethodHandle IsEventLogging$handle() {
        return IsEventLogging.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IsEventLogging()
     * }
     */
    public static MemorySegment IsEventLogging$address() {
        return IsEventLogging.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IsEventLogging()
     * }
     */
    public static int IsEventLogging() {
        var mh$ = IsEventLogging.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsEventLogging");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsEventLogged {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IsEventLogged");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IsEventLogged(const ExceptionType type)
     * }
     */
    public static FunctionDescriptor IsEventLogged$descriptor() {
        return IsEventLogged.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IsEventLogged(const ExceptionType type)
     * }
     */
    public static MethodHandle IsEventLogged$handle() {
        return IsEventLogged.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IsEventLogged(const ExceptionType type)
     * }
     */
    public static MemorySegment IsEventLogged$address() {
        return IsEventLogged.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IsEventLogged(const ExceptionType type)
     * }
     */
    public static int IsEventLogged(int type) {
        var mh$ = IsEventLogged.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsEventLogged", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern unsigned int LogMagickEvent(const ExceptionType type, const char *module, const char *function, const unsigned long line, const char *format, ...)
     * }
     */
    public static class LogMagickEvent {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                magick_wand_h.C_INT,
                magick_wand_h.C_INT,
                magick_wand_h.C_POINTER,
                magick_wand_h.C_POINTER,
                magick_wand_h.C_LONG,
                magick_wand_h.C_POINTER
            );
        private static final MemorySegment ADDR = magick_wand_h.findOrThrow("LogMagickEvent");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private LogMagickEvent(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern unsigned int LogMagickEvent(const ExceptionType type, const char *module, const char *function, const unsigned long line, const char *format, ...)
         * }
         */
        public static LogMagickEvent makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new LogMagickEvent(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int type, MemorySegment module, MemorySegment function, long line, MemorySegment format, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("LogMagickEvent", type, module, function, line, format, x5);
                }
                return (int) spreader.invokeExact(type, module, function, line, format, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class LogMagickEventList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("LogMagickEventList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int LogMagickEventList(const ExceptionType type, const char *module, const char *function, const unsigned long line, const char *format, va_list operands)
     * }
     */
    public static FunctionDescriptor LogMagickEventList$descriptor() {
        return LogMagickEventList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int LogMagickEventList(const ExceptionType type, const char *module, const char *function, const unsigned long line, const char *format, va_list operands)
     * }
     */
    public static MethodHandle LogMagickEventList$handle() {
        return LogMagickEventList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int LogMagickEventList(const ExceptionType type, const char *module, const char *function, const unsigned long line, const char *format, va_list operands)
     * }
     */
    public static MemorySegment LogMagickEventList$address() {
        return LogMagickEventList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int LogMagickEventList(const ExceptionType type, const char *module, const char *function, const unsigned long line, const char *format, va_list operands)
     * }
     */
    public static int LogMagickEventList(int type, MemorySegment module, MemorySegment function, long line, MemorySegment format, MemorySegment operands) {
        var mh$ = LogMagickEventList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogMagickEventList", type, module, function, line, format, operands);
            }
            return (int)mh$.invokeExact(type, module, function, line, format, operands);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLogEventMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetLogEventMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long SetLogEventMask(const char *events)
     * }
     */
    public static FunctionDescriptor SetLogEventMask$descriptor() {
        return SetLogEventMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long SetLogEventMask(const char *events)
     * }
     */
    public static MethodHandle SetLogEventMask$handle() {
        return SetLogEventMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long SetLogEventMask(const char *events)
     * }
     */
    public static MemorySegment SetLogEventMask$address() {
        return SetLogEventMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long SetLogEventMask(const char *events)
     * }
     */
    public static long SetLogEventMask(MemorySegment events) {
        var mh$ = SetLogEventMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLogEventMask", events);
            }
            return (long)mh$.invokeExact(events);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLogDefaultEventType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetLogDefaultEventType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void SetLogDefaultEventType(const char *events)
     * }
     */
    public static FunctionDescriptor SetLogDefaultEventType$descriptor() {
        return SetLogDefaultEventType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void SetLogDefaultEventType(const char *events)
     * }
     */
    public static MethodHandle SetLogDefaultEventType$handle() {
        return SetLogDefaultEventType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void SetLogDefaultEventType(const char *events)
     * }
     */
    public static MemorySegment SetLogDefaultEventType$address() {
        return SetLogDefaultEventType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void SetLogDefaultEventType(const char *events)
     * }
     */
    public static void SetLogDefaultEventType(MemorySegment events) {
        var mh$ = SetLogDefaultEventType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLogDefaultEventType", events);
            }
            mh$.invokeExact(events);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLogDefaultGenerations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetLogDefaultGenerations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void SetLogDefaultGenerations(const unsigned long generations)
     * }
     */
    public static FunctionDescriptor SetLogDefaultGenerations$descriptor() {
        return SetLogDefaultGenerations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void SetLogDefaultGenerations(const unsigned long generations)
     * }
     */
    public static MethodHandle SetLogDefaultGenerations$handle() {
        return SetLogDefaultGenerations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void SetLogDefaultGenerations(const unsigned long generations)
     * }
     */
    public static MemorySegment SetLogDefaultGenerations$address() {
        return SetLogDefaultGenerations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void SetLogDefaultGenerations(const unsigned long generations)
     * }
     */
    public static void SetLogDefaultGenerations(long generations) {
        var mh$ = SetLogDefaultGenerations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLogDefaultGenerations", generations);
            }
            mh$.invokeExact(generations);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLogDefaultLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetLogDefaultLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void SetLogDefaultLimit(const unsigned long limit)
     * }
     */
    public static FunctionDescriptor SetLogDefaultLimit$descriptor() {
        return SetLogDefaultLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void SetLogDefaultLimit(const unsigned long limit)
     * }
     */
    public static MethodHandle SetLogDefaultLimit$handle() {
        return SetLogDefaultLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void SetLogDefaultLimit(const unsigned long limit)
     * }
     */
    public static MemorySegment SetLogDefaultLimit$address() {
        return SetLogDefaultLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void SetLogDefaultLimit(const unsigned long limit)
     * }
     */
    public static void SetLogDefaultLimit(long limit) {
        var mh$ = SetLogDefaultLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLogDefaultLimit", limit);
            }
            mh$.invokeExact(limit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLogDefaultFileName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetLogDefaultFileName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void SetLogDefaultFileName(const char *filename)
     * }
     */
    public static FunctionDescriptor SetLogDefaultFileName$descriptor() {
        return SetLogDefaultFileName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void SetLogDefaultFileName(const char *filename)
     * }
     */
    public static MethodHandle SetLogDefaultFileName$handle() {
        return SetLogDefaultFileName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void SetLogDefaultFileName(const char *filename)
     * }
     */
    public static MemorySegment SetLogDefaultFileName$address() {
        return SetLogDefaultFileName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void SetLogDefaultFileName(const char *filename)
     * }
     */
    public static void SetLogDefaultFileName(MemorySegment filename) {
        var mh$ = SetLogDefaultFileName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLogDefaultFileName", filename);
            }
            mh$.invokeExact(filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLogDefaultFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetLogDefaultFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void SetLogDefaultFormat(const char *format)
     * }
     */
    public static FunctionDescriptor SetLogDefaultFormat$descriptor() {
        return SetLogDefaultFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void SetLogDefaultFormat(const char *format)
     * }
     */
    public static MethodHandle SetLogDefaultFormat$handle() {
        return SetLogDefaultFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void SetLogDefaultFormat(const char *format)
     * }
     */
    public static MemorySegment SetLogDefaultFormat$address() {
        return SetLogDefaultFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void SetLogDefaultFormat(const char *format)
     * }
     */
    public static void SetLogDefaultFormat(MemorySegment format) {
        var mh$ = SetLogDefaultFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLogDefaultFormat", format);
            }
            mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLogDefaultLogMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetLogDefaultLogMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void SetLogDefaultLogMethod(const LogMethod method)
     * }
     */
    public static FunctionDescriptor SetLogDefaultLogMethod$descriptor() {
        return SetLogDefaultLogMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void SetLogDefaultLogMethod(const LogMethod method)
     * }
     */
    public static MethodHandle SetLogDefaultLogMethod$handle() {
        return SetLogDefaultLogMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void SetLogDefaultLogMethod(const LogMethod method)
     * }
     */
    public static MemorySegment SetLogDefaultLogMethod$address() {
        return SetLogDefaultLogMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void SetLogDefaultLogMethod(const LogMethod method)
     * }
     */
    public static void SetLogDefaultLogMethod(MemorySegment method) {
        var mh$ = SetLogDefaultLogMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLogDefaultLogMethod", method);
            }
            mh$.invokeExact(method);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLogDefaultOutputType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetLogDefaultOutputType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void SetLogDefaultOutputType(const LogOutputType output_type)
     * }
     */
    public static FunctionDescriptor SetLogDefaultOutputType$descriptor() {
        return SetLogDefaultOutputType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void SetLogDefaultOutputType(const LogOutputType output_type)
     * }
     */
    public static MethodHandle SetLogDefaultOutputType$handle() {
        return SetLogDefaultOutputType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void SetLogDefaultOutputType(const LogOutputType output_type)
     * }
     */
    public static MemorySegment SetLogDefaultOutputType$address() {
        return SetLogDefaultOutputType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void SetLogDefaultOutputType(const LogOutputType output_type)
     * }
     */
    public static void SetLogDefaultOutputType(int output_type) {
        var mh$ = SetLogDefaultOutputType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLogDefaultOutputType", output_type);
            }
            mh$.invokeExact(output_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLogFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetLogFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void SetLogFormat(const char *format)
     * }
     */
    public static FunctionDescriptor SetLogFormat$descriptor() {
        return SetLogFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void SetLogFormat(const char *format)
     * }
     */
    public static MethodHandle SetLogFormat$handle() {
        return SetLogFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void SetLogFormat(const char *format)
     * }
     */
    public static MemorySegment SetLogFormat$address() {
        return SetLogFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void SetLogFormat(const char *format)
     * }
     */
    public static void SetLogFormat(MemorySegment format) {
        var mh$ = SetLogFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLogFormat", format);
            }
            mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLogMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetLogMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void SetLogMethod(LogMethod)
     * }
     */
    public static FunctionDescriptor SetLogMethod$descriptor() {
        return SetLogMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void SetLogMethod(LogMethod)
     * }
     */
    public static MethodHandle SetLogMethod$handle() {
        return SetLogMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void SetLogMethod(LogMethod)
     * }
     */
    public static MemorySegment SetLogMethod$address() {
        return SetLogMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void SetLogMethod(LogMethod)
     * }
     */
    public static void SetLogMethod(MemorySegment x0) {
        var mh$ = SetLogMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLogMethod", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UndefinedTimerState = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedTimerState = 0
     * }
     */
    public static int UndefinedTimerState() {
        return UndefinedTimerState;
    }
    private static final int StoppedTimerState = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.StoppedTimerState = 1
     * }
     */
    public static int StoppedTimerState() {
        return StoppedTimerState;
    }
    private static final int RunningTimerState = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RunningTimerState = 2
     * }
     */
    public static int RunningTimerState() {
        return RunningTimerState;
    }

    private static class GetElapsedTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetElapsedTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double GetElapsedTime(TimerInfo *)
     * }
     */
    public static FunctionDescriptor GetElapsedTime$descriptor() {
        return GetElapsedTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double GetElapsedTime(TimerInfo *)
     * }
     */
    public static MethodHandle GetElapsedTime$handle() {
        return GetElapsedTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double GetElapsedTime(TimerInfo *)
     * }
     */
    public static MemorySegment GetElapsedTime$address() {
        return GetElapsedTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double GetElapsedTime(TimerInfo *)
     * }
     */
    public static double GetElapsedTime(MemorySegment x0) {
        var mh$ = GetElapsedTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetElapsedTime", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetUserTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double GetUserTime(TimerInfo *)
     * }
     */
    public static FunctionDescriptor GetUserTime$descriptor() {
        return GetUserTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double GetUserTime(TimerInfo *)
     * }
     */
    public static MethodHandle GetUserTime$handle() {
        return GetUserTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double GetUserTime(TimerInfo *)
     * }
     */
    public static MemorySegment GetUserTime$address() {
        return GetUserTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double GetUserTime(TimerInfo *)
     * }
     */
    public static double GetUserTime(MemorySegment x0) {
        var mh$ = GetUserTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserTime", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTimerResolution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetTimerResolution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double GetTimerResolution()
     * }
     */
    public static FunctionDescriptor GetTimerResolution$descriptor() {
        return GetTimerResolution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double GetTimerResolution()
     * }
     */
    public static MethodHandle GetTimerResolution$handle() {
        return GetTimerResolution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double GetTimerResolution()
     * }
     */
    public static MemorySegment GetTimerResolution$address() {
        return GetTimerResolution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double GetTimerResolution()
     * }
     */
    public static double GetTimerResolution() {
        var mh$ = GetTimerResolution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTimerResolution");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ContinueTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ContinueTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ContinueTimer(TimerInfo *)
     * }
     */
    public static FunctionDescriptor ContinueTimer$descriptor() {
        return ContinueTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ContinueTimer(TimerInfo *)
     * }
     */
    public static MethodHandle ContinueTimer$handle() {
        return ContinueTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ContinueTimer(TimerInfo *)
     * }
     */
    public static MemorySegment ContinueTimer$address() {
        return ContinueTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ContinueTimer(TimerInfo *)
     * }
     */
    public static int ContinueTimer(MemorySegment x0) {
        var mh$ = ContinueTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ContinueTimer", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTimerInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetTimerInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void GetTimerInfo(TimerInfo *)
     * }
     */
    public static FunctionDescriptor GetTimerInfo$descriptor() {
        return GetTimerInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void GetTimerInfo(TimerInfo *)
     * }
     */
    public static MethodHandle GetTimerInfo$handle() {
        return GetTimerInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void GetTimerInfo(TimerInfo *)
     * }
     */
    public static MemorySegment GetTimerInfo$address() {
        return GetTimerInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void GetTimerInfo(TimerInfo *)
     * }
     */
    public static void GetTimerInfo(MemorySegment x0) {
        var mh$ = GetTimerInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTimerInfo", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ResetTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ResetTimer(TimerInfo *)
     * }
     */
    public static FunctionDescriptor ResetTimer$descriptor() {
        return ResetTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ResetTimer(TimerInfo *)
     * }
     */
    public static MethodHandle ResetTimer$handle() {
        return ResetTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ResetTimer(TimerInfo *)
     * }
     */
    public static MemorySegment ResetTimer$address() {
        return ResetTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ResetTimer(TimerInfo *)
     * }
     */
    public static void ResetTimer(MemorySegment x0) {
        var mh$ = ResetTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetTimer", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StartTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void StartTimer(TimerInfo *time_info, const unsigned int reset)
     * }
     */
    public static FunctionDescriptor StartTimer$descriptor() {
        return StartTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void StartTimer(TimerInfo *time_info, const unsigned int reset)
     * }
     */
    public static MethodHandle StartTimer$handle() {
        return StartTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void StartTimer(TimerInfo *time_info, const unsigned int reset)
     * }
     */
    public static MemorySegment StartTimer$address() {
        return StartTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void StartTimer(TimerInfo *time_info, const unsigned int reset)
     * }
     */
    public static void StartTimer(MemorySegment time_info, int reset) {
        var mh$ = StartTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartTimer", time_info, reset);
            }
            mh$.invokeExact(time_info, reset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StopTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StopTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void StopTimer(TimerInfo *time_info)
     * }
     */
    public static FunctionDescriptor StopTimer$descriptor() {
        return StopTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void StopTimer(TimerInfo *time_info)
     * }
     */
    public static MethodHandle StopTimer$handle() {
        return StopTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void StopTimer(TimerInfo *time_info)
     * }
     */
    public static MemorySegment StopTimer$address() {
        return StopTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void StopTimer(TimerInfo *time_info)
     * }
     */
    public static void StopTimer(MemorySegment time_info) {
        var mh$ = StopTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StopTimer", time_info);
            }
            mh$.invokeExact(time_info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned short Quantum
     * }
     */
    public static final OfShort Quantum = magick_wand_h.C_SHORT;
    private static final int UnspecifiedAlpha = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UnspecifiedAlpha = 0
     * }
     */
    public static int UnspecifiedAlpha() {
        return UnspecifiedAlpha;
    }
    private static final int AssociatedAlpha = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AssociatedAlpha = 1
     * }
     */
    public static int AssociatedAlpha() {
        return AssociatedAlpha;
    }
    private static final int UnassociatedAlpha = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UnassociatedAlpha = 2
     * }
     */
    public static int UnassociatedAlpha() {
        return UnassociatedAlpha;
    }
    private static final int UndefinedChannel = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedChannel = 0
     * }
     */
    public static int UndefinedChannel() {
        return UndefinedChannel;
    }
    private static final int RedChannel = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RedChannel = 1
     * }
     */
    public static int RedChannel() {
        return RedChannel;
    }
    private static final int CyanChannel = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CyanChannel = 2
     * }
     */
    public static int CyanChannel() {
        return CyanChannel;
    }
    private static final int GreenChannel = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GreenChannel = 3
     * }
     */
    public static int GreenChannel() {
        return GreenChannel;
    }
    private static final int MagentaChannel = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MagentaChannel = 4
     * }
     */
    public static int MagentaChannel() {
        return MagentaChannel;
    }
    private static final int BlueChannel = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BlueChannel = 5
     * }
     */
    public static int BlueChannel() {
        return BlueChannel;
    }
    private static final int YellowChannel = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.YellowChannel = 6
     * }
     */
    public static int YellowChannel() {
        return YellowChannel;
    }
    private static final int OpacityChannel = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OpacityChannel = 7
     * }
     */
    public static int OpacityChannel() {
        return OpacityChannel;
    }
    private static final int BlackChannel = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BlackChannel = 8
     * }
     */
    public static int BlackChannel() {
        return BlackChannel;
    }
    private static final int MatteChannel = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MatteChannel = 9
     * }
     */
    public static int MatteChannel() {
        return MatteChannel;
    }
    private static final int AllChannels = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AllChannels = 10
     * }
     */
    public static int AllChannels() {
        return AllChannels;
    }
    private static final int GrayChannel = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GrayChannel = 11
     * }
     */
    public static int GrayChannel() {
        return GrayChannel;
    }
    private static final int UndefinedClass = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedClass = 0
     * }
     */
    public static int UndefinedClass() {
        return UndefinedClass;
    }
    private static final int DirectClass = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DirectClass = 1
     * }
     */
    public static int DirectClass() {
        return DirectClass;
    }
    private static final int PseudoClass = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PseudoClass = 2
     * }
     */
    public static int PseudoClass() {
        return PseudoClass;
    }
    private static final int UndefinedCompositeOp = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedCompositeOp = 0
     * }
     */
    public static int UndefinedCompositeOp() {
        return UndefinedCompositeOp;
    }
    private static final int OverCompositeOp = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OverCompositeOp = 1
     * }
     */
    public static int OverCompositeOp() {
        return OverCompositeOp;
    }
    private static final int InCompositeOp = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.InCompositeOp = 2
     * }
     */
    public static int InCompositeOp() {
        return InCompositeOp;
    }
    private static final int OutCompositeOp = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OutCompositeOp = 3
     * }
     */
    public static int OutCompositeOp() {
        return OutCompositeOp;
    }
    private static final int AtopCompositeOp = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AtopCompositeOp = 4
     * }
     */
    public static int AtopCompositeOp() {
        return AtopCompositeOp;
    }
    private static final int XorCompositeOp = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.XorCompositeOp = 5
     * }
     */
    public static int XorCompositeOp() {
        return XorCompositeOp;
    }
    private static final int PlusCompositeOp = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PlusCompositeOp = 6
     * }
     */
    public static int PlusCompositeOp() {
        return PlusCompositeOp;
    }
    private static final int MinusCompositeOp = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MinusCompositeOp = 7
     * }
     */
    public static int MinusCompositeOp() {
        return MinusCompositeOp;
    }
    private static final int AddCompositeOp = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AddCompositeOp = 8
     * }
     */
    public static int AddCompositeOp() {
        return AddCompositeOp;
    }
    private static final int SubtractCompositeOp = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SubtractCompositeOp = 9
     * }
     */
    public static int SubtractCompositeOp() {
        return SubtractCompositeOp;
    }
    private static final int DifferenceCompositeOp = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DifferenceCompositeOp = 10
     * }
     */
    public static int DifferenceCompositeOp() {
        return DifferenceCompositeOp;
    }
    private static final int MultiplyCompositeOp = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MultiplyCompositeOp = 11
     * }
     */
    public static int MultiplyCompositeOp() {
        return MultiplyCompositeOp;
    }
    private static final int BumpmapCompositeOp = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BumpmapCompositeOp = 12
     * }
     */
    public static int BumpmapCompositeOp() {
        return BumpmapCompositeOp;
    }
    private static final int CopyCompositeOp = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CopyCompositeOp = 13
     * }
     */
    public static int CopyCompositeOp() {
        return CopyCompositeOp;
    }
    private static final int CopyRedCompositeOp = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CopyRedCompositeOp = 14
     * }
     */
    public static int CopyRedCompositeOp() {
        return CopyRedCompositeOp;
    }
    private static final int CopyGreenCompositeOp = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CopyGreenCompositeOp = 15
     * }
     */
    public static int CopyGreenCompositeOp() {
        return CopyGreenCompositeOp;
    }
    private static final int CopyBlueCompositeOp = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CopyBlueCompositeOp = 16
     * }
     */
    public static int CopyBlueCompositeOp() {
        return CopyBlueCompositeOp;
    }
    private static final int CopyOpacityCompositeOp = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CopyOpacityCompositeOp = 17
     * }
     */
    public static int CopyOpacityCompositeOp() {
        return CopyOpacityCompositeOp;
    }
    private static final int ClearCompositeOp = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ClearCompositeOp = 18
     * }
     */
    public static int ClearCompositeOp() {
        return ClearCompositeOp;
    }
    private static final int DissolveCompositeOp = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DissolveCompositeOp = 19
     * }
     */
    public static int DissolveCompositeOp() {
        return DissolveCompositeOp;
    }
    private static final int DisplaceCompositeOp = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DisplaceCompositeOp = 20
     * }
     */
    public static int DisplaceCompositeOp() {
        return DisplaceCompositeOp;
    }
    private static final int ModulateCompositeOp = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ModulateCompositeOp = 21
     * }
     */
    public static int ModulateCompositeOp() {
        return ModulateCompositeOp;
    }
    private static final int ThresholdCompositeOp = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ThresholdCompositeOp = 22
     * }
     */
    public static int ThresholdCompositeOp() {
        return ThresholdCompositeOp;
    }
    private static final int NoCompositeOp = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NoCompositeOp = 23
     * }
     */
    public static int NoCompositeOp() {
        return NoCompositeOp;
    }
    private static final int DarkenCompositeOp = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DarkenCompositeOp = 24
     * }
     */
    public static int DarkenCompositeOp() {
        return DarkenCompositeOp;
    }
    private static final int LightenCompositeOp = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LightenCompositeOp = 25
     * }
     */
    public static int LightenCompositeOp() {
        return LightenCompositeOp;
    }
    private static final int HueCompositeOp = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HueCompositeOp = 26
     * }
     */
    public static int HueCompositeOp() {
        return HueCompositeOp;
    }
    private static final int SaturateCompositeOp = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SaturateCompositeOp = 27
     * }
     */
    public static int SaturateCompositeOp() {
        return SaturateCompositeOp;
    }
    private static final int ColorizeCompositeOp = (int)28L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ColorizeCompositeOp = 28
     * }
     */
    public static int ColorizeCompositeOp() {
        return ColorizeCompositeOp;
    }
    private static final int LuminizeCompositeOp = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LuminizeCompositeOp = 29
     * }
     */
    public static int LuminizeCompositeOp() {
        return LuminizeCompositeOp;
    }
    private static final int ScreenCompositeOp = (int)30L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ScreenCompositeOp = 30
     * }
     */
    public static int ScreenCompositeOp() {
        return ScreenCompositeOp;
    }
    private static final int OverlayCompositeOp = (int)31L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OverlayCompositeOp = 31
     * }
     */
    public static int OverlayCompositeOp() {
        return OverlayCompositeOp;
    }
    private static final int CopyCyanCompositeOp = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CopyCyanCompositeOp = 32
     * }
     */
    public static int CopyCyanCompositeOp() {
        return CopyCyanCompositeOp;
    }
    private static final int CopyMagentaCompositeOp = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CopyMagentaCompositeOp = 33
     * }
     */
    public static int CopyMagentaCompositeOp() {
        return CopyMagentaCompositeOp;
    }
    private static final int CopyYellowCompositeOp = (int)34L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CopyYellowCompositeOp = 34
     * }
     */
    public static int CopyYellowCompositeOp() {
        return CopyYellowCompositeOp;
    }
    private static final int CopyBlackCompositeOp = (int)35L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CopyBlackCompositeOp = 35
     * }
     */
    public static int CopyBlackCompositeOp() {
        return CopyBlackCompositeOp;
    }
    private static final int DivideCompositeOp = (int)36L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DivideCompositeOp = 36
     * }
     */
    public static int DivideCompositeOp() {
        return DivideCompositeOp;
    }
    private static final int HardLightCompositeOp = (int)37L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HardLightCompositeOp = 37
     * }
     */
    public static int HardLightCompositeOp() {
        return HardLightCompositeOp;
    }
    private static final int ExclusionCompositeOp = (int)38L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ExclusionCompositeOp = 38
     * }
     */
    public static int ExclusionCompositeOp() {
        return ExclusionCompositeOp;
    }
    private static final int ColorDodgeCompositeOp = (int)39L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ColorDodgeCompositeOp = 39
     * }
     */
    public static int ColorDodgeCompositeOp() {
        return ColorDodgeCompositeOp;
    }
    private static final int ColorBurnCompositeOp = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ColorBurnCompositeOp = 40
     * }
     */
    public static int ColorBurnCompositeOp() {
        return ColorBurnCompositeOp;
    }
    private static final int SoftLightCompositeOp = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SoftLightCompositeOp = 41
     * }
     */
    public static int SoftLightCompositeOp() {
        return SoftLightCompositeOp;
    }
    private static final int LinearBurnCompositeOp = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LinearBurnCompositeOp = 42
     * }
     */
    public static int LinearBurnCompositeOp() {
        return LinearBurnCompositeOp;
    }
    private static final int LinearDodgeCompositeOp = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LinearDodgeCompositeOp = 43
     * }
     */
    public static int LinearDodgeCompositeOp() {
        return LinearDodgeCompositeOp;
    }
    private static final int LinearLightCompositeOp = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LinearLightCompositeOp = 44
     * }
     */
    public static int LinearLightCompositeOp() {
        return LinearLightCompositeOp;
    }
    private static final int VividLightCompositeOp = (int)45L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.VividLightCompositeOp = 45
     * }
     */
    public static int VividLightCompositeOp() {
        return VividLightCompositeOp;
    }
    private static final int PinLightCompositeOp = (int)46L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PinLightCompositeOp = 46
     * }
     */
    public static int PinLightCompositeOp() {
        return PinLightCompositeOp;
    }
    private static final int HardMixCompositeOp = (int)47L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HardMixCompositeOp = 47
     * }
     */
    public static int HardMixCompositeOp() {
        return HardMixCompositeOp;
    }
    private static final int UndefinedCompression = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedCompression = 0
     * }
     */
    public static int UndefinedCompression() {
        return UndefinedCompression;
    }
    private static final int NoCompression = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NoCompression = 1
     * }
     */
    public static int NoCompression() {
        return NoCompression;
    }
    private static final int BZipCompression = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BZipCompression = 2
     * }
     */
    public static int BZipCompression() {
        return BZipCompression;
    }
    private static final int FaxCompression = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FaxCompression = 3
     * }
     */
    public static int FaxCompression() {
        return FaxCompression;
    }
    private static final int Group3Compression = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.Group3Compression = 3
     * }
     */
    public static int Group3Compression() {
        return Group3Compression;
    }
    private static final int Group4Compression = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.Group4Compression = 4
     * }
     */
    public static int Group4Compression() {
        return Group4Compression;
    }
    private static final int JPEGCompression = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPEGCompression = 5
     * }
     */
    public static int JPEGCompression() {
        return JPEGCompression;
    }
    private static final int LosslessJPEGCompression = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LosslessJPEGCompression = 6
     * }
     */
    public static int LosslessJPEGCompression() {
        return LosslessJPEGCompression;
    }
    private static final int LZWCompression = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LZWCompression = 7
     * }
     */
    public static int LZWCompression() {
        return LZWCompression;
    }
    private static final int RLECompression = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RLECompression = 8
     * }
     */
    public static int RLECompression() {
        return RLECompression;
    }
    private static final int ZipCompression = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ZipCompression = 9
     * }
     */
    public static int ZipCompression() {
        return ZipCompression;
    }
    private static final int LZMACompression = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LZMACompression = 10
     * }
     */
    public static int LZMACompression() {
        return LZMACompression;
    }
    private static final int JPEG2000Compression = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPEG2000Compression = 11
     * }
     */
    public static int JPEG2000Compression() {
        return JPEG2000Compression;
    }
    private static final int JBIG1Compression = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JBIG1Compression = 12
     * }
     */
    public static int JBIG1Compression() {
        return JBIG1Compression;
    }
    private static final int JBIG2Compression = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JBIG2Compression = 13
     * }
     */
    public static int JBIG2Compression() {
        return JBIG2Compression;
    }
    private static final int ZSTDCompression = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ZSTDCompression = 14
     * }
     */
    public static int ZSTDCompression() {
        return ZSTDCompression;
    }
    private static final int WebPCompression = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WebPCompression = 15
     * }
     */
    public static int WebPCompression() {
        return WebPCompression;
    }
    private static final int UndefinedDispose = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedDispose = 0
     * }
     */
    public static int UndefinedDispose() {
        return UndefinedDispose;
    }
    private static final int NoneDispose = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NoneDispose = 1
     * }
     */
    public static int NoneDispose() {
        return NoneDispose;
    }
    private static final int BackgroundDispose = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BackgroundDispose = 2
     * }
     */
    public static int BackgroundDispose() {
        return BackgroundDispose;
    }
    private static final int PreviousDispose = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PreviousDispose = 3
     * }
     */
    public static int PreviousDispose() {
        return PreviousDispose;
    }
    private static final int UndefinedEndian = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedEndian = 0
     * }
     */
    public static int UndefinedEndian() {
        return UndefinedEndian;
    }
    private static final int LSBEndian = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LSBEndian = 1
     * }
     */
    public static int LSBEndian() {
        return LSBEndian;
    }
    private static final int MSBEndian = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSBEndian = 2
     * }
     */
    public static int MSBEndian() {
        return MSBEndian;
    }
    private static final int NativeEndian = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NativeEndian = 3
     * }
     */
    public static int NativeEndian() {
        return NativeEndian;
    }
    private static final int UndefinedFilter = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedFilter = 0
     * }
     */
    public static int UndefinedFilter() {
        return UndefinedFilter;
    }
    private static final int PointFilter = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PointFilter = 1
     * }
     */
    public static int PointFilter() {
        return PointFilter;
    }
    private static final int BoxFilter = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BoxFilter = 2
     * }
     */
    public static int BoxFilter() {
        return BoxFilter;
    }
    private static final int TriangleFilter = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TriangleFilter = 3
     * }
     */
    public static int TriangleFilter() {
        return TriangleFilter;
    }
    private static final int HermiteFilter = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HermiteFilter = 4
     * }
     */
    public static int HermiteFilter() {
        return HermiteFilter;
    }
    private static final int HanningFilter = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HanningFilter = 5
     * }
     */
    public static int HanningFilter() {
        return HanningFilter;
    }
    private static final int HammingFilter = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HammingFilter = 6
     * }
     */
    public static int HammingFilter() {
        return HammingFilter;
    }
    private static final int BlackmanFilter = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BlackmanFilter = 7
     * }
     */
    public static int BlackmanFilter() {
        return BlackmanFilter;
    }
    private static final int GaussianFilter = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GaussianFilter = 8
     * }
     */
    public static int GaussianFilter() {
        return GaussianFilter;
    }
    private static final int QuadraticFilter = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QuadraticFilter = 9
     * }
     */
    public static int QuadraticFilter() {
        return QuadraticFilter;
    }
    private static final int CubicFilter = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CubicFilter = 10
     * }
     */
    public static int CubicFilter() {
        return CubicFilter;
    }
    private static final int CatromFilter = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CatromFilter = 11
     * }
     */
    public static int CatromFilter() {
        return CatromFilter;
    }
    private static final int MitchellFilter = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MitchellFilter = 12
     * }
     */
    public static int MitchellFilter() {
        return MitchellFilter;
    }
    private static final int LanczosFilter = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LanczosFilter = 13
     * }
     */
    public static int LanczosFilter() {
        return LanczosFilter;
    }
    private static final int BesselFilter = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BesselFilter = 14
     * }
     */
    public static int BesselFilter() {
        return BesselFilter;
    }
    private static final int SincFilter = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SincFilter = 15
     * }
     */
    public static int SincFilter() {
        return SincFilter;
    }
    private static final int NoValue = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NoValue = 0
     * }
     */
    public static int NoValue() {
        return NoValue;
    }
    private static final int XValue = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.XValue = 1
     * }
     */
    public static int XValue() {
        return XValue;
    }
    private static final int YValue = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.YValue = 2
     * }
     */
    public static int YValue() {
        return YValue;
    }
    private static final int WidthValue = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WidthValue = 4
     * }
     */
    public static int WidthValue() {
        return WidthValue;
    }
    private static final int HeightValue = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HeightValue = 8
     * }
     */
    public static int HeightValue() {
        return HeightValue;
    }
    private static final int AllValues = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AllValues = 15
     * }
     */
    public static int AllValues() {
        return AllValues;
    }
    private static final int XNegative = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.XNegative = 16
     * }
     */
    public static int XNegative() {
        return XNegative;
    }
    private static final int YNegative = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.YNegative = 32
     * }
     */
    public static int YNegative() {
        return YNegative;
    }
    private static final int PercentValue = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PercentValue = 4096
     * }
     */
    public static int PercentValue() {
        return PercentValue;
    }
    private static final int AspectValue = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AspectValue = 8192
     * }
     */
    public static int AspectValue() {
        return AspectValue;
    }
    private static final int LessValue = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LessValue = 16384
     * }
     */
    public static int LessValue() {
        return LessValue;
    }
    private static final int GreaterValue = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GreaterValue = 32768
     * }
     */
    public static int GreaterValue() {
        return GreaterValue;
    }
    private static final int AreaValue = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AreaValue = 65536
     * }
     */
    public static int AreaValue() {
        return AreaValue;
    }
    private static final int MinimumValue = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MinimumValue = 131072
     * }
     */
    public static int MinimumValue() {
        return MinimumValue;
    }
    private static final int ForgetGravity = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ForgetGravity = 0
     * }
     */
    public static int ForgetGravity() {
        return ForgetGravity;
    }
    private static final int NorthWestGravity = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NorthWestGravity = 1
     * }
     */
    public static int NorthWestGravity() {
        return NorthWestGravity;
    }
    private static final int NorthGravity = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NorthGravity = 2
     * }
     */
    public static int NorthGravity() {
        return NorthGravity;
    }
    private static final int NorthEastGravity = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NorthEastGravity = 3
     * }
     */
    public static int NorthEastGravity() {
        return NorthEastGravity;
    }
    private static final int WestGravity = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WestGravity = 4
     * }
     */
    public static int WestGravity() {
        return WestGravity;
    }
    private static final int CenterGravity = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CenterGravity = 5
     * }
     */
    public static int CenterGravity() {
        return CenterGravity;
    }
    private static final int EastGravity = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EastGravity = 6
     * }
     */
    public static int EastGravity() {
        return EastGravity;
    }
    private static final int SouthWestGravity = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SouthWestGravity = 7
     * }
     */
    public static int SouthWestGravity() {
        return SouthWestGravity;
    }
    private static final int SouthGravity = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SouthGravity = 8
     * }
     */
    public static int SouthGravity() {
        return SouthGravity;
    }
    private static final int SouthEastGravity = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SouthEastGravity = 9
     * }
     */
    public static int SouthEastGravity() {
        return SouthEastGravity;
    }
    private static final int StaticGravity = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.StaticGravity = 10
     * }
     */
    public static int StaticGravity() {
        return StaticGravity;
    }
    private static final int UndefinedType = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedType = 0
     * }
     */
    public static int UndefinedType() {
        return UndefinedType;
    }
    private static final int BilevelType = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BilevelType = 1
     * }
     */
    public static int BilevelType() {
        return BilevelType;
    }
    private static final int GrayscaleType = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GrayscaleType = 2
     * }
     */
    public static int GrayscaleType() {
        return GrayscaleType;
    }
    private static final int GrayscaleMatteType = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GrayscaleMatteType = 3
     * }
     */
    public static int GrayscaleMatteType() {
        return GrayscaleMatteType;
    }
    private static final int PaletteType = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PaletteType = 4
     * }
     */
    public static int PaletteType() {
        return PaletteType;
    }
    private static final int PaletteMatteType = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PaletteMatteType = 5
     * }
     */
    public static int PaletteMatteType() {
        return PaletteMatteType;
    }
    private static final int TrueColorType = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TrueColorType = 6
     * }
     */
    public static int TrueColorType() {
        return TrueColorType;
    }
    private static final int TrueColorMatteType = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TrueColorMatteType = 7
     * }
     */
    public static int TrueColorMatteType() {
        return TrueColorMatteType;
    }
    private static final int ColorSeparationType = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ColorSeparationType = 8
     * }
     */
    public static int ColorSeparationType() {
        return ColorSeparationType;
    }
    private static final int ColorSeparationMatteType = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ColorSeparationMatteType = 9
     * }
     */
    public static int ColorSeparationMatteType() {
        return ColorSeparationMatteType;
    }
    private static final int OptimizeType = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OptimizeType = 10
     * }
     */
    public static int OptimizeType() {
        return OptimizeType;
    }
    private static final int UndefinedInterlace = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedInterlace = 0
     * }
     */
    public static int UndefinedInterlace() {
        return UndefinedInterlace;
    }
    private static final int NoInterlace = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NoInterlace = 1
     * }
     */
    public static int NoInterlace() {
        return NoInterlace;
    }
    private static final int LineInterlace = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LineInterlace = 2
     * }
     */
    public static int LineInterlace() {
        return LineInterlace;
    }
    private static final int PlaneInterlace = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PlaneInterlace = 3
     * }
     */
    public static int PlaneInterlace() {
        return PlaneInterlace;
    }
    private static final int PartitionInterlace = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PartitionInterlace = 4
     * }
     */
    public static int PartitionInterlace() {
        return PartitionInterlace;
    }
    private static final int UndefinedMode = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedMode = 0
     * }
     */
    public static int UndefinedMode() {
        return UndefinedMode;
    }
    private static final int FrameMode = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FrameMode = 1
     * }
     */
    public static int FrameMode() {
        return FrameMode;
    }
    private static final int UnframeMode = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UnframeMode = 2
     * }
     */
    public static int UnframeMode() {
        return UnframeMode;
    }
    private static final int ConcatenateMode = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ConcatenateMode = 3
     * }
     */
    public static int ConcatenateMode() {
        return ConcatenateMode;
    }
    private static final int UniformNoise = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UniformNoise = 0
     * }
     */
    public static int UniformNoise() {
        return UniformNoise;
    }
    private static final int GaussianNoise = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GaussianNoise = 1
     * }
     */
    public static int GaussianNoise() {
        return GaussianNoise;
    }
    private static final int MultiplicativeGaussianNoise = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MultiplicativeGaussianNoise = 2
     * }
     */
    public static int MultiplicativeGaussianNoise() {
        return MultiplicativeGaussianNoise;
    }
    private static final int ImpulseNoise = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ImpulseNoise = 3
     * }
     */
    public static int ImpulseNoise() {
        return ImpulseNoise;
    }
    private static final int LaplacianNoise = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LaplacianNoise = 4
     * }
     */
    public static int LaplacianNoise() {
        return LaplacianNoise;
    }
    private static final int PoissonNoise = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PoissonNoise = 5
     * }
     */
    public static int PoissonNoise() {
        return PoissonNoise;
    }
    private static final int RandomNoise = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RandomNoise = 6
     * }
     */
    public static int RandomNoise() {
        return RandomNoise;
    }
    private static final int UndefinedNoise = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedNoise = 7
     * }
     */
    public static int UndefinedNoise() {
        return UndefinedNoise;
    }
    private static final int UndefinedOrientation = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedOrientation = 0
     * }
     */
    public static int UndefinedOrientation() {
        return UndefinedOrientation;
    }
    private static final int TopLeftOrientation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TopLeftOrientation = 1
     * }
     */
    public static int TopLeftOrientation() {
        return TopLeftOrientation;
    }
    private static final int TopRightOrientation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TopRightOrientation = 2
     * }
     */
    public static int TopRightOrientation() {
        return TopRightOrientation;
    }
    private static final int BottomRightOrientation = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BottomRightOrientation = 3
     * }
     */
    public static int BottomRightOrientation() {
        return BottomRightOrientation;
    }
    private static final int BottomLeftOrientation = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BottomLeftOrientation = 4
     * }
     */
    public static int BottomLeftOrientation() {
        return BottomLeftOrientation;
    }
    private static final int LeftTopOrientation = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LeftTopOrientation = 5
     * }
     */
    public static int LeftTopOrientation() {
        return LeftTopOrientation;
    }
    private static final int RightTopOrientation = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RightTopOrientation = 6
     * }
     */
    public static int RightTopOrientation() {
        return RightTopOrientation;
    }
    private static final int RightBottomOrientation = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RightBottomOrientation = 7
     * }
     */
    public static int RightBottomOrientation() {
        return RightBottomOrientation;
    }
    private static final int LeftBottomOrientation = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LeftBottomOrientation = 8
     * }
     */
    public static int LeftBottomOrientation() {
        return LeftBottomOrientation;
    }
    private static final int UndefinedPreview = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedPreview = 0
     * }
     */
    public static int UndefinedPreview() {
        return UndefinedPreview;
    }
    private static final int RotatePreview = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RotatePreview = 1
     * }
     */
    public static int RotatePreview() {
        return RotatePreview;
    }
    private static final int ShearPreview = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ShearPreview = 2
     * }
     */
    public static int ShearPreview() {
        return ShearPreview;
    }
    private static final int RollPreview = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RollPreview = 3
     * }
     */
    public static int RollPreview() {
        return RollPreview;
    }
    private static final int HuePreview = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HuePreview = 4
     * }
     */
    public static int HuePreview() {
        return HuePreview;
    }
    private static final int SaturationPreview = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SaturationPreview = 5
     * }
     */
    public static int SaturationPreview() {
        return SaturationPreview;
    }
    private static final int BrightnessPreview = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BrightnessPreview = 6
     * }
     */
    public static int BrightnessPreview() {
        return BrightnessPreview;
    }
    private static final int GammaPreview = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GammaPreview = 7
     * }
     */
    public static int GammaPreview() {
        return GammaPreview;
    }
    private static final int SpiffPreview = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SpiffPreview = 8
     * }
     */
    public static int SpiffPreview() {
        return SpiffPreview;
    }
    private static final int DullPreview = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DullPreview = 9
     * }
     */
    public static int DullPreview() {
        return DullPreview;
    }
    private static final int GrayscalePreview = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GrayscalePreview = 10
     * }
     */
    public static int GrayscalePreview() {
        return GrayscalePreview;
    }
    private static final int QuantizePreview = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QuantizePreview = 11
     * }
     */
    public static int QuantizePreview() {
        return QuantizePreview;
    }
    private static final int DespecklePreview = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DespecklePreview = 12
     * }
     */
    public static int DespecklePreview() {
        return DespecklePreview;
    }
    private static final int ReduceNoisePreview = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ReduceNoisePreview = 13
     * }
     */
    public static int ReduceNoisePreview() {
        return ReduceNoisePreview;
    }
    private static final int AddNoisePreview = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AddNoisePreview = 14
     * }
     */
    public static int AddNoisePreview() {
        return AddNoisePreview;
    }
    private static final int SharpenPreview = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SharpenPreview = 15
     * }
     */
    public static int SharpenPreview() {
        return SharpenPreview;
    }
    private static final int BlurPreview = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BlurPreview = 16
     * }
     */
    public static int BlurPreview() {
        return BlurPreview;
    }
    private static final int ThresholdPreview = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ThresholdPreview = 17
     * }
     */
    public static int ThresholdPreview() {
        return ThresholdPreview;
    }
    private static final int EdgeDetectPreview = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EdgeDetectPreview = 18
     * }
     */
    public static int EdgeDetectPreview() {
        return EdgeDetectPreview;
    }
    private static final int SpreadPreview = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SpreadPreview = 19
     * }
     */
    public static int SpreadPreview() {
        return SpreadPreview;
    }
    private static final int SolarizePreview = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SolarizePreview = 20
     * }
     */
    public static int SolarizePreview() {
        return SolarizePreview;
    }
    private static final int ShadePreview = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ShadePreview = 21
     * }
     */
    public static int ShadePreview() {
        return ShadePreview;
    }
    private static final int RaisePreview = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RaisePreview = 22
     * }
     */
    public static int RaisePreview() {
        return RaisePreview;
    }
    private static final int SegmentPreview = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SegmentPreview = 23
     * }
     */
    public static int SegmentPreview() {
        return SegmentPreview;
    }
    private static final int SwirlPreview = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SwirlPreview = 24
     * }
     */
    public static int SwirlPreview() {
        return SwirlPreview;
    }
    private static final int ImplodePreview = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ImplodePreview = 25
     * }
     */
    public static int ImplodePreview() {
        return ImplodePreview;
    }
    private static final int WavePreview = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WavePreview = 26
     * }
     */
    public static int WavePreview() {
        return WavePreview;
    }
    private static final int OilPaintPreview = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OilPaintPreview = 27
     * }
     */
    public static int OilPaintPreview() {
        return OilPaintPreview;
    }
    private static final int CharcoalDrawingPreview = (int)28L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CharcoalDrawingPreview = 28
     * }
     */
    public static int CharcoalDrawingPreview() {
        return CharcoalDrawingPreview;
    }
    private static final int JPEGPreview = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JPEGPreview = 29
     * }
     */
    public static int JPEGPreview() {
        return JPEGPreview;
    }
    private static final int UndefinedIntent = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedIntent = 0
     * }
     */
    public static int UndefinedIntent() {
        return UndefinedIntent;
    }
    private static final int SaturationIntent = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SaturationIntent = 1
     * }
     */
    public static int SaturationIntent() {
        return SaturationIntent;
    }
    private static final int PerceptualIntent = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PerceptualIntent = 2
     * }
     */
    public static int PerceptualIntent() {
        return PerceptualIntent;
    }
    private static final int AbsoluteIntent = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AbsoluteIntent = 3
     * }
     */
    public static int AbsoluteIntent() {
        return AbsoluteIntent;
    }
    private static final int RelativeIntent = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RelativeIntent = 4
     * }
     */
    public static int RelativeIntent() {
        return RelativeIntent;
    }
    private static final int UndefinedResolution = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedResolution = 0
     * }
     */
    public static int UndefinedResolution() {
        return UndefinedResolution;
    }
    private static final int PixelsPerInchResolution = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PixelsPerInchResolution = 1
     * }
     */
    public static int PixelsPerInchResolution() {
        return PixelsPerInchResolution;
    }
    private static final int PixelsPerCentimeterResolution = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PixelsPerCentimeterResolution = 2
     * }
     */
    public static int PixelsPerCentimeterResolution() {
        return PixelsPerCentimeterResolution;
    }
    /**
     * {@snippet lang=c :
     * typedef Quantum IndexPacket
     * }
     */
    public static final OfShort IndexPacket = magick_wand_h.C_SHORT;

    private static class CatchImageException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CatchImageException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ExceptionType CatchImageException(Image *)
     * }
     */
    public static FunctionDescriptor CatchImageException$descriptor() {
        return CatchImageException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ExceptionType CatchImageException(Image *)
     * }
     */
    public static MethodHandle CatchImageException$handle() {
        return CatchImageException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ExceptionType CatchImageException(Image *)
     * }
     */
    public static MemorySegment CatchImageException$address() {
        return CatchImageException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ExceptionType CatchImageException(Image *)
     * }
     */
    public static int CatchImageException(MemorySegment x0) {
        var mh$ = CatchImageException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CatchImageException", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AllocateImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *AllocateImage(const ImageInfo *)
     * }
     */
    public static FunctionDescriptor AllocateImage$descriptor() {
        return AllocateImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *AllocateImage(const ImageInfo *)
     * }
     */
    public static MethodHandle AllocateImage$handle() {
        return AllocateImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *AllocateImage(const ImageInfo *)
     * }
     */
    public static MemorySegment AllocateImage$address() {
        return AllocateImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *AllocateImage(const ImageInfo *)
     * }
     */
    public static MemorySegment AllocateImage(MemorySegment x0) {
        var mh$ = AllocateImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateImage", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AppendImages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AppendImages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *AppendImages(const Image *, const unsigned int, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor AppendImages$descriptor() {
        return AppendImages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *AppendImages(const Image *, const unsigned int, ExceptionInfo *)
     * }
     */
    public static MethodHandle AppendImages$handle() {
        return AppendImages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *AppendImages(const Image *, const unsigned int, ExceptionInfo *)
     * }
     */
    public static MemorySegment AppendImages$address() {
        return AppendImages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *AppendImages(const Image *, const unsigned int, ExceptionInfo *)
     * }
     */
    public static MemorySegment AppendImages(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = AppendImages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AppendImages", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloneImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CloneImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *CloneImage(const Image *, const unsigned long, const unsigned long, const unsigned int, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor CloneImage$descriptor() {
        return CloneImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *CloneImage(const Image *, const unsigned long, const unsigned long, const unsigned int, ExceptionInfo *)
     * }
     */
    public static MethodHandle CloneImage$handle() {
        return CloneImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *CloneImage(const Image *, const unsigned long, const unsigned long, const unsigned int, ExceptionInfo *)
     * }
     */
    public static MemorySegment CloneImage$address() {
        return CloneImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *CloneImage(const Image *, const unsigned long, const unsigned long, const unsigned int, ExceptionInfo *)
     * }
     */
    public static MemorySegment CloneImage(MemorySegment x0, long x1, long x2, int x3, MemorySegment x4) {
        var mh$ = CloneImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloneImage", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageClipMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageClipMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *GetImageClipMask(const Image *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor GetImageClipMask$descriptor() {
        return GetImageClipMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *GetImageClipMask(const Image *, ExceptionInfo *)
     * }
     */
    public static MethodHandle GetImageClipMask$handle() {
        return GetImageClipMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *GetImageClipMask(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment GetImageClipMask$address() {
        return GetImageClipMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *GetImageClipMask(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment GetImageClipMask(MemorySegment x0, MemorySegment x1) {
        var mh$ = GetImageClipMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageClipMask", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageCompositeMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageCompositeMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *GetImageCompositeMask(const Image *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor GetImageCompositeMask$descriptor() {
        return GetImageCompositeMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *GetImageCompositeMask(const Image *, ExceptionInfo *)
     * }
     */
    public static MethodHandle GetImageCompositeMask$handle() {
        return GetImageCompositeMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *GetImageCompositeMask(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment GetImageCompositeMask$address() {
        return GetImageCompositeMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *GetImageCompositeMask(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment GetImageCompositeMask(MemorySegment x0, MemorySegment x1) {
        var mh$ = GetImageCompositeMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageCompositeMask", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReferenceImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReferenceImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ReferenceImage(Image *)
     * }
     */
    public static FunctionDescriptor ReferenceImage$descriptor() {
        return ReferenceImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ReferenceImage(Image *)
     * }
     */
    public static MethodHandle ReferenceImage$handle() {
        return ReferenceImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ReferenceImage(Image *)
     * }
     */
    public static MemorySegment ReferenceImage$address() {
        return ReferenceImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ReferenceImage(Image *)
     * }
     */
    public static MemorySegment ReferenceImage(MemorySegment x0) {
        var mh$ = ReferenceImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReferenceImage", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloneImageInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CloneImageInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ImageInfo *CloneImageInfo(const ImageInfo *)
     * }
     */
    public static FunctionDescriptor CloneImageInfo$descriptor() {
        return CloneImageInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ImageInfo *CloneImageInfo(const ImageInfo *)
     * }
     */
    public static MethodHandle CloneImageInfo$handle() {
        return CloneImageInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ImageInfo *CloneImageInfo(const ImageInfo *)
     * }
     */
    public static MemorySegment CloneImageInfo$address() {
        return CloneImageInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ImageInfo *CloneImageInfo(const ImageInfo *)
     * }
     */
    public static MemorySegment CloneImageInfo(MemorySegment x0) {
        var mh$ = CloneImageInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloneImageInfo", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessDefinition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AccessDefinition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *AccessDefinition(const ImageInfo *image_info, const char *magick, const char *key)
     * }
     */
    public static FunctionDescriptor AccessDefinition$descriptor() {
        return AccessDefinition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *AccessDefinition(const ImageInfo *image_info, const char *magick, const char *key)
     * }
     */
    public static MethodHandle AccessDefinition$handle() {
        return AccessDefinition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *AccessDefinition(const ImageInfo *image_info, const char *magick, const char *key)
     * }
     */
    public static MemorySegment AccessDefinition$address() {
        return AccessDefinition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *AccessDefinition(const ImageInfo *image_info, const char *magick, const char *key)
     * }
     */
    public static MemorySegment AccessDefinition(MemorySegment image_info, MemorySegment magick, MemorySegment key) {
        var mh$ = AccessDefinition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessDefinition", image_info, magick, key);
            }
            return (MemorySegment)mh$.invokeExact(image_info, magick, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageGeometry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageGeometry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int GetImageGeometry(const Image *, const char *, const unsigned int, RectangleInfo *)
     * }
     */
    public static FunctionDescriptor GetImageGeometry$descriptor() {
        return GetImageGeometry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int GetImageGeometry(const Image *, const char *, const unsigned int, RectangleInfo *)
     * }
     */
    public static MethodHandle GetImageGeometry$handle() {
        return GetImageGeometry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int GetImageGeometry(const Image *, const char *, const unsigned int, RectangleInfo *)
     * }
     */
    public static MemorySegment GetImageGeometry$address() {
        return GetImageGeometry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int GetImageGeometry(const Image *, const char *, const unsigned int, RectangleInfo *)
     * }
     */
    public static int GetImageGeometry(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = GetImageGeometry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageGeometry", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsTaintImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IsTaintImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IsTaintImage(const Image *)
     * }
     */
    public static FunctionDescriptor IsTaintImage$descriptor() {
        return IsTaintImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IsTaintImage(const Image *)
     * }
     */
    public static MethodHandle IsTaintImage$handle() {
        return IsTaintImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IsTaintImage(const Image *)
     * }
     */
    public static MemorySegment IsTaintImage$address() {
        return IsTaintImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IsTaintImage(const Image *)
     * }
     */
    public static int IsTaintImage(MemorySegment x0) {
        var mh$ = IsTaintImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsTaintImage", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsSubimage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IsSubimage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IsSubimage(const char *, const unsigned int)
     * }
     */
    public static FunctionDescriptor IsSubimage$descriptor() {
        return IsSubimage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IsSubimage(const char *, const unsigned int)
     * }
     */
    public static MethodHandle IsSubimage$handle() {
        return IsSubimage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IsSubimage(const char *, const unsigned int)
     * }
     */
    public static MemorySegment IsSubimage$address() {
        return IsSubimage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IsSubimage(const char *, const unsigned int)
     * }
     */
    public static int IsSubimage(MemorySegment x0, int x1) {
        var mh$ = IsSubimage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsSubimage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddDefinition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AddDefinition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int AddDefinition(ImageInfo *image_info, const char *magick, const char *key, const char *value, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor AddDefinition$descriptor() {
        return AddDefinition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int AddDefinition(ImageInfo *image_info, const char *magick, const char *key, const char *value, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle AddDefinition$handle() {
        return AddDefinition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int AddDefinition(ImageInfo *image_info, const char *magick, const char *key, const char *value, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment AddDefinition$address() {
        return AddDefinition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int AddDefinition(ImageInfo *image_info, const char *magick, const char *key, const char *value, ExceptionInfo *exception)
     * }
     */
    public static int AddDefinition(MemorySegment image_info, MemorySegment magick, MemorySegment key, MemorySegment value, MemorySegment exception) {
        var mh$ = AddDefinition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddDefinition", image_info, magick, key, value, exception);
            }
            return (int)mh$.invokeExact(image_info, magick, key, value, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddDefinitions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AddDefinitions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int AddDefinitions(ImageInfo *image_info, const char *options, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor AddDefinitions$descriptor() {
        return AddDefinitions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int AddDefinitions(ImageInfo *image_info, const char *options, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle AddDefinitions$handle() {
        return AddDefinitions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int AddDefinitions(ImageInfo *image_info, const char *options, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment AddDefinitions$address() {
        return AddDefinitions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int AddDefinitions(ImageInfo *image_info, const char *options, ExceptionInfo *exception)
     * }
     */
    public static int AddDefinitions(MemorySegment image_info, MemorySegment options, MemorySegment exception) {
        var mh$ = AddDefinitions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddDefinitions", image_info, options, exception);
            }
            return (int)mh$.invokeExact(image_info, options, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimateImages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AnimateImages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int AnimateImages(const ImageInfo *image_info, Image *image)
     * }
     */
    public static FunctionDescriptor AnimateImages$descriptor() {
        return AnimateImages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int AnimateImages(const ImageInfo *image_info, Image *image)
     * }
     */
    public static MethodHandle AnimateImages$handle() {
        return AnimateImages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int AnimateImages(const ImageInfo *image_info, Image *image)
     * }
     */
    public static MemorySegment AnimateImages$address() {
        return AnimateImages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int AnimateImages(const ImageInfo *image_info, Image *image)
     * }
     */
    public static int AnimateImages(MemorySegment image_info, MemorySegment image) {
        var mh$ = AnimateImages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimateImages", image_info, image);
            }
            return (int)mh$.invokeExact(image_info, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClipImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ClipImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ClipImage(Image *image)
     * }
     */
    public static FunctionDescriptor ClipImage$descriptor() {
        return ClipImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ClipImage(Image *image)
     * }
     */
    public static MethodHandle ClipImage$handle() {
        return ClipImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ClipImage(Image *image)
     * }
     */
    public static MemorySegment ClipImage$address() {
        return ClipImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ClipImage(Image *image)
     * }
     */
    public static int ClipImage(MemorySegment image) {
        var mh$ = ClipImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClipImage", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClipPathImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ClipPathImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ClipPathImage(Image *image, const char *pathname, const unsigned int inside)
     * }
     */
    public static FunctionDescriptor ClipPathImage$descriptor() {
        return ClipPathImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ClipPathImage(Image *image, const char *pathname, const unsigned int inside)
     * }
     */
    public static MethodHandle ClipPathImage$handle() {
        return ClipPathImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ClipPathImage(Image *image, const char *pathname, const unsigned int inside)
     * }
     */
    public static MemorySegment ClipPathImage$address() {
        return ClipPathImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ClipPathImage(Image *image, const char *pathname, const unsigned int inside)
     * }
     */
    public static int ClipPathImage(MemorySegment image, MemorySegment pathname, int inside) {
        var mh$ = ClipPathImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClipPathImage", image, pathname, inside);
            }
            return (int)mh$.invokeExact(image, pathname, inside);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompositeMaskImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CompositeMaskImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int CompositeMaskImage(Image *image)
     * }
     */
    public static FunctionDescriptor CompositeMaskImage$descriptor() {
        return CompositeMaskImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int CompositeMaskImage(Image *image)
     * }
     */
    public static MethodHandle CompositeMaskImage$handle() {
        return CompositeMaskImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int CompositeMaskImage(Image *image)
     * }
     */
    public static MemorySegment CompositeMaskImage$address() {
        return CompositeMaskImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int CompositeMaskImage(Image *image)
     * }
     */
    public static int CompositeMaskImage(MemorySegment image) {
        var mh$ = CompositeMaskImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompositeMaskImage", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompositePathImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CompositePathImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int CompositePathImage(Image *image, const char *pathname, const unsigned int inside)
     * }
     */
    public static FunctionDescriptor CompositePathImage$descriptor() {
        return CompositePathImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int CompositePathImage(Image *image, const char *pathname, const unsigned int inside)
     * }
     */
    public static MethodHandle CompositePathImage$handle() {
        return CompositePathImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int CompositePathImage(Image *image, const char *pathname, const unsigned int inside)
     * }
     */
    public static MemorySegment CompositePathImage$address() {
        return CompositePathImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int CompositePathImage(Image *image, const char *pathname, const unsigned int inside)
     * }
     */
    public static int CompositePathImage(MemorySegment image, MemorySegment pathname, int inside) {
        var mh$ = CompositePathImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompositePathImage", image, pathname, inside);
            }
            return (int)mh$.invokeExact(image, pathname, inside);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisplayImages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DisplayImages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int DisplayImages(const ImageInfo *image_info, Image *image)
     * }
     */
    public static FunctionDescriptor DisplayImages$descriptor() {
        return DisplayImages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int DisplayImages(const ImageInfo *image_info, Image *image)
     * }
     */
    public static MethodHandle DisplayImages$handle() {
        return DisplayImages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int DisplayImages(const ImageInfo *image_info, Image *image)
     * }
     */
    public static MemorySegment DisplayImages$address() {
        return DisplayImages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int DisplayImages(const ImageInfo *image_info, Image *image)
     * }
     */
    public static int DisplayImages(MemorySegment image_info, MemorySegment image) {
        var mh$ = DisplayImages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisplayImages", image_info, image);
            }
            return (int)mh$.invokeExact(image_info, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDefinitions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("RemoveDefinitions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int RemoveDefinitions(const ImageInfo *image_info, const char *options)
     * }
     */
    public static FunctionDescriptor RemoveDefinitions$descriptor() {
        return RemoveDefinitions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int RemoveDefinitions(const ImageInfo *image_info, const char *options)
     * }
     */
    public static MethodHandle RemoveDefinitions$handle() {
        return RemoveDefinitions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int RemoveDefinitions(const ImageInfo *image_info, const char *options)
     * }
     */
    public static MemorySegment RemoveDefinitions$address() {
        return RemoveDefinitions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int RemoveDefinitions(const ImageInfo *image_info, const char *options)
     * }
     */
    public static int RemoveDefinitions(MemorySegment image_info, MemorySegment options) {
        var mh$ = RemoveDefinitions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDefinitions", image_info, options);
            }
            return (int)mh$.invokeExact(image_info, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetImagePage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ResetImagePage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ResetImagePage(Image *image, const char *page)
     * }
     */
    public static FunctionDescriptor ResetImagePage$descriptor() {
        return ResetImagePage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ResetImagePage(Image *image, const char *page)
     * }
     */
    public static MethodHandle ResetImagePage$handle() {
        return ResetImagePage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ResetImagePage(Image *image, const char *page)
     * }
     */
    public static MemorySegment ResetImagePage$address() {
        return ResetImagePage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ResetImagePage(Image *image, const char *page)
     * }
     */
    public static int ResetImagePage(MemorySegment image, MemorySegment page) {
        var mh$ = ResetImagePage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetImagePage", image, page);
            }
            return (int)mh$.invokeExact(image, page);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_SHORT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SetImage(Image *image, const Quantum)
     * }
     */
    public static FunctionDescriptor SetImage$descriptor() {
        return SetImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SetImage(Image *image, const Quantum)
     * }
     */
    public static MethodHandle SetImage$handle() {
        return SetImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SetImage(Image *image, const Quantum)
     * }
     */
    public static MemorySegment SetImage$address() {
        return SetImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SetImage(Image *image, const Quantum)
     * }
     */
    public static int SetImage(MemorySegment image, short x1) {
        var mh$ = SetImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetImage", image, x1);
            }
            return (int)mh$.invokeExact(image, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetImageEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_SHORT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetImageEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SetImageEx(Image *image, const Quantum opacity, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor SetImageEx$descriptor() {
        return SetImageEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SetImageEx(Image *image, const Quantum opacity, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle SetImageEx$handle() {
        return SetImageEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SetImageEx(Image *image, const Quantum opacity, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment SetImageEx$address() {
        return SetImageEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SetImageEx(Image *image, const Quantum opacity, ExceptionInfo *exception)
     * }
     */
    public static int SetImageEx(MemorySegment image, short opacity, MemorySegment exception) {
        var mh$ = SetImageEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetImageEx", image, opacity, exception);
            }
            return (int)mh$.invokeExact(image, opacity, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetImageColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetImageColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SetImageColor(Image *image, const PixelPacket *pixel)
     * }
     */
    public static FunctionDescriptor SetImageColor$descriptor() {
        return SetImageColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SetImageColor(Image *image, const PixelPacket *pixel)
     * }
     */
    public static MethodHandle SetImageColor$handle() {
        return SetImageColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SetImageColor(Image *image, const PixelPacket *pixel)
     * }
     */
    public static MemorySegment SetImageColor$address() {
        return SetImageColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SetImageColor(Image *image, const PixelPacket *pixel)
     * }
     */
    public static int SetImageColor(MemorySegment image, MemorySegment pixel) {
        var mh$ = SetImageColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetImageColor", image, pixel);
            }
            return (int)mh$.invokeExact(image, pixel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetImageColorRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetImageColorRegion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SetImageColorRegion(Image *image, long x, long y, unsigned long width, unsigned long height, const PixelPacket *pixel)
     * }
     */
    public static FunctionDescriptor SetImageColorRegion$descriptor() {
        return SetImageColorRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SetImageColorRegion(Image *image, long x, long y, unsigned long width, unsigned long height, const PixelPacket *pixel)
     * }
     */
    public static MethodHandle SetImageColorRegion$handle() {
        return SetImageColorRegion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SetImageColorRegion(Image *image, long x, long y, unsigned long width, unsigned long height, const PixelPacket *pixel)
     * }
     */
    public static MemorySegment SetImageColorRegion$address() {
        return SetImageColorRegion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SetImageColorRegion(Image *image, long x, long y, unsigned long width, unsigned long height, const PixelPacket *pixel)
     * }
     */
    public static int SetImageColorRegion(MemorySegment image, long x, long y, long width, long height, MemorySegment pixel) {
        var mh$ = SetImageColorRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetImageColorRegion", image, x, y, width, height, pixel);
            }
            return (int)mh$.invokeExact(image, x, y, width, height, pixel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetImageClipMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetImageClipMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SetImageClipMask(Image *image, const Image *clip_mask)
     * }
     */
    public static FunctionDescriptor SetImageClipMask$descriptor() {
        return SetImageClipMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SetImageClipMask(Image *image, const Image *clip_mask)
     * }
     */
    public static MethodHandle SetImageClipMask$handle() {
        return SetImageClipMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SetImageClipMask(Image *image, const Image *clip_mask)
     * }
     */
    public static MemorySegment SetImageClipMask$address() {
        return SetImageClipMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SetImageClipMask(Image *image, const Image *clip_mask)
     * }
     */
    public static int SetImageClipMask(MemorySegment image, MemorySegment clip_mask) {
        var mh$ = SetImageClipMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetImageClipMask", image, clip_mask);
            }
            return (int)mh$.invokeExact(image, clip_mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetImageCompositeMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetImageCompositeMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SetImageCompositeMask(Image *image, const Image *composite_mask)
     * }
     */
    public static FunctionDescriptor SetImageCompositeMask$descriptor() {
        return SetImageCompositeMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SetImageCompositeMask(Image *image, const Image *composite_mask)
     * }
     */
    public static MethodHandle SetImageCompositeMask$handle() {
        return SetImageCompositeMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SetImageCompositeMask(Image *image, const Image *composite_mask)
     * }
     */
    public static MemorySegment SetImageCompositeMask$address() {
        return SetImageCompositeMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SetImageCompositeMask(Image *image, const Image *composite_mask)
     * }
     */
    public static int SetImageCompositeMask(MemorySegment image, MemorySegment composite_mask) {
        var mh$ = SetImageCompositeMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetImageCompositeMask", image, composite_mask);
            }
            return (int)mh$.invokeExact(image, composite_mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetImageDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetImageDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SetImageDepth(Image *image, const unsigned long)
     * }
     */
    public static FunctionDescriptor SetImageDepth$descriptor() {
        return SetImageDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SetImageDepth(Image *image, const unsigned long)
     * }
     */
    public static MethodHandle SetImageDepth$handle() {
        return SetImageDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SetImageDepth(Image *image, const unsigned long)
     * }
     */
    public static MemorySegment SetImageDepth$address() {
        return SetImageDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SetImageDepth(Image *image, const unsigned long)
     * }
     */
    public static int SetImageDepth(MemorySegment image, long x1) {
        var mh$ = SetImageDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetImageDepth", image, x1);
            }
            return (int)mh$.invokeExact(image, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetImageInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetImageInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SetImageInfo(ImageInfo *image_info, const unsigned int flags, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor SetImageInfo$descriptor() {
        return SetImageInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SetImageInfo(ImageInfo *image_info, const unsigned int flags, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle SetImageInfo$handle() {
        return SetImageInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SetImageInfo(ImageInfo *image_info, const unsigned int flags, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment SetImageInfo$address() {
        return SetImageInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SetImageInfo(ImageInfo *image_info, const unsigned int flags, ExceptionInfo *exception)
     * }
     */
    public static int SetImageInfo(MemorySegment image_info, int flags, MemorySegment exception) {
        var mh$ = SetImageInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetImageInfo", image_info, flags, exception);
            }
            return (int)mh$.invokeExact(image_info, flags, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetImageOpacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetImageOpacity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SetImageOpacity(Image *, const unsigned int)
     * }
     */
    public static FunctionDescriptor SetImageOpacity$descriptor() {
        return SetImageOpacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SetImageOpacity(Image *, const unsigned int)
     * }
     */
    public static MethodHandle SetImageOpacity$handle() {
        return SetImageOpacity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SetImageOpacity(Image *, const unsigned int)
     * }
     */
    public static MemorySegment SetImageOpacity$address() {
        return SetImageOpacity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SetImageOpacity(Image *, const unsigned int)
     * }
     */
    public static int SetImageOpacity(MemorySegment x0, int x1) {
        var mh$ = SetImageOpacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetImageOpacity", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetImageType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetImageType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SetImageType(Image *image, const ImageType)
     * }
     */
    public static FunctionDescriptor SetImageType$descriptor() {
        return SetImageType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SetImageType(Image *image, const ImageType)
     * }
     */
    public static MethodHandle SetImageType$handle() {
        return SetImageType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SetImageType(Image *image, const ImageType)
     * }
     */
    public static MemorySegment SetImageType$address() {
        return SetImageType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SetImageType(Image *image, const ImageType)
     * }
     */
    public static int SetImageType(MemorySegment image, int x1) {
        var mh$ = SetImageType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetImageType", image, x1);
            }
            return (int)mh$.invokeExact(image, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StripImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StripImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int StripImage(Image *image)
     * }
     */
    public static FunctionDescriptor StripImage$descriptor() {
        return StripImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int StripImage(Image *image)
     * }
     */
    public static MethodHandle StripImage$handle() {
        return StripImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int StripImage(Image *image)
     * }
     */
    public static MemorySegment StripImage$address() {
        return StripImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int StripImage(Image *image)
     * }
     */
    public static int StripImage(MemorySegment image) {
        var mh$ = StripImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StripImage", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SyncImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SyncImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SyncImage(Image *image)
     * }
     */
    public static FunctionDescriptor SyncImage$descriptor() {
        return SyncImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SyncImage(Image *image)
     * }
     */
    public static MethodHandle SyncImage$handle() {
        return SyncImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SyncImage(Image *image)
     * }
     */
    public static MemorySegment SyncImage$address() {
        return SyncImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SyncImage(Image *image)
     * }
     */
    public static int SyncImage(MemorySegment image) {
        var mh$ = SyncImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SyncImage", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateNextImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AllocateNextImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void AllocateNextImage(const ImageInfo *, Image *)
     * }
     */
    public static FunctionDescriptor AllocateNextImage$descriptor() {
        return AllocateNextImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void AllocateNextImage(const ImageInfo *, Image *)
     * }
     */
    public static MethodHandle AllocateNextImage$handle() {
        return AllocateNextImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void AllocateNextImage(const ImageInfo *, Image *)
     * }
     */
    public static MemorySegment AllocateNextImage$address() {
        return AllocateNextImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void AllocateNextImage(const ImageInfo *, Image *)
     * }
     */
    public static void AllocateNextImage(MemorySegment x0, MemorySegment x1) {
        var mh$ = AllocateNextImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateNextImage", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DestroyImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DestroyImage(Image *)
     * }
     */
    public static FunctionDescriptor DestroyImage$descriptor() {
        return DestroyImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DestroyImage(Image *)
     * }
     */
    public static MethodHandle DestroyImage$handle() {
        return DestroyImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DestroyImage(Image *)
     * }
     */
    public static MemorySegment DestroyImage$address() {
        return DestroyImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DestroyImage(Image *)
     * }
     */
    public static void DestroyImage(MemorySegment x0) {
        var mh$ = DestroyImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyImage", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyImageInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DestroyImageInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DestroyImageInfo(ImageInfo *)
     * }
     */
    public static FunctionDescriptor DestroyImageInfo$descriptor() {
        return DestroyImageInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DestroyImageInfo(ImageInfo *)
     * }
     */
    public static MethodHandle DestroyImageInfo$handle() {
        return DestroyImageInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DestroyImageInfo(ImageInfo *)
     * }
     */
    public static MemorySegment DestroyImageInfo$address() {
        return DestroyImageInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DestroyImageInfo(ImageInfo *)
     * }
     */
    public static void DestroyImageInfo(MemorySegment x0) {
        var mh$ = DestroyImageInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyImageInfo", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void GetImageException(Image *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor GetImageException$descriptor() {
        return GetImageException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void GetImageException(Image *, ExceptionInfo *)
     * }
     */
    public static MethodHandle GetImageException$handle() {
        return GetImageException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void GetImageException(Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment GetImageException$address() {
        return GetImageException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void GetImageException(Image *, ExceptionInfo *)
     * }
     */
    public static void GetImageException(MemorySegment x0, MemorySegment x1) {
        var mh$ = GetImageException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageException", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void GetImageInfo(ImageInfo *)
     * }
     */
    public static FunctionDescriptor GetImageInfo$descriptor() {
        return GetImageInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void GetImageInfo(ImageInfo *)
     * }
     */
    public static MethodHandle GetImageInfo$handle() {
        return GetImageInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void GetImageInfo(ImageInfo *)
     * }
     */
    public static MemorySegment GetImageInfo$address() {
        return GetImageInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void GetImageInfo(ImageInfo *)
     * }
     */
    public static void GetImageInfo(MemorySegment x0) {
        var mh$ = GetImageInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageInfo", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ModifyImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ModifyImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ModifyImage(Image **, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor ModifyImage$descriptor() {
        return ModifyImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ModifyImage(Image **, ExceptionInfo *)
     * }
     */
    public static MethodHandle ModifyImage$handle() {
        return ModifyImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ModifyImage(Image **, ExceptionInfo *)
     * }
     */
    public static MemorySegment ModifyImage$address() {
        return ModifyImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ModifyImage(Image **, ExceptionInfo *)
     * }
     */
    public static void ModifyImage(MemorySegment x0, MemorySegment x1) {
        var mh$ = ModifyImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ModifyImage", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageGetClipMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ImageGetClipMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image **ImageGetClipMask(const Image *)
     * }
     */
    public static FunctionDescriptor ImageGetClipMask$descriptor() {
        return ImageGetClipMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image **ImageGetClipMask(const Image *)
     * }
     */
    public static MethodHandle ImageGetClipMask$handle() {
        return ImageGetClipMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image **ImageGetClipMask(const Image *)
     * }
     */
    public static MemorySegment ImageGetClipMask$address() {
        return ImageGetClipMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image **ImageGetClipMask(const Image *)
     * }
     */
    public static MemorySegment ImageGetClipMask(MemorySegment x0) {
        var mh$ = ImageGetClipMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageGetClipMask", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageGetCompositeMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ImageGetCompositeMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image **ImageGetCompositeMask(const Image *)
     * }
     */
    public static FunctionDescriptor ImageGetCompositeMask$descriptor() {
        return ImageGetCompositeMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image **ImageGetCompositeMask(const Image *)
     * }
     */
    public static MethodHandle ImageGetCompositeMask$handle() {
        return ImageGetCompositeMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image **ImageGetCompositeMask(const Image *)
     * }
     */
    public static MemorySegment ImageGetCompositeMask$address() {
        return ImageGetCompositeMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image **ImageGetCompositeMask(const Image *)
     * }
     */
    public static MemorySegment ImageGetCompositeMask(MemorySegment x0) {
        var mh$ = ImageGetCompositeMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageGetCompositeMask", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageCharacteristics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageCharacteristics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int GetImageCharacteristics(const Image *image, ImageCharacteristics *characteristics, const unsigned int optimize, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetImageCharacteristics$descriptor() {
        return GetImageCharacteristics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int GetImageCharacteristics(const Image *image, ImageCharacteristics *characteristics, const unsigned int optimize, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetImageCharacteristics$handle() {
        return GetImageCharacteristics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int GetImageCharacteristics(const Image *image, ImageCharacteristics *characteristics, const unsigned int optimize, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetImageCharacteristics$address() {
        return GetImageCharacteristics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int GetImageCharacteristics(const Image *image, ImageCharacteristics *characteristics, const unsigned int optimize, ExceptionInfo *exception)
     * }
     */
    public static int GetImageCharacteristics(MemorySegment image, MemorySegment characteristics, int optimize, MemorySegment exception) {
        var mh$ = GetImageCharacteristics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageCharacteristics", image, characteristics, optimize, exception);
            }
            return (int)mh$.invokeExact(image, characteristics, optimize, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long GetImageDepth(const Image *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor GetImageDepth$descriptor() {
        return GetImageDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long GetImageDepth(const Image *, ExceptionInfo *)
     * }
     */
    public static MethodHandle GetImageDepth$handle() {
        return GetImageDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long GetImageDepth(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment GetImageDepth$address() {
        return GetImageDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long GetImageDepth(const Image *, ExceptionInfo *)
     * }
     */
    public static long GetImageDepth(MemorySegment x0, MemorySegment x1) {
        var mh$ = GetImageDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageDepth", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsGrayImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IsGrayImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IsGrayImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor IsGrayImage$descriptor() {
        return IsGrayImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IsGrayImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle IsGrayImage$handle() {
        return IsGrayImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IsGrayImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment IsGrayImage$address() {
        return IsGrayImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IsGrayImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static int IsGrayImage(MemorySegment image, MemorySegment exception) {
        var mh$ = IsGrayImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsGrayImage", image, exception);
            }
            return (int)mh$.invokeExact(image, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMonochromeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IsMonochromeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IsMonochromeImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor IsMonochromeImage$descriptor() {
        return IsMonochromeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IsMonochromeImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle IsMonochromeImage$handle() {
        return IsMonochromeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IsMonochromeImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment IsMonochromeImage$address() {
        return IsMonochromeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IsMonochromeImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static int IsMonochromeImage(MemorySegment image, MemorySegment exception) {
        var mh$ = IsMonochromeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMonochromeImage", image, exception);
            }
            return (int)mh$.invokeExact(image, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsOpaqueImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IsOpaqueImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IsOpaqueImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor IsOpaqueImage$descriptor() {
        return IsOpaqueImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IsOpaqueImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle IsOpaqueImage$handle() {
        return IsOpaqueImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IsOpaqueImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment IsOpaqueImage$address() {
        return IsOpaqueImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IsOpaqueImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static int IsOpaqueImage(MemorySegment image, MemorySegment exception) {
        var mh$ = IsOpaqueImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsOpaqueImage", image, exception);
            }
            return (int)mh$.invokeExact(image, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ImageType GetImageType(const Image *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor GetImageType$descriptor() {
        return GetImageType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ImageType GetImageType(const Image *, ExceptionInfo *)
     * }
     */
    public static MethodHandle GetImageType$handle() {
        return GetImageType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ImageType GetImageType(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment GetImageType$address() {
        return GetImageType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ImageType GetImageType(const Image *, ExceptionInfo *)
     * }
     */
    public static int GetImageType(MemorySegment x0, MemorySegment x1) {
        var mh$ = GetImageType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageType", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageBoundingBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _RectangleInfo.layout(),
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageBoundingBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern RectangleInfo GetImageBoundingBox(const Image *, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetImageBoundingBox$descriptor() {
        return GetImageBoundingBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern RectangleInfo GetImageBoundingBox(const Image *, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetImageBoundingBox$handle() {
        return GetImageBoundingBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern RectangleInfo GetImageBoundingBox(const Image *, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetImageBoundingBox$address() {
        return GetImageBoundingBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern RectangleInfo GetImageBoundingBox(const Image *, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetImageBoundingBox(SegmentAllocator allocator, MemorySegment x0, MemorySegment exception) {
        var mh$ = GetImageBoundingBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageBoundingBox", allocator, x0, exception);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const ImageAttribute *GetImageAttribute(const Image *image, const char *key)
     * }
     */
    public static FunctionDescriptor GetImageAttribute$descriptor() {
        return GetImageAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const ImageAttribute *GetImageAttribute(const Image *image, const char *key)
     * }
     */
    public static MethodHandle GetImageAttribute$handle() {
        return GetImageAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const ImageAttribute *GetImageAttribute(const Image *image, const char *key)
     * }
     */
    public static MemorySegment GetImageAttribute$address() {
        return GetImageAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const ImageAttribute *GetImageAttribute(const Image *image, const char *key)
     * }
     */
    public static MemorySegment GetImageAttribute(MemorySegment image, MemorySegment key) {
        var mh$ = GetImageAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageAttribute", image, key);
            }
            return (MemorySegment)mh$.invokeExact(image, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageClippingPathAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageClippingPathAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const ImageAttribute *GetImageClippingPathAttribute(const Image *image)
     * }
     */
    public static FunctionDescriptor GetImageClippingPathAttribute$descriptor() {
        return GetImageClippingPathAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const ImageAttribute *GetImageClippingPathAttribute(const Image *image)
     * }
     */
    public static MethodHandle GetImageClippingPathAttribute$handle() {
        return GetImageClippingPathAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const ImageAttribute *GetImageClippingPathAttribute(const Image *image)
     * }
     */
    public static MemorySegment GetImageClippingPathAttribute$address() {
        return GetImageClippingPathAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const ImageAttribute *GetImageClippingPathAttribute(const Image *image)
     * }
     */
    public static MemorySegment GetImageClippingPathAttribute(MemorySegment image) {
        var mh$ = GetImageClippingPathAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageClippingPathAttribute", image);
            }
            return (MemorySegment)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageInfoAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageInfoAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const ImageAttribute *GetImageInfoAttribute(const ImageInfo *image_info, const Image *image, const char *key)
     * }
     */
    public static FunctionDescriptor GetImageInfoAttribute$descriptor() {
        return GetImageInfoAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const ImageAttribute *GetImageInfoAttribute(const ImageInfo *image_info, const Image *image, const char *key)
     * }
     */
    public static MethodHandle GetImageInfoAttribute$handle() {
        return GetImageInfoAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const ImageAttribute *GetImageInfoAttribute(const ImageInfo *image_info, const Image *image, const char *key)
     * }
     */
    public static MemorySegment GetImageInfoAttribute$address() {
        return GetImageInfoAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const ImageAttribute *GetImageInfoAttribute(const ImageInfo *image_info, const Image *image, const char *key)
     * }
     */
    public static MemorySegment GetImageInfoAttribute(MemorySegment image_info, MemorySegment image, MemorySegment key) {
        var mh$ = GetImageInfoAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageInfoAttribute", image_info, image, key);
            }
            return (MemorySegment)mh$.invokeExact(image_info, image, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloneImageAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CloneImageAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int CloneImageAttributes(Image *clone_image, const Image *original_image)
     * }
     */
    public static FunctionDescriptor CloneImageAttributes$descriptor() {
        return CloneImageAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int CloneImageAttributes(Image *clone_image, const Image *original_image)
     * }
     */
    public static MethodHandle CloneImageAttributes$handle() {
        return CloneImageAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int CloneImageAttributes(Image *clone_image, const Image *original_image)
     * }
     */
    public static MemorySegment CloneImageAttributes$address() {
        return CloneImageAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int CloneImageAttributes(Image *clone_image, const Image *original_image)
     * }
     */
    public static int CloneImageAttributes(MemorySegment clone_image, MemorySegment original_image) {
        var mh$ = CloneImageAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloneImageAttributes", clone_image, original_image);
            }
            return (int)mh$.invokeExact(clone_image, original_image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetImageAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetImageAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SetImageAttribute(Image *image, const char *key, const char *value)
     * }
     */
    public static FunctionDescriptor SetImageAttribute$descriptor() {
        return SetImageAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SetImageAttribute(Image *image, const char *key, const char *value)
     * }
     */
    public static MethodHandle SetImageAttribute$handle() {
        return SetImageAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SetImageAttribute(Image *image, const char *key, const char *value)
     * }
     */
    public static MemorySegment SetImageAttribute$address() {
        return SetImageAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SetImageAttribute(Image *image, const char *key, const char *value)
     * }
     */
    public static int SetImageAttribute(MemorySegment image, MemorySegment key, MemorySegment value) {
        var mh$ = SetImageAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetImageAttribute", image, key, value);
            }
            return (int)mh$.invokeExact(image, key, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyImageAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DestroyImageAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DestroyImageAttributes(Image *image)
     * }
     */
    public static FunctionDescriptor DestroyImageAttributes$descriptor() {
        return DestroyImageAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DestroyImageAttributes(Image *image)
     * }
     */
    public static MethodHandle DestroyImageAttributes$handle() {
        return DestroyImageAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DestroyImageAttributes(Image *image)
     * }
     */
    public static MemorySegment DestroyImageAttributes$address() {
        return DestroyImageAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DestroyImageAttributes(Image *image)
     * }
     */
    public static void DestroyImageAttributes(MemorySegment image) {
        var mh$ = DestroyImageAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyImageAttributes", image);
            }
            mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AverageImages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AverageImages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *AverageImages(const Image *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor AverageImages$descriptor() {
        return AverageImages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *AverageImages(const Image *, ExceptionInfo *)
     * }
     */
    public static MethodHandle AverageImages$handle() {
        return AverageImages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *AverageImages(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment AverageImages$address() {
        return AverageImages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *AverageImages(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment AverageImages(MemorySegment x0, MemorySegment x1) {
        var mh$ = AverageImages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AverageImages", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloneBlobInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CloneBlobInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BlobInfo *CloneBlobInfo(const BlobInfo *blob_info)
     * }
     */
    public static FunctionDescriptor CloneBlobInfo$descriptor() {
        return CloneBlobInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BlobInfo *CloneBlobInfo(const BlobInfo *blob_info)
     * }
     */
    public static MethodHandle CloneBlobInfo$handle() {
        return CloneBlobInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BlobInfo *CloneBlobInfo(const BlobInfo *blob_info)
     * }
     */
    public static MemorySegment CloneBlobInfo$address() {
        return CloneBlobInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BlobInfo *CloneBlobInfo(const BlobInfo *blob_info)
     * }
     */
    public static MemorySegment CloneBlobInfo(MemorySegment blob_info) {
        var mh$ = CloneBlobInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloneBlobInfo", blob_info);
            }
            return (MemorySegment)mh$.invokeExact(blob_info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReferenceBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReferenceBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BlobInfo *ReferenceBlob(BlobInfo *blob)
     * }
     */
    public static FunctionDescriptor ReferenceBlob$descriptor() {
        return ReferenceBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BlobInfo *ReferenceBlob(BlobInfo *blob)
     * }
     */
    public static MethodHandle ReferenceBlob$handle() {
        return ReferenceBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BlobInfo *ReferenceBlob(BlobInfo *blob)
     * }
     */
    public static MemorySegment ReferenceBlob$address() {
        return ReferenceBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BlobInfo *ReferenceBlob(BlobInfo *blob)
     * }
     */
    public static MemorySegment ReferenceBlob(MemorySegment blob) {
        var mh$ = ReferenceBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReferenceBlob", blob);
            }
            return (MemorySegment)mh$.invokeExact(blob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyBlobInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DestroyBlobInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DestroyBlobInfo(BlobInfo *blob)
     * }
     */
    public static FunctionDescriptor DestroyBlobInfo$descriptor() {
        return DestroyBlobInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DestroyBlobInfo(BlobInfo *blob)
     * }
     */
    public static MethodHandle DestroyBlobInfo$handle() {
        return DestroyBlobInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DestroyBlobInfo(BlobInfo *blob)
     * }
     */
    public static MemorySegment DestroyBlobInfo$address() {
        return DestroyBlobInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DestroyBlobInfo(BlobInfo *blob)
     * }
     */
    public static void DestroyBlobInfo(MemorySegment blob) {
        var mh$ = DestroyBlobInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyBlobInfo", blob);
            }
            mh$.invokeExact(blob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DetachBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DetachBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DetachBlob(BlobInfo *blob)
     * }
     */
    public static FunctionDescriptor DetachBlob$descriptor() {
        return DetachBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DetachBlob(BlobInfo *blob)
     * }
     */
    public static MethodHandle DetachBlob$handle() {
        return DetachBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DetachBlob(BlobInfo *blob)
     * }
     */
    public static MemorySegment DetachBlob$address() {
        return DetachBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DetachBlob(BlobInfo *blob)
     * }
     */
    public static void DetachBlob(MemorySegment blob) {
        var mh$ = DetachBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DetachBlob", blob);
            }
            mh$.invokeExact(blob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBlobInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetBlobInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void GetBlobInfo(BlobInfo *blob)
     * }
     */
    public static FunctionDescriptor GetBlobInfo$descriptor() {
        return GetBlobInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void GetBlobInfo(BlobInfo *blob)
     * }
     */
    public static MethodHandle GetBlobInfo$handle() {
        return GetBlobInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void GetBlobInfo(BlobInfo *blob)
     * }
     */
    public static MemorySegment GetBlobInfo$address() {
        return GetBlobInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void GetBlobInfo(BlobInfo *blob)
     * }
     */
    public static void GetBlobInfo(MemorySegment blob) {
        var mh$ = GetBlobInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBlobInfo", blob);
            }
            mh$.invokeExact(blob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AttachBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void AttachBlob(BlobInfo *blob_info, const void *blob, const size_t length)
     * }
     */
    public static FunctionDescriptor AttachBlob$descriptor() {
        return AttachBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void AttachBlob(BlobInfo *blob_info, const void *blob, const size_t length)
     * }
     */
    public static MethodHandle AttachBlob$handle() {
        return AttachBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void AttachBlob(BlobInfo *blob_info, const void *blob, const size_t length)
     * }
     */
    public static MemorySegment AttachBlob$address() {
        return AttachBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void AttachBlob(BlobInfo *blob_info, const void *blob, const size_t length)
     * }
     */
    public static void AttachBlob(MemorySegment blob_info, MemorySegment blob, long length) {
        var mh$ = AttachBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachBlob", blob_info, blob, length);
            }
            mh$.invokeExact(blob_info, blob, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DestroyBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DestroyBlob(Image *image)
     * }
     */
    public static FunctionDescriptor DestroyBlob$descriptor() {
        return DestroyBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DestroyBlob(Image *image)
     * }
     */
    public static MethodHandle DestroyBlob$handle() {
        return DestroyBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DestroyBlob(Image *image)
     * }
     */
    public static MemorySegment DestroyBlob$address() {
        return DestroyBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DestroyBlob(Image *image)
     * }
     */
    public static void DestroyBlob(MemorySegment image) {
        var mh$ = DestroyBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyBlob", image);
            }
            mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BlobToImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("BlobToImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *BlobToImage(const ImageInfo *image_info, const void *blob, const size_t length, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor BlobToImage$descriptor() {
        return BlobToImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *BlobToImage(const ImageInfo *image_info, const void *blob, const size_t length, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle BlobToImage$handle() {
        return BlobToImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *BlobToImage(const ImageInfo *image_info, const void *blob, const size_t length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment BlobToImage$address() {
        return BlobToImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *BlobToImage(const ImageInfo *image_info, const void *blob, const size_t length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment BlobToImage(MemorySegment image_info, MemorySegment blob, long length, MemorySegment exception) {
        var mh$ = BlobToImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BlobToImage", image_info, blob, length, exception);
            }
            return (MemorySegment)mh$.invokeExact(image_info, blob, length, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PingBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PingBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *PingBlob(const ImageInfo *image_info, const void *blob, const size_t length, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor PingBlob$descriptor() {
        return PingBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *PingBlob(const ImageInfo *image_info, const void *blob, const size_t length, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle PingBlob$handle() {
        return PingBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *PingBlob(const ImageInfo *image_info, const void *blob, const size_t length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment PingBlob$address() {
        return PingBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *PingBlob(const ImageInfo *image_info, const void *blob, const size_t length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment PingBlob(MemorySegment image_info, MemorySegment blob, long length, MemorySegment exception) {
        var mh$ = PingBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PingBlob", image_info, blob, length, exception);
            }
            return (MemorySegment)mh$.invokeExact(image_info, blob, length, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

