// Generated by jextract

package magick;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _DrawInfo {
 *     char *primitive;
 *     char *geometry;
 *     AffineMatrix affine;
 *     GravityType gravity;
 *     PixelPacket fill;
 *     PixelPacket stroke;
 *     double stroke_width;
 *     GradientInfo gradient;
 *     Image *fill_pattern;
 *     Image *tile;
 *     Image *stroke_pattern;
 *     unsigned int stroke_antialias;
 *     unsigned int text_antialias;
 *     FillRule fill_rule;
 *     LineCap linecap;
 *     LineJoin linejoin;
 *     unsigned long miterlimit;
 *     double dash_offset;
 *     DecorationType decorate;
 *     CompositeOperator compose;
 *     char *text;
 *     char *font;
 *     char *family;
 *     StyleType style;
 *     StretchType stretch;
 *     unsigned long weight;
 *     char *encoding;
 *     double pointsize;
 *     char *density;
 *     AlignType align;
 *     PixelPacket undercolor;
 *     PixelPacket border_color;
 *     char *server_name;
 *     double *dash_pattern;
 *     struct _DrawInfoExtra *extra;
 *     SegmentInfo bounds;
 *     ClipPathUnits clip_units;
 *     Quantum opacity;
 *     unsigned int render;
 *     unsigned int flags;
 *     ElementReference element_reference;
 *     unsigned long signature;
 * }
 * }
 */
public class _DrawInfo {

    _DrawInfo() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        magick_wand_h.C_POINTER.withName("primitive"),
        magick_wand_h.C_POINTER.withName("geometry"),
        _AffineMatrix.layout().withName("affine"),
        magick_wand_h.C_INT.withName("gravity"),
        _PixelPacket.layout().withName("fill"),
        _PixelPacket.layout().withName("stroke"),
        MemoryLayout.paddingLayout(4),
        magick_wand_h.C_DOUBLE.withName("stroke_width"),
        _GradientInfo.layout().withName("gradient"),
        magick_wand_h.C_POINTER.withName("fill_pattern"),
        magick_wand_h.C_POINTER.withName("tile"),
        magick_wand_h.C_POINTER.withName("stroke_pattern"),
        magick_wand_h.C_INT.withName("stroke_antialias"),
        magick_wand_h.C_INT.withName("text_antialias"),
        magick_wand_h.C_INT.withName("fill_rule"),
        magick_wand_h.C_INT.withName("linecap"),
        magick_wand_h.C_INT.withName("linejoin"),
        MemoryLayout.paddingLayout(4),
        magick_wand_h.C_LONG.withName("miterlimit"),
        magick_wand_h.C_DOUBLE.withName("dash_offset"),
        magick_wand_h.C_INT.withName("decorate"),
        magick_wand_h.C_INT.withName("compose"),
        magick_wand_h.C_POINTER.withName("text"),
        magick_wand_h.C_POINTER.withName("font"),
        magick_wand_h.C_POINTER.withName("family"),
        magick_wand_h.C_INT.withName("style"),
        magick_wand_h.C_INT.withName("stretch"),
        magick_wand_h.C_LONG.withName("weight"),
        magick_wand_h.C_POINTER.withName("encoding"),
        magick_wand_h.C_DOUBLE.withName("pointsize"),
        magick_wand_h.C_POINTER.withName("density"),
        magick_wand_h.C_INT.withName("align"),
        _PixelPacket.layout().withName("undercolor"),
        _PixelPacket.layout().withName("border_color"),
        MemoryLayout.paddingLayout(4),
        magick_wand_h.C_POINTER.withName("server_name"),
        magick_wand_h.C_POINTER.withName("dash_pattern"),
        magick_wand_h.C_POINTER.withName("extra"),
        _SegmentInfo.layout().withName("bounds"),
        magick_wand_h.C_INT.withName("clip_units"),
        magick_wand_h.C_SHORT.withName("opacity"),
        MemoryLayout.paddingLayout(2),
        magick_wand_h.C_INT.withName("render"),
        magick_wand_h.C_INT.withName("flags"),
        _ElementReference.layout().withName("element_reference"),
        magick_wand_h.C_LONG.withName("signature")
    ).withName("_DrawInfo");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout primitive$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("primitive"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *primitive
     * }
     */
    public static final AddressLayout primitive$layout() {
        return primitive$LAYOUT;
    }

    private static final long primitive$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *primitive
     * }
     */
    public static final long primitive$offset() {
        return primitive$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *primitive
     * }
     */
    public static MemorySegment primitive(MemorySegment struct) {
        return struct.get(primitive$LAYOUT, primitive$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *primitive
     * }
     */
    public static void primitive(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(primitive$LAYOUT, primitive$OFFSET, fieldValue);
    }

    private static final AddressLayout geometry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("geometry"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *geometry
     * }
     */
    public static final AddressLayout geometry$layout() {
        return geometry$LAYOUT;
    }

    private static final long geometry$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *geometry
     * }
     */
    public static final long geometry$offset() {
        return geometry$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *geometry
     * }
     */
    public static MemorySegment geometry(MemorySegment struct) {
        return struct.get(geometry$LAYOUT, geometry$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *geometry
     * }
     */
    public static void geometry(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(geometry$LAYOUT, geometry$OFFSET, fieldValue);
    }

    private static final GroupLayout affine$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("affine"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AffineMatrix affine
     * }
     */
    public static final GroupLayout affine$layout() {
        return affine$LAYOUT;
    }

    private static final long affine$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AffineMatrix affine
     * }
     */
    public static final long affine$offset() {
        return affine$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AffineMatrix affine
     * }
     */
    public static MemorySegment affine(MemorySegment struct) {
        return struct.asSlice(affine$OFFSET, affine$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AffineMatrix affine
     * }
     */
    public static void affine(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, affine$OFFSET, affine$LAYOUT.byteSize());
    }

    private static final OfInt gravity$LAYOUT = (OfInt)$LAYOUT.select(groupElement("gravity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GravityType gravity
     * }
     */
    public static final OfInt gravity$layout() {
        return gravity$LAYOUT;
    }

    private static final long gravity$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GravityType gravity
     * }
     */
    public static final long gravity$offset() {
        return gravity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GravityType gravity
     * }
     */
    public static int gravity(MemorySegment struct) {
        return struct.get(gravity$LAYOUT, gravity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GravityType gravity
     * }
     */
    public static void gravity(MemorySegment struct, int fieldValue) {
        struct.set(gravity$LAYOUT, gravity$OFFSET, fieldValue);
    }

    private static final GroupLayout fill$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("fill"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * PixelPacket fill
     * }
     */
    public static final GroupLayout fill$layout() {
        return fill$LAYOUT;
    }

    private static final long fill$OFFSET = 68;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * PixelPacket fill
     * }
     */
    public static final long fill$offset() {
        return fill$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * PixelPacket fill
     * }
     */
    public static MemorySegment fill(MemorySegment struct) {
        return struct.asSlice(fill$OFFSET, fill$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * PixelPacket fill
     * }
     */
    public static void fill(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, fill$OFFSET, fill$LAYOUT.byteSize());
    }

    private static final GroupLayout stroke$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("stroke"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * PixelPacket stroke
     * }
     */
    public static final GroupLayout stroke$layout() {
        return stroke$LAYOUT;
    }

    private static final long stroke$OFFSET = 76;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * PixelPacket stroke
     * }
     */
    public static final long stroke$offset() {
        return stroke$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * PixelPacket stroke
     * }
     */
    public static MemorySegment stroke(MemorySegment struct) {
        return struct.asSlice(stroke$OFFSET, stroke$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * PixelPacket stroke
     * }
     */
    public static void stroke(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, stroke$OFFSET, stroke$LAYOUT.byteSize());
    }

    private static final OfDouble stroke_width$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("stroke_width"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double stroke_width
     * }
     */
    public static final OfDouble stroke_width$layout() {
        return stroke_width$LAYOUT;
    }

    private static final long stroke_width$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double stroke_width
     * }
     */
    public static final long stroke_width$offset() {
        return stroke_width$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double stroke_width
     * }
     */
    public static double stroke_width(MemorySegment struct) {
        return struct.get(stroke_width$LAYOUT, stroke_width$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double stroke_width
     * }
     */
    public static void stroke_width(MemorySegment struct, double fieldValue) {
        struct.set(stroke_width$LAYOUT, stroke_width$OFFSET, fieldValue);
    }

    private static final GroupLayout gradient$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("gradient"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GradientInfo gradient
     * }
     */
    public static final GroupLayout gradient$layout() {
        return gradient$LAYOUT;
    }

    private static final long gradient$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GradientInfo gradient
     * }
     */
    public static final long gradient$offset() {
        return gradient$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GradientInfo gradient
     * }
     */
    public static MemorySegment gradient(MemorySegment struct) {
        return struct.asSlice(gradient$OFFSET, gradient$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GradientInfo gradient
     * }
     */
    public static void gradient(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, gradient$OFFSET, gradient$LAYOUT.byteSize());
    }

    private static final AddressLayout fill_pattern$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fill_pattern"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * Image *fill_pattern
     * }
     */
    public static final AddressLayout fill_pattern$layout() {
        return fill_pattern$LAYOUT;
    }

    private static final long fill_pattern$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * Image *fill_pattern
     * }
     */
    public static final long fill_pattern$offset() {
        return fill_pattern$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * Image *fill_pattern
     * }
     */
    public static MemorySegment fill_pattern(MemorySegment struct) {
        return struct.get(fill_pattern$LAYOUT, fill_pattern$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * Image *fill_pattern
     * }
     */
    public static void fill_pattern(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(fill_pattern$LAYOUT, fill_pattern$OFFSET, fieldValue);
    }

    private static final AddressLayout tile$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("tile"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * Image *tile
     * }
     */
    public static final AddressLayout tile$layout() {
        return tile$LAYOUT;
    }

    private static final long tile$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * Image *tile
     * }
     */
    public static final long tile$offset() {
        return tile$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * Image *tile
     * }
     */
    public static MemorySegment tile(MemorySegment struct) {
        return struct.get(tile$LAYOUT, tile$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * Image *tile
     * }
     */
    public static void tile(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(tile$LAYOUT, tile$OFFSET, fieldValue);
    }

    private static final AddressLayout stroke_pattern$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("stroke_pattern"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * Image *stroke_pattern
     * }
     */
    public static final AddressLayout stroke_pattern$layout() {
        return stroke_pattern$LAYOUT;
    }

    private static final long stroke_pattern$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * Image *stroke_pattern
     * }
     */
    public static final long stroke_pattern$offset() {
        return stroke_pattern$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * Image *stroke_pattern
     * }
     */
    public static MemorySegment stroke_pattern(MemorySegment struct) {
        return struct.get(stroke_pattern$LAYOUT, stroke_pattern$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * Image *stroke_pattern
     * }
     */
    public static void stroke_pattern(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(stroke_pattern$LAYOUT, stroke_pattern$OFFSET, fieldValue);
    }

    private static final OfInt stroke_antialias$LAYOUT = (OfInt)$LAYOUT.select(groupElement("stroke_antialias"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int stroke_antialias
     * }
     */
    public static final OfInt stroke_antialias$layout() {
        return stroke_antialias$LAYOUT;
    }

    private static final long stroke_antialias$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int stroke_antialias
     * }
     */
    public static final long stroke_antialias$offset() {
        return stroke_antialias$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int stroke_antialias
     * }
     */
    public static int stroke_antialias(MemorySegment struct) {
        return struct.get(stroke_antialias$LAYOUT, stroke_antialias$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int stroke_antialias
     * }
     */
    public static void stroke_antialias(MemorySegment struct, int fieldValue) {
        struct.set(stroke_antialias$LAYOUT, stroke_antialias$OFFSET, fieldValue);
    }

    private static final OfInt text_antialias$LAYOUT = (OfInt)$LAYOUT.select(groupElement("text_antialias"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int text_antialias
     * }
     */
    public static final OfInt text_antialias$layout() {
        return text_antialias$LAYOUT;
    }

    private static final long text_antialias$OFFSET = 212;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int text_antialias
     * }
     */
    public static final long text_antialias$offset() {
        return text_antialias$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int text_antialias
     * }
     */
    public static int text_antialias(MemorySegment struct) {
        return struct.get(text_antialias$LAYOUT, text_antialias$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int text_antialias
     * }
     */
    public static void text_antialias(MemorySegment struct, int fieldValue) {
        struct.set(text_antialias$LAYOUT, text_antialias$OFFSET, fieldValue);
    }

    private static final OfInt fill_rule$LAYOUT = (OfInt)$LAYOUT.select(groupElement("fill_rule"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FillRule fill_rule
     * }
     */
    public static final OfInt fill_rule$layout() {
        return fill_rule$LAYOUT;
    }

    private static final long fill_rule$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FillRule fill_rule
     * }
     */
    public static final long fill_rule$offset() {
        return fill_rule$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FillRule fill_rule
     * }
     */
    public static int fill_rule(MemorySegment struct) {
        return struct.get(fill_rule$LAYOUT, fill_rule$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FillRule fill_rule
     * }
     */
    public static void fill_rule(MemorySegment struct, int fieldValue) {
        struct.set(fill_rule$LAYOUT, fill_rule$OFFSET, fieldValue);
    }

    private static final OfInt linecap$LAYOUT = (OfInt)$LAYOUT.select(groupElement("linecap"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * LineCap linecap
     * }
     */
    public static final OfInt linecap$layout() {
        return linecap$LAYOUT;
    }

    private static final long linecap$OFFSET = 220;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * LineCap linecap
     * }
     */
    public static final long linecap$offset() {
        return linecap$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * LineCap linecap
     * }
     */
    public static int linecap(MemorySegment struct) {
        return struct.get(linecap$LAYOUT, linecap$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * LineCap linecap
     * }
     */
    public static void linecap(MemorySegment struct, int fieldValue) {
        struct.set(linecap$LAYOUT, linecap$OFFSET, fieldValue);
    }

    private static final OfInt linejoin$LAYOUT = (OfInt)$LAYOUT.select(groupElement("linejoin"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * LineJoin linejoin
     * }
     */
    public static final OfInt linejoin$layout() {
        return linejoin$LAYOUT;
    }

    private static final long linejoin$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * LineJoin linejoin
     * }
     */
    public static final long linejoin$offset() {
        return linejoin$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * LineJoin linejoin
     * }
     */
    public static int linejoin(MemorySegment struct) {
        return struct.get(linejoin$LAYOUT, linejoin$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * LineJoin linejoin
     * }
     */
    public static void linejoin(MemorySegment struct, int fieldValue) {
        struct.set(linejoin$LAYOUT, linejoin$OFFSET, fieldValue);
    }

    private static final OfLong miterlimit$LAYOUT = (OfLong)$LAYOUT.select(groupElement("miterlimit"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned long miterlimit
     * }
     */
    public static final OfLong miterlimit$layout() {
        return miterlimit$LAYOUT;
    }

    private static final long miterlimit$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned long miterlimit
     * }
     */
    public static final long miterlimit$offset() {
        return miterlimit$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned long miterlimit
     * }
     */
    public static long miterlimit(MemorySegment struct) {
        return struct.get(miterlimit$LAYOUT, miterlimit$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned long miterlimit
     * }
     */
    public static void miterlimit(MemorySegment struct, long fieldValue) {
        struct.set(miterlimit$LAYOUT, miterlimit$OFFSET, fieldValue);
    }

    private static final OfDouble dash_offset$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("dash_offset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double dash_offset
     * }
     */
    public static final OfDouble dash_offset$layout() {
        return dash_offset$LAYOUT;
    }

    private static final long dash_offset$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double dash_offset
     * }
     */
    public static final long dash_offset$offset() {
        return dash_offset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double dash_offset
     * }
     */
    public static double dash_offset(MemorySegment struct) {
        return struct.get(dash_offset$LAYOUT, dash_offset$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double dash_offset
     * }
     */
    public static void dash_offset(MemorySegment struct, double fieldValue) {
        struct.set(dash_offset$LAYOUT, dash_offset$OFFSET, fieldValue);
    }

    private static final OfInt decorate$LAYOUT = (OfInt)$LAYOUT.select(groupElement("decorate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * DecorationType decorate
     * }
     */
    public static final OfInt decorate$layout() {
        return decorate$LAYOUT;
    }

    private static final long decorate$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * DecorationType decorate
     * }
     */
    public static final long decorate$offset() {
        return decorate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * DecorationType decorate
     * }
     */
    public static int decorate(MemorySegment struct) {
        return struct.get(decorate$LAYOUT, decorate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * DecorationType decorate
     * }
     */
    public static void decorate(MemorySegment struct, int fieldValue) {
        struct.set(decorate$LAYOUT, decorate$OFFSET, fieldValue);
    }

    private static final OfInt compose$LAYOUT = (OfInt)$LAYOUT.select(groupElement("compose"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * CompositeOperator compose
     * }
     */
    public static final OfInt compose$layout() {
        return compose$LAYOUT;
    }

    private static final long compose$OFFSET = 252;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * CompositeOperator compose
     * }
     */
    public static final long compose$offset() {
        return compose$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * CompositeOperator compose
     * }
     */
    public static int compose(MemorySegment struct) {
        return struct.get(compose$LAYOUT, compose$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * CompositeOperator compose
     * }
     */
    public static void compose(MemorySegment struct, int fieldValue) {
        struct.set(compose$LAYOUT, compose$OFFSET, fieldValue);
    }

    private static final AddressLayout text$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("text"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *text
     * }
     */
    public static final AddressLayout text$layout() {
        return text$LAYOUT;
    }

    private static final long text$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *text
     * }
     */
    public static final long text$offset() {
        return text$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *text
     * }
     */
    public static MemorySegment text(MemorySegment struct) {
        return struct.get(text$LAYOUT, text$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *text
     * }
     */
    public static void text(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(text$LAYOUT, text$OFFSET, fieldValue);
    }

    private static final AddressLayout font$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("font"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *font
     * }
     */
    public static final AddressLayout font$layout() {
        return font$LAYOUT;
    }

    private static final long font$OFFSET = 264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *font
     * }
     */
    public static final long font$offset() {
        return font$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *font
     * }
     */
    public static MemorySegment font(MemorySegment struct) {
        return struct.get(font$LAYOUT, font$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *font
     * }
     */
    public static void font(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(font$LAYOUT, font$OFFSET, fieldValue);
    }

    private static final AddressLayout family$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("family"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *family
     * }
     */
    public static final AddressLayout family$layout() {
        return family$LAYOUT;
    }

    private static final long family$OFFSET = 272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *family
     * }
     */
    public static final long family$offset() {
        return family$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *family
     * }
     */
    public static MemorySegment family(MemorySegment struct) {
        return struct.get(family$LAYOUT, family$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *family
     * }
     */
    public static void family(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(family$LAYOUT, family$OFFSET, fieldValue);
    }

    private static final OfInt style$LAYOUT = (OfInt)$LAYOUT.select(groupElement("style"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * StyleType style
     * }
     */
    public static final OfInt style$layout() {
        return style$LAYOUT;
    }

    private static final long style$OFFSET = 280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * StyleType style
     * }
     */
    public static final long style$offset() {
        return style$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * StyleType style
     * }
     */
    public static int style(MemorySegment struct) {
        return struct.get(style$LAYOUT, style$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * StyleType style
     * }
     */
    public static void style(MemorySegment struct, int fieldValue) {
        struct.set(style$LAYOUT, style$OFFSET, fieldValue);
    }

    private static final OfInt stretch$LAYOUT = (OfInt)$LAYOUT.select(groupElement("stretch"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * StretchType stretch
     * }
     */
    public static final OfInt stretch$layout() {
        return stretch$LAYOUT;
    }

    private static final long stretch$OFFSET = 284;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * StretchType stretch
     * }
     */
    public static final long stretch$offset() {
        return stretch$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * StretchType stretch
     * }
     */
    public static int stretch(MemorySegment struct) {
        return struct.get(stretch$LAYOUT, stretch$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * StretchType stretch
     * }
     */
    public static void stretch(MemorySegment struct, int fieldValue) {
        struct.set(stretch$LAYOUT, stretch$OFFSET, fieldValue);
    }

    private static final OfLong weight$LAYOUT = (OfLong)$LAYOUT.select(groupElement("weight"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned long weight
     * }
     */
    public static final OfLong weight$layout() {
        return weight$LAYOUT;
    }

    private static final long weight$OFFSET = 288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned long weight
     * }
     */
    public static final long weight$offset() {
        return weight$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned long weight
     * }
     */
    public static long weight(MemorySegment struct) {
        return struct.get(weight$LAYOUT, weight$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned long weight
     * }
     */
    public static void weight(MemorySegment struct, long fieldValue) {
        struct.set(weight$LAYOUT, weight$OFFSET, fieldValue);
    }

    private static final AddressLayout encoding$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("encoding"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *encoding
     * }
     */
    public static final AddressLayout encoding$layout() {
        return encoding$LAYOUT;
    }

    private static final long encoding$OFFSET = 296;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *encoding
     * }
     */
    public static final long encoding$offset() {
        return encoding$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *encoding
     * }
     */
    public static MemorySegment encoding(MemorySegment struct) {
        return struct.get(encoding$LAYOUT, encoding$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *encoding
     * }
     */
    public static void encoding(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(encoding$LAYOUT, encoding$OFFSET, fieldValue);
    }

    private static final OfDouble pointsize$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("pointsize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double pointsize
     * }
     */
    public static final OfDouble pointsize$layout() {
        return pointsize$LAYOUT;
    }

    private static final long pointsize$OFFSET = 304;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double pointsize
     * }
     */
    public static final long pointsize$offset() {
        return pointsize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double pointsize
     * }
     */
    public static double pointsize(MemorySegment struct) {
        return struct.get(pointsize$LAYOUT, pointsize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double pointsize
     * }
     */
    public static void pointsize(MemorySegment struct, double fieldValue) {
        struct.set(pointsize$LAYOUT, pointsize$OFFSET, fieldValue);
    }

    private static final AddressLayout density$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("density"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *density
     * }
     */
    public static final AddressLayout density$layout() {
        return density$LAYOUT;
    }

    private static final long density$OFFSET = 312;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *density
     * }
     */
    public static final long density$offset() {
        return density$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *density
     * }
     */
    public static MemorySegment density(MemorySegment struct) {
        return struct.get(density$LAYOUT, density$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *density
     * }
     */
    public static void density(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(density$LAYOUT, density$OFFSET, fieldValue);
    }

    private static final OfInt align$LAYOUT = (OfInt)$LAYOUT.select(groupElement("align"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AlignType align
     * }
     */
    public static final OfInt align$layout() {
        return align$LAYOUT;
    }

    private static final long align$OFFSET = 320;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AlignType align
     * }
     */
    public static final long align$offset() {
        return align$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AlignType align
     * }
     */
    public static int align(MemorySegment struct) {
        return struct.get(align$LAYOUT, align$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AlignType align
     * }
     */
    public static void align(MemorySegment struct, int fieldValue) {
        struct.set(align$LAYOUT, align$OFFSET, fieldValue);
    }

    private static final GroupLayout undercolor$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("undercolor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * PixelPacket undercolor
     * }
     */
    public static final GroupLayout undercolor$layout() {
        return undercolor$LAYOUT;
    }

    private static final long undercolor$OFFSET = 324;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * PixelPacket undercolor
     * }
     */
    public static final long undercolor$offset() {
        return undercolor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * PixelPacket undercolor
     * }
     */
    public static MemorySegment undercolor(MemorySegment struct) {
        return struct.asSlice(undercolor$OFFSET, undercolor$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * PixelPacket undercolor
     * }
     */
    public static void undercolor(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, undercolor$OFFSET, undercolor$LAYOUT.byteSize());
    }

    private static final GroupLayout border_color$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("border_color"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * PixelPacket border_color
     * }
     */
    public static final GroupLayout border_color$layout() {
        return border_color$LAYOUT;
    }

    private static final long border_color$OFFSET = 332;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * PixelPacket border_color
     * }
     */
    public static final long border_color$offset() {
        return border_color$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * PixelPacket border_color
     * }
     */
    public static MemorySegment border_color(MemorySegment struct) {
        return struct.asSlice(border_color$OFFSET, border_color$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * PixelPacket border_color
     * }
     */
    public static void border_color(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, border_color$OFFSET, border_color$LAYOUT.byteSize());
    }

    private static final AddressLayout server_name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("server_name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *server_name
     * }
     */
    public static final AddressLayout server_name$layout() {
        return server_name$LAYOUT;
    }

    private static final long server_name$OFFSET = 344;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *server_name
     * }
     */
    public static final long server_name$offset() {
        return server_name$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *server_name
     * }
     */
    public static MemorySegment server_name(MemorySegment struct) {
        return struct.get(server_name$LAYOUT, server_name$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *server_name
     * }
     */
    public static void server_name(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(server_name$LAYOUT, server_name$OFFSET, fieldValue);
    }

    private static final AddressLayout dash_pattern$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("dash_pattern"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double *dash_pattern
     * }
     */
    public static final AddressLayout dash_pattern$layout() {
        return dash_pattern$LAYOUT;
    }

    private static final long dash_pattern$OFFSET = 352;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double *dash_pattern
     * }
     */
    public static final long dash_pattern$offset() {
        return dash_pattern$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double *dash_pattern
     * }
     */
    public static MemorySegment dash_pattern(MemorySegment struct) {
        return struct.get(dash_pattern$LAYOUT, dash_pattern$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double *dash_pattern
     * }
     */
    public static void dash_pattern(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(dash_pattern$LAYOUT, dash_pattern$OFFSET, fieldValue);
    }

    private static final AddressLayout extra$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("extra"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct _DrawInfoExtra *extra
     * }
     */
    public static final AddressLayout extra$layout() {
        return extra$LAYOUT;
    }

    private static final long extra$OFFSET = 360;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct _DrawInfoExtra *extra
     * }
     */
    public static final long extra$offset() {
        return extra$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct _DrawInfoExtra *extra
     * }
     */
    public static MemorySegment extra(MemorySegment struct) {
        return struct.get(extra$LAYOUT, extra$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct _DrawInfoExtra *extra
     * }
     */
    public static void extra(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(extra$LAYOUT, extra$OFFSET, fieldValue);
    }

    private static final GroupLayout bounds$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("bounds"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * SegmentInfo bounds
     * }
     */
    public static final GroupLayout bounds$layout() {
        return bounds$LAYOUT;
    }

    private static final long bounds$OFFSET = 368;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * SegmentInfo bounds
     * }
     */
    public static final long bounds$offset() {
        return bounds$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * SegmentInfo bounds
     * }
     */
    public static MemorySegment bounds(MemorySegment struct) {
        return struct.asSlice(bounds$OFFSET, bounds$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * SegmentInfo bounds
     * }
     */
    public static void bounds(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, bounds$OFFSET, bounds$LAYOUT.byteSize());
    }

    private static final OfInt clip_units$LAYOUT = (OfInt)$LAYOUT.select(groupElement("clip_units"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ClipPathUnits clip_units
     * }
     */
    public static final OfInt clip_units$layout() {
        return clip_units$LAYOUT;
    }

    private static final long clip_units$OFFSET = 400;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ClipPathUnits clip_units
     * }
     */
    public static final long clip_units$offset() {
        return clip_units$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ClipPathUnits clip_units
     * }
     */
    public static int clip_units(MemorySegment struct) {
        return struct.get(clip_units$LAYOUT, clip_units$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ClipPathUnits clip_units
     * }
     */
    public static void clip_units(MemorySegment struct, int fieldValue) {
        struct.set(clip_units$LAYOUT, clip_units$OFFSET, fieldValue);
    }

    private static final OfShort opacity$LAYOUT = (OfShort)$LAYOUT.select(groupElement("opacity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * Quantum opacity
     * }
     */
    public static final OfShort opacity$layout() {
        return opacity$LAYOUT;
    }

    private static final long opacity$OFFSET = 404;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * Quantum opacity
     * }
     */
    public static final long opacity$offset() {
        return opacity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * Quantum opacity
     * }
     */
    public static short opacity(MemorySegment struct) {
        return struct.get(opacity$LAYOUT, opacity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * Quantum opacity
     * }
     */
    public static void opacity(MemorySegment struct, short fieldValue) {
        struct.set(opacity$LAYOUT, opacity$OFFSET, fieldValue);
    }

    private static final OfInt render$LAYOUT = (OfInt)$LAYOUT.select(groupElement("render"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int render
     * }
     */
    public static final OfInt render$layout() {
        return render$LAYOUT;
    }

    private static final long render$OFFSET = 408;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int render
     * }
     */
    public static final long render$offset() {
        return render$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int render
     * }
     */
    public static int render(MemorySegment struct) {
        return struct.get(render$LAYOUT, render$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int render
     * }
     */
    public static void render(MemorySegment struct, int fieldValue) {
        struct.set(render$LAYOUT, render$OFFSET, fieldValue);
    }

    private static final OfInt flags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int flags
     * }
     */
    public static final OfInt flags$layout() {
        return flags$LAYOUT;
    }

    private static final long flags$OFFSET = 412;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int flags
     * }
     */
    public static final long flags$offset() {
        return flags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int flags
     * }
     */
    public static int flags(MemorySegment struct) {
        return struct.get(flags$LAYOUT, flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int flags
     * }
     */
    public static void flags(MemorySegment struct, int fieldValue) {
        struct.set(flags$LAYOUT, flags$OFFSET, fieldValue);
    }

    private static final GroupLayout element_reference$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("element_reference"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ElementReference element_reference
     * }
     */
    public static final GroupLayout element_reference$layout() {
        return element_reference$LAYOUT;
    }

    private static final long element_reference$OFFSET = 416;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ElementReference element_reference
     * }
     */
    public static final long element_reference$offset() {
        return element_reference$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ElementReference element_reference
     * }
     */
    public static MemorySegment element_reference(MemorySegment struct) {
        return struct.asSlice(element_reference$OFFSET, element_reference$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ElementReference element_reference
     * }
     */
    public static void element_reference(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, element_reference$OFFSET, element_reference$LAYOUT.byteSize());
    }

    private static final OfLong signature$LAYOUT = (OfLong)$LAYOUT.select(groupElement("signature"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned long signature
     * }
     */
    public static final OfLong signature$layout() {
        return signature$LAYOUT;
    }

    private static final long signature$OFFSET = 544;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned long signature
     * }
     */
    public static final long signature$offset() {
        return signature$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned long signature
     * }
     */
    public static long signature(MemorySegment struct) {
        return struct.get(signature$LAYOUT, signature$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned long signature
     * }
     */
    public static void signature(MemorySegment struct, long fieldValue) {
        struct.set(signature$LAYOUT, signature$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

