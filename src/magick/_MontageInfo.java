// Generated by jextract

package magick;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _MontageInfo {
 *     char *geometry;
 *     char *tile;
 *     char *title;
 *     char *frame;
 *     char *texture;
 *     char *font;
 *     double pointsize;
 *     unsigned long border_width;
 *     unsigned int shadow;
 *     PixelPacket fill;
 *     PixelPacket stroke;
 *     PixelPacket background_color;
 *     PixelPacket border_color;
 *     PixelPacket matte_color;
 *     GravityType gravity;
 *     char filename[2053];
 *     unsigned long signature;
 * }
 * }
 */
public class _MontageInfo {

    _MontageInfo() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        magick_wand_h.C_POINTER.withName("geometry"),
        magick_wand_h.C_POINTER.withName("tile"),
        magick_wand_h.C_POINTER.withName("title"),
        magick_wand_h.C_POINTER.withName("frame"),
        magick_wand_h.C_POINTER.withName("texture"),
        magick_wand_h.C_POINTER.withName("font"),
        magick_wand_h.C_DOUBLE.withName("pointsize"),
        magick_wand_h.C_LONG.withName("border_width"),
        magick_wand_h.C_INT.withName("shadow"),
        _PixelPacket.layout().withName("fill"),
        _PixelPacket.layout().withName("stroke"),
        _PixelPacket.layout().withName("background_color"),
        _PixelPacket.layout().withName("border_color"),
        _PixelPacket.layout().withName("matte_color"),
        magick_wand_h.C_INT.withName("gravity"),
        MemoryLayout.sequenceLayout(2053, magick_wand_h.C_CHAR).withName("filename"),
        MemoryLayout.paddingLayout(3),
        magick_wand_h.C_LONG.withName("signature")
    ).withName("_MontageInfo");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout geometry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("geometry"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *geometry
     * }
     */
    public static final AddressLayout geometry$layout() {
        return geometry$LAYOUT;
    }

    private static final long geometry$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *geometry
     * }
     */
    public static final long geometry$offset() {
        return geometry$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *geometry
     * }
     */
    public static MemorySegment geometry(MemorySegment struct) {
        return struct.get(geometry$LAYOUT, geometry$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *geometry
     * }
     */
    public static void geometry(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(geometry$LAYOUT, geometry$OFFSET, fieldValue);
    }

    private static final AddressLayout tile$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("tile"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *tile
     * }
     */
    public static final AddressLayout tile$layout() {
        return tile$LAYOUT;
    }

    private static final long tile$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *tile
     * }
     */
    public static final long tile$offset() {
        return tile$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *tile
     * }
     */
    public static MemorySegment tile(MemorySegment struct) {
        return struct.get(tile$LAYOUT, tile$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *tile
     * }
     */
    public static void tile(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(tile$LAYOUT, tile$OFFSET, fieldValue);
    }

    private static final AddressLayout title$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("title"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *title
     * }
     */
    public static final AddressLayout title$layout() {
        return title$LAYOUT;
    }

    private static final long title$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *title
     * }
     */
    public static final long title$offset() {
        return title$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *title
     * }
     */
    public static MemorySegment title(MemorySegment struct) {
        return struct.get(title$LAYOUT, title$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *title
     * }
     */
    public static void title(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(title$LAYOUT, title$OFFSET, fieldValue);
    }

    private static final AddressLayout frame$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("frame"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *frame
     * }
     */
    public static final AddressLayout frame$layout() {
        return frame$LAYOUT;
    }

    private static final long frame$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *frame
     * }
     */
    public static final long frame$offset() {
        return frame$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *frame
     * }
     */
    public static MemorySegment frame(MemorySegment struct) {
        return struct.get(frame$LAYOUT, frame$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *frame
     * }
     */
    public static void frame(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(frame$LAYOUT, frame$OFFSET, fieldValue);
    }

    private static final AddressLayout texture$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("texture"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *texture
     * }
     */
    public static final AddressLayout texture$layout() {
        return texture$LAYOUT;
    }

    private static final long texture$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *texture
     * }
     */
    public static final long texture$offset() {
        return texture$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *texture
     * }
     */
    public static MemorySegment texture(MemorySegment struct) {
        return struct.get(texture$LAYOUT, texture$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *texture
     * }
     */
    public static void texture(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(texture$LAYOUT, texture$OFFSET, fieldValue);
    }

    private static final AddressLayout font$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("font"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *font
     * }
     */
    public static final AddressLayout font$layout() {
        return font$LAYOUT;
    }

    private static final long font$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *font
     * }
     */
    public static final long font$offset() {
        return font$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *font
     * }
     */
    public static MemorySegment font(MemorySegment struct) {
        return struct.get(font$LAYOUT, font$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *font
     * }
     */
    public static void font(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(font$LAYOUT, font$OFFSET, fieldValue);
    }

    private static final OfDouble pointsize$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("pointsize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double pointsize
     * }
     */
    public static final OfDouble pointsize$layout() {
        return pointsize$LAYOUT;
    }

    private static final long pointsize$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double pointsize
     * }
     */
    public static final long pointsize$offset() {
        return pointsize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double pointsize
     * }
     */
    public static double pointsize(MemorySegment struct) {
        return struct.get(pointsize$LAYOUT, pointsize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double pointsize
     * }
     */
    public static void pointsize(MemorySegment struct, double fieldValue) {
        struct.set(pointsize$LAYOUT, pointsize$OFFSET, fieldValue);
    }

    private static final OfLong border_width$LAYOUT = (OfLong)$LAYOUT.select(groupElement("border_width"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned long border_width
     * }
     */
    public static final OfLong border_width$layout() {
        return border_width$LAYOUT;
    }

    private static final long border_width$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned long border_width
     * }
     */
    public static final long border_width$offset() {
        return border_width$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned long border_width
     * }
     */
    public static long border_width(MemorySegment struct) {
        return struct.get(border_width$LAYOUT, border_width$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned long border_width
     * }
     */
    public static void border_width(MemorySegment struct, long fieldValue) {
        struct.set(border_width$LAYOUT, border_width$OFFSET, fieldValue);
    }

    private static final OfInt shadow$LAYOUT = (OfInt)$LAYOUT.select(groupElement("shadow"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int shadow
     * }
     */
    public static final OfInt shadow$layout() {
        return shadow$LAYOUT;
    }

    private static final long shadow$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int shadow
     * }
     */
    public static final long shadow$offset() {
        return shadow$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int shadow
     * }
     */
    public static int shadow(MemorySegment struct) {
        return struct.get(shadow$LAYOUT, shadow$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int shadow
     * }
     */
    public static void shadow(MemorySegment struct, int fieldValue) {
        struct.set(shadow$LAYOUT, shadow$OFFSET, fieldValue);
    }

    private static final GroupLayout fill$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("fill"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * PixelPacket fill
     * }
     */
    public static final GroupLayout fill$layout() {
        return fill$LAYOUT;
    }

    private static final long fill$OFFSET = 68;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * PixelPacket fill
     * }
     */
    public static final long fill$offset() {
        return fill$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * PixelPacket fill
     * }
     */
    public static MemorySegment fill(MemorySegment struct) {
        return struct.asSlice(fill$OFFSET, fill$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * PixelPacket fill
     * }
     */
    public static void fill(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, fill$OFFSET, fill$LAYOUT.byteSize());
    }

    private static final GroupLayout stroke$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("stroke"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * PixelPacket stroke
     * }
     */
    public static final GroupLayout stroke$layout() {
        return stroke$LAYOUT;
    }

    private static final long stroke$OFFSET = 76;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * PixelPacket stroke
     * }
     */
    public static final long stroke$offset() {
        return stroke$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * PixelPacket stroke
     * }
     */
    public static MemorySegment stroke(MemorySegment struct) {
        return struct.asSlice(stroke$OFFSET, stroke$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * PixelPacket stroke
     * }
     */
    public static void stroke(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, stroke$OFFSET, stroke$LAYOUT.byteSize());
    }

    private static final GroupLayout background_color$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("background_color"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * PixelPacket background_color
     * }
     */
    public static final GroupLayout background_color$layout() {
        return background_color$LAYOUT;
    }

    private static final long background_color$OFFSET = 84;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * PixelPacket background_color
     * }
     */
    public static final long background_color$offset() {
        return background_color$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * PixelPacket background_color
     * }
     */
    public static MemorySegment background_color(MemorySegment struct) {
        return struct.asSlice(background_color$OFFSET, background_color$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * PixelPacket background_color
     * }
     */
    public static void background_color(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, background_color$OFFSET, background_color$LAYOUT.byteSize());
    }

    private static final GroupLayout border_color$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("border_color"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * PixelPacket border_color
     * }
     */
    public static final GroupLayout border_color$layout() {
        return border_color$LAYOUT;
    }

    private static final long border_color$OFFSET = 92;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * PixelPacket border_color
     * }
     */
    public static final long border_color$offset() {
        return border_color$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * PixelPacket border_color
     * }
     */
    public static MemorySegment border_color(MemorySegment struct) {
        return struct.asSlice(border_color$OFFSET, border_color$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * PixelPacket border_color
     * }
     */
    public static void border_color(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, border_color$OFFSET, border_color$LAYOUT.byteSize());
    }

    private static final GroupLayout matte_color$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("matte_color"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * PixelPacket matte_color
     * }
     */
    public static final GroupLayout matte_color$layout() {
        return matte_color$LAYOUT;
    }

    private static final long matte_color$OFFSET = 100;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * PixelPacket matte_color
     * }
     */
    public static final long matte_color$offset() {
        return matte_color$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * PixelPacket matte_color
     * }
     */
    public static MemorySegment matte_color(MemorySegment struct) {
        return struct.asSlice(matte_color$OFFSET, matte_color$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * PixelPacket matte_color
     * }
     */
    public static void matte_color(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, matte_color$OFFSET, matte_color$LAYOUT.byteSize());
    }

    private static final OfInt gravity$LAYOUT = (OfInt)$LAYOUT.select(groupElement("gravity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GravityType gravity
     * }
     */
    public static final OfInt gravity$layout() {
        return gravity$LAYOUT;
    }

    private static final long gravity$OFFSET = 108;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GravityType gravity
     * }
     */
    public static final long gravity$offset() {
        return gravity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GravityType gravity
     * }
     */
    public static int gravity(MemorySegment struct) {
        return struct.get(gravity$LAYOUT, gravity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GravityType gravity
     * }
     */
    public static void gravity(MemorySegment struct, int fieldValue) {
        struct.set(gravity$LAYOUT, gravity$OFFSET, fieldValue);
    }

    private static final SequenceLayout filename$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("filename"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char filename[2053]
     * }
     */
    public static final SequenceLayout filename$layout() {
        return filename$LAYOUT;
    }

    private static final long filename$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char filename[2053]
     * }
     */
    public static final long filename$offset() {
        return filename$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char filename[2053]
     * }
     */
    public static MemorySegment filename(MemorySegment struct) {
        return struct.asSlice(filename$OFFSET, filename$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char filename[2053]
     * }
     */
    public static void filename(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, filename$OFFSET, filename$LAYOUT.byteSize());
    }

    private static long[] filename$DIMS = { 2053 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char filename[2053]
     * }
     */
    public static long[] filename$dimensions() {
        return filename$DIMS;
    }
    private static final VarHandle filename$ELEM_HANDLE = filename$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char filename[2053]
     * }
     */
    public static byte filename(MemorySegment struct, long index0) {
        return (byte)filename$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char filename[2053]
     * }
     */
    public static void filename(MemorySegment struct, long index0, byte fieldValue) {
        filename$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfLong signature$LAYOUT = (OfLong)$LAYOUT.select(groupElement("signature"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned long signature
     * }
     */
    public static final OfLong signature$layout() {
        return signature$LAYOUT;
    }

    private static final long signature$OFFSET = 2168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned long signature
     * }
     */
    public static final long signature$offset() {
        return signature$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned long signature
     * }
     */
    public static long signature(MemorySegment struct) {
        return struct.get(signature$LAYOUT, signature$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned long signature
     * }
     */
    public static void signature(MemorySegment struct, long fieldValue) {
        struct.set(signature$LAYOUT, signature$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

