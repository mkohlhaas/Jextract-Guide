// Generated by jextract

package magick;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class magick_wand_h_1 extends magick_wand_h_2 {

    magick_wand_h_1() {
        // Should not be called directly
    }

    private static class ImageToBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ImageToBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *ImageToBlob(const ImageInfo *image_info, Image *image, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ImageToBlob$descriptor() {
        return ImageToBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *ImageToBlob(const ImageInfo *image_info, Image *image, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ImageToBlob$handle() {
        return ImageToBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *ImageToBlob(const ImageInfo *image_info, Image *image, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ImageToBlob$address() {
        return ImageToBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *ImageToBlob(const ImageInfo *image_info, Image *image, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ImageToBlob(MemorySegment image_info, MemorySegment image, MemorySegment length, MemorySegment exception) {
        var mh$ = ImageToBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageToBlob", image_info, image, length, exception);
            }
            return (MemorySegment)mh$.invokeExact(image_info, image, length, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UndefinedBlobMode = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedBlobMode = 0
     * }
     */
    public static int UndefinedBlobMode() {
        return UndefinedBlobMode;
    }
    private static final int ReadBlobMode = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ReadBlobMode = 1
     * }
     */
    public static int ReadBlobMode() {
        return ReadBlobMode;
    }
    private static final int ReadBinaryBlobMode = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ReadBinaryBlobMode = 2
     * }
     */
    public static int ReadBinaryBlobMode() {
        return ReadBinaryBlobMode;
    }
    private static final int WriteBlobMode = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WriteBlobMode = 3
     * }
     */
    public static int WriteBlobMode() {
        return WriteBlobMode;
    }
    private static final int WriteBinaryBlobMode = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WriteBinaryBlobMode = 4
     * }
     */
    public static int WriteBinaryBlobMode() {
        return WriteBinaryBlobMode;
    }

    private static class OpenBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("OpenBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int OpenBlob(const ImageInfo *image_info, Image *image, const BlobMode mode, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor OpenBlob$descriptor() {
        return OpenBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int OpenBlob(const ImageInfo *image_info, Image *image, const BlobMode mode, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle OpenBlob$handle() {
        return OpenBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int OpenBlob(const ImageInfo *image_info, Image *image, const BlobMode mode, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment OpenBlob$address() {
        return OpenBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int OpenBlob(const ImageInfo *image_info, Image *image, const BlobMode mode, ExceptionInfo *exception)
     * }
     */
    public static int OpenBlob(MemorySegment image_info, MemorySegment image, int mode, MemorySegment exception) {
        var mh$ = OpenBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenBlob", image_info, image, mode, exception);
            }
            return (int)mh$.invokeExact(image_info, image, mode, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CloseBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int CloseBlob(Image *image)
     * }
     */
    public static FunctionDescriptor CloseBlob$descriptor() {
        return CloseBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int CloseBlob(Image *image)
     * }
     */
    public static MethodHandle CloseBlob$handle() {
        return CloseBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int CloseBlob(Image *image)
     * }
     */
    public static MemorySegment CloseBlob$address() {
        return CloseBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int CloseBlob(Image *image)
     * }
     */
    public static int CloseBlob(MemorySegment image) {
        var mh$ = CloseBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseBlob", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ReadBlob(Image *image, const size_t length, void *data)
     * }
     */
    public static FunctionDescriptor ReadBlob$descriptor() {
        return ReadBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ReadBlob(Image *image, const size_t length, void *data)
     * }
     */
    public static MethodHandle ReadBlob$handle() {
        return ReadBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ReadBlob(Image *image, const size_t length, void *data)
     * }
     */
    public static MemorySegment ReadBlob$address() {
        return ReadBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ReadBlob(Image *image, const size_t length, void *data)
     * }
     */
    public static long ReadBlob(MemorySegment image, long length, MemorySegment data) {
        var mh$ = ReadBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlob", image, length, data);
            }
            return (long)mh$.invokeExact(image, length, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobZC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobZC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ReadBlobZC(Image *image, const size_t length, void **data)
     * }
     */
    public static FunctionDescriptor ReadBlobZC$descriptor() {
        return ReadBlobZC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ReadBlobZC(Image *image, const size_t length, void **data)
     * }
     */
    public static MethodHandle ReadBlobZC$handle() {
        return ReadBlobZC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ReadBlobZC(Image *image, const size_t length, void **data)
     * }
     */
    public static MemorySegment ReadBlobZC$address() {
        return ReadBlobZC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ReadBlobZC(Image *image, const size_t length, void **data)
     * }
     */
    public static long ReadBlobZC(MemorySegment image, long length, MemorySegment data) {
        var mh$ = ReadBlobZC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobZC", image, length, data);
            }
            return (long)mh$.invokeExact(image, length, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WriteBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t WriteBlob(Image *image, const size_t length, const void *data)
     * }
     */
    public static FunctionDescriptor WriteBlob$descriptor() {
        return WriteBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t WriteBlob(Image *image, const size_t length, const void *data)
     * }
     */
    public static MethodHandle WriteBlob$handle() {
        return WriteBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t WriteBlob(Image *image, const size_t length, const void *data)
     * }
     */
    public static MemorySegment WriteBlob$address() {
        return WriteBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t WriteBlob(Image *image, const size_t length, const void *data)
     * }
     */
    public static long WriteBlob(MemorySegment image, long length, MemorySegment data) {
        var mh$ = WriteBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteBlob", image, length, data);
            }
            return (long)mh$.invokeExact(image, length, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SeekBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SeekBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern magick_off_t SeekBlob(Image *image, const magick_off_t offset, const int whence)
     * }
     */
    public static FunctionDescriptor SeekBlob$descriptor() {
        return SeekBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern magick_off_t SeekBlob(Image *image, const magick_off_t offset, const int whence)
     * }
     */
    public static MethodHandle SeekBlob$handle() {
        return SeekBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern magick_off_t SeekBlob(Image *image, const magick_off_t offset, const int whence)
     * }
     */
    public static MemorySegment SeekBlob$address() {
        return SeekBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern magick_off_t SeekBlob(Image *image, const magick_off_t offset, const int whence)
     * }
     */
    public static long SeekBlob(MemorySegment image, long offset, int whence) {
        var mh$ = SeekBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SeekBlob", image, offset, whence);
            }
            return (long)mh$.invokeExact(image, offset, whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TellBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("TellBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern magick_off_t TellBlob(const Image *image)
     * }
     */
    public static FunctionDescriptor TellBlob$descriptor() {
        return TellBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern magick_off_t TellBlob(const Image *image)
     * }
     */
    public static MethodHandle TellBlob$handle() {
        return TellBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern magick_off_t TellBlob(const Image *image)
     * }
     */
    public static MemorySegment TellBlob$address() {
        return TellBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern magick_off_t TellBlob(const Image *image)
     * }
     */
    public static long TellBlob(MemorySegment image) {
        var mh$ = TellBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TellBlob", image);
            }
            return (long)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EOFBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("EOFBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int EOFBlob(const Image *image)
     * }
     */
    public static FunctionDescriptor EOFBlob$descriptor() {
        return EOFBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int EOFBlob(const Image *image)
     * }
     */
    public static MethodHandle EOFBlob$handle() {
        return EOFBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int EOFBlob(const Image *image)
     * }
     */
    public static MemorySegment EOFBlob$address() {
        return EOFBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int EOFBlob(const Image *image)
     * }
     */
    public static int EOFBlob(MemorySegment image) {
        var mh$ = EOFBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EOFBlob", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBlobStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetBlobStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int GetBlobStatus(const Image *image)
     * }
     */
    public static FunctionDescriptor GetBlobStatus$descriptor() {
        return GetBlobStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int GetBlobStatus(const Image *image)
     * }
     */
    public static MethodHandle GetBlobStatus$handle() {
        return GetBlobStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int GetBlobStatus(const Image *image)
     * }
     */
    public static MemorySegment GetBlobStatus$address() {
        return GetBlobStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int GetBlobStatus(const Image *image)
     * }
     */
    public static int GetBlobStatus(MemorySegment image) {
        var mh$ = GetBlobStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBlobStatus", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBlobFirstErrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetBlobFirstErrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int GetBlobFirstErrno(const Image *image)
     * }
     */
    public static FunctionDescriptor GetBlobFirstErrno$descriptor() {
        return GetBlobFirstErrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int GetBlobFirstErrno(const Image *image)
     * }
     */
    public static MethodHandle GetBlobFirstErrno$handle() {
        return GetBlobFirstErrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int GetBlobFirstErrno(const Image *image)
     * }
     */
    public static MemorySegment GetBlobFirstErrno$address() {
        return GetBlobFirstErrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int GetBlobFirstErrno(const Image *image)
     * }
     */
    public static int GetBlobFirstErrno(MemorySegment image) {
        var mh$ = GetBlobFirstErrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBlobFirstErrno", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBlobIsOpen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetBlobIsOpen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int GetBlobIsOpen(const Image *image)
     * }
     */
    public static FunctionDescriptor GetBlobIsOpen$descriptor() {
        return GetBlobIsOpen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int GetBlobIsOpen(const Image *image)
     * }
     */
    public static MethodHandle GetBlobIsOpen$handle() {
        return GetBlobIsOpen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int GetBlobIsOpen(const Image *image)
     * }
     */
    public static MemorySegment GetBlobIsOpen$address() {
        return GetBlobIsOpen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int GetBlobIsOpen(const Image *image)
     * }
     */
    public static int GetBlobIsOpen(MemorySegment image) {
        var mh$ = GetBlobIsOpen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBlobIsOpen", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBlobSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetBlobSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern magick_off_t GetBlobSize(const Image *image)
     * }
     */
    public static FunctionDescriptor GetBlobSize$descriptor() {
        return GetBlobSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern magick_off_t GetBlobSize(const Image *image)
     * }
     */
    public static MethodHandle GetBlobSize$handle() {
        return GetBlobSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern magick_off_t GetBlobSize(const Image *image)
     * }
     */
    public static MemorySegment GetBlobSize$address() {
        return GetBlobSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern magick_off_t GetBlobSize(const Image *image)
     * }
     */
    public static long GetBlobSize(MemorySegment image) {
        var mh$ = GetBlobSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBlobSize", image);
            }
            return (long)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBlobFileHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetBlobFileHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *GetBlobFileHandle(const Image *image)
     * }
     */
    public static FunctionDescriptor GetBlobFileHandle$descriptor() {
        return GetBlobFileHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *GetBlobFileHandle(const Image *image)
     * }
     */
    public static MethodHandle GetBlobFileHandle$handle() {
        return GetBlobFileHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *GetBlobFileHandle(const Image *image)
     * }
     */
    public static MemorySegment GetBlobFileHandle$address() {
        return GetBlobFileHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *GetBlobFileHandle(const Image *image)
     * }
     */
    public static MemorySegment GetBlobFileHandle(MemorySegment image) {
        var mh$ = GetBlobFileHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBlobFileHandle", image);
            }
            return (MemorySegment)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBlobStreamData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetBlobStreamData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned char *GetBlobStreamData(const Image *image)
     * }
     */
    public static FunctionDescriptor GetBlobStreamData$descriptor() {
        return GetBlobStreamData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned char *GetBlobStreamData(const Image *image)
     * }
     */
    public static MethodHandle GetBlobStreamData$handle() {
        return GetBlobStreamData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned char *GetBlobStreamData(const Image *image)
     * }
     */
    public static MemorySegment GetBlobStreamData$address() {
        return GetBlobStreamData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned char *GetBlobStreamData(const Image *image)
     * }
     */
    public static MemorySegment GetBlobStreamData(MemorySegment image) {
        var mh$ = GetBlobStreamData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBlobStreamData", image);
            }
            return (MemorySegment)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobByte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobByte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ReadBlobByte(Image *image)
     * }
     */
    public static FunctionDescriptor ReadBlobByte$descriptor() {
        return ReadBlobByte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ReadBlobByte(Image *image)
     * }
     */
    public static MethodHandle ReadBlobByte$handle() {
        return ReadBlobByte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ReadBlobByte(Image *image)
     * }
     */
    public static MemorySegment ReadBlobByte$address() {
        return ReadBlobByte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ReadBlobByte(Image *image)
     * }
     */
    public static int ReadBlobByte(MemorySegment image) {
        var mh$ = ReadBlobByte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobByte", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobLSBShort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_SHORT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobLSBShort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern magick_uint16_t ReadBlobLSBShort(Image *image)
     * }
     */
    public static FunctionDescriptor ReadBlobLSBShort$descriptor() {
        return ReadBlobLSBShort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern magick_uint16_t ReadBlobLSBShort(Image *image)
     * }
     */
    public static MethodHandle ReadBlobLSBShort$handle() {
        return ReadBlobLSBShort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern magick_uint16_t ReadBlobLSBShort(Image *image)
     * }
     */
    public static MemorySegment ReadBlobLSBShort$address() {
        return ReadBlobLSBShort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern magick_uint16_t ReadBlobLSBShort(Image *image)
     * }
     */
    public static short ReadBlobLSBShort(MemorySegment image) {
        var mh$ = ReadBlobLSBShort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobLSBShort", image);
            }
            return (short)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobLSBSignedShort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_SHORT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobLSBSignedShort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern magick_int16_t ReadBlobLSBSignedShort(Image *image)
     * }
     */
    public static FunctionDescriptor ReadBlobLSBSignedShort$descriptor() {
        return ReadBlobLSBSignedShort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern magick_int16_t ReadBlobLSBSignedShort(Image *image)
     * }
     */
    public static MethodHandle ReadBlobLSBSignedShort$handle() {
        return ReadBlobLSBSignedShort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern magick_int16_t ReadBlobLSBSignedShort(Image *image)
     * }
     */
    public static MemorySegment ReadBlobLSBSignedShort$address() {
        return ReadBlobLSBSignedShort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern magick_int16_t ReadBlobLSBSignedShort(Image *image)
     * }
     */
    public static short ReadBlobLSBSignedShort(MemorySegment image) {
        var mh$ = ReadBlobLSBSignedShort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobLSBSignedShort", image);
            }
            return (short)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobLSBShorts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobLSBShorts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ReadBlobLSBShorts(Image *image, size_t octets, magick_uint16_t *data)
     * }
     */
    public static FunctionDescriptor ReadBlobLSBShorts$descriptor() {
        return ReadBlobLSBShorts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ReadBlobLSBShorts(Image *image, size_t octets, magick_uint16_t *data)
     * }
     */
    public static MethodHandle ReadBlobLSBShorts$handle() {
        return ReadBlobLSBShorts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ReadBlobLSBShorts(Image *image, size_t octets, magick_uint16_t *data)
     * }
     */
    public static MemorySegment ReadBlobLSBShorts$address() {
        return ReadBlobLSBShorts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ReadBlobLSBShorts(Image *image, size_t octets, magick_uint16_t *data)
     * }
     */
    public static long ReadBlobLSBShorts(MemorySegment image, long octets, MemorySegment data) {
        var mh$ = ReadBlobLSBShorts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobLSBShorts", image, octets, data);
            }
            return (long)mh$.invokeExact(image, octets, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobMSBShort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_SHORT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobMSBShort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern magick_uint16_t ReadBlobMSBShort(Image *image)
     * }
     */
    public static FunctionDescriptor ReadBlobMSBShort$descriptor() {
        return ReadBlobMSBShort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern magick_uint16_t ReadBlobMSBShort(Image *image)
     * }
     */
    public static MethodHandle ReadBlobMSBShort$handle() {
        return ReadBlobMSBShort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern magick_uint16_t ReadBlobMSBShort(Image *image)
     * }
     */
    public static MemorySegment ReadBlobMSBShort$address() {
        return ReadBlobMSBShort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern magick_uint16_t ReadBlobMSBShort(Image *image)
     * }
     */
    public static short ReadBlobMSBShort(MemorySegment image) {
        var mh$ = ReadBlobMSBShort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobMSBShort", image);
            }
            return (short)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobMSBSignedShort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_SHORT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobMSBSignedShort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern magick_int16_t ReadBlobMSBSignedShort(Image *image)
     * }
     */
    public static FunctionDescriptor ReadBlobMSBSignedShort$descriptor() {
        return ReadBlobMSBSignedShort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern magick_int16_t ReadBlobMSBSignedShort(Image *image)
     * }
     */
    public static MethodHandle ReadBlobMSBSignedShort$handle() {
        return ReadBlobMSBSignedShort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern magick_int16_t ReadBlobMSBSignedShort(Image *image)
     * }
     */
    public static MemorySegment ReadBlobMSBSignedShort$address() {
        return ReadBlobMSBSignedShort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern magick_int16_t ReadBlobMSBSignedShort(Image *image)
     * }
     */
    public static short ReadBlobMSBSignedShort(MemorySegment image) {
        var mh$ = ReadBlobMSBSignedShort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobMSBSignedShort", image);
            }
            return (short)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobMSBShorts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobMSBShorts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ReadBlobMSBShorts(Image *image, size_t octets, magick_uint16_t *data)
     * }
     */
    public static FunctionDescriptor ReadBlobMSBShorts$descriptor() {
        return ReadBlobMSBShorts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ReadBlobMSBShorts(Image *image, size_t octets, magick_uint16_t *data)
     * }
     */
    public static MethodHandle ReadBlobMSBShorts$handle() {
        return ReadBlobMSBShorts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ReadBlobMSBShorts(Image *image, size_t octets, magick_uint16_t *data)
     * }
     */
    public static MemorySegment ReadBlobMSBShorts$address() {
        return ReadBlobMSBShorts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ReadBlobMSBShorts(Image *image, size_t octets, magick_uint16_t *data)
     * }
     */
    public static long ReadBlobMSBShorts(MemorySegment image, long octets, MemorySegment data) {
        var mh$ = ReadBlobMSBShorts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobMSBShorts", image, octets, data);
            }
            return (long)mh$.invokeExact(image, octets, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobLSBLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobLSBLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern magick_uint32_t ReadBlobLSBLong(Image *image)
     * }
     */
    public static FunctionDescriptor ReadBlobLSBLong$descriptor() {
        return ReadBlobLSBLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern magick_uint32_t ReadBlobLSBLong(Image *image)
     * }
     */
    public static MethodHandle ReadBlobLSBLong$handle() {
        return ReadBlobLSBLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern magick_uint32_t ReadBlobLSBLong(Image *image)
     * }
     */
    public static MemorySegment ReadBlobLSBLong$address() {
        return ReadBlobLSBLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern magick_uint32_t ReadBlobLSBLong(Image *image)
     * }
     */
    public static int ReadBlobLSBLong(MemorySegment image) {
        var mh$ = ReadBlobLSBLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobLSBLong", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobLSBSignedLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobLSBSignedLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern magick_int32_t ReadBlobLSBSignedLong(Image *image)
     * }
     */
    public static FunctionDescriptor ReadBlobLSBSignedLong$descriptor() {
        return ReadBlobLSBSignedLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern magick_int32_t ReadBlobLSBSignedLong(Image *image)
     * }
     */
    public static MethodHandle ReadBlobLSBSignedLong$handle() {
        return ReadBlobLSBSignedLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern magick_int32_t ReadBlobLSBSignedLong(Image *image)
     * }
     */
    public static MemorySegment ReadBlobLSBSignedLong$address() {
        return ReadBlobLSBSignedLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern magick_int32_t ReadBlobLSBSignedLong(Image *image)
     * }
     */
    public static int ReadBlobLSBSignedLong(MemorySegment image) {
        var mh$ = ReadBlobLSBSignedLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobLSBSignedLong", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobLSBLongs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobLSBLongs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ReadBlobLSBLongs(Image *image, size_t octets, magick_uint32_t *data)
     * }
     */
    public static FunctionDescriptor ReadBlobLSBLongs$descriptor() {
        return ReadBlobLSBLongs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ReadBlobLSBLongs(Image *image, size_t octets, magick_uint32_t *data)
     * }
     */
    public static MethodHandle ReadBlobLSBLongs$handle() {
        return ReadBlobLSBLongs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ReadBlobLSBLongs(Image *image, size_t octets, magick_uint32_t *data)
     * }
     */
    public static MemorySegment ReadBlobLSBLongs$address() {
        return ReadBlobLSBLongs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ReadBlobLSBLongs(Image *image, size_t octets, magick_uint32_t *data)
     * }
     */
    public static long ReadBlobLSBLongs(MemorySegment image, long octets, MemorySegment data) {
        var mh$ = ReadBlobLSBLongs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobLSBLongs", image, octets, data);
            }
            return (long)mh$.invokeExact(image, octets, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobMSBLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobMSBLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern magick_uint32_t ReadBlobMSBLong(Image *image)
     * }
     */
    public static FunctionDescriptor ReadBlobMSBLong$descriptor() {
        return ReadBlobMSBLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern magick_uint32_t ReadBlobMSBLong(Image *image)
     * }
     */
    public static MethodHandle ReadBlobMSBLong$handle() {
        return ReadBlobMSBLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern magick_uint32_t ReadBlobMSBLong(Image *image)
     * }
     */
    public static MemorySegment ReadBlobMSBLong$address() {
        return ReadBlobMSBLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern magick_uint32_t ReadBlobMSBLong(Image *image)
     * }
     */
    public static int ReadBlobMSBLong(MemorySegment image) {
        var mh$ = ReadBlobMSBLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobMSBLong", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobMSBSignedLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobMSBSignedLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern magick_int32_t ReadBlobMSBSignedLong(Image *image)
     * }
     */
    public static FunctionDescriptor ReadBlobMSBSignedLong$descriptor() {
        return ReadBlobMSBSignedLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern magick_int32_t ReadBlobMSBSignedLong(Image *image)
     * }
     */
    public static MethodHandle ReadBlobMSBSignedLong$handle() {
        return ReadBlobMSBSignedLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern magick_int32_t ReadBlobMSBSignedLong(Image *image)
     * }
     */
    public static MemorySegment ReadBlobMSBSignedLong$address() {
        return ReadBlobMSBSignedLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern magick_int32_t ReadBlobMSBSignedLong(Image *image)
     * }
     */
    public static int ReadBlobMSBSignedLong(MemorySegment image) {
        var mh$ = ReadBlobMSBSignedLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobMSBSignedLong", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobMSBLongs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobMSBLongs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ReadBlobMSBLongs(Image *image, size_t octets, magick_uint32_t *data)
     * }
     */
    public static FunctionDescriptor ReadBlobMSBLongs$descriptor() {
        return ReadBlobMSBLongs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ReadBlobMSBLongs(Image *image, size_t octets, magick_uint32_t *data)
     * }
     */
    public static MethodHandle ReadBlobMSBLongs$handle() {
        return ReadBlobMSBLongs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ReadBlobMSBLongs(Image *image, size_t octets, magick_uint32_t *data)
     * }
     */
    public static MemorySegment ReadBlobMSBLongs$address() {
        return ReadBlobMSBLongs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ReadBlobMSBLongs(Image *image, size_t octets, magick_uint32_t *data)
     * }
     */
    public static long ReadBlobMSBLongs(MemorySegment image, long octets, MemorySegment data) {
        var mh$ = ReadBlobMSBLongs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobMSBLongs", image, octets, data);
            }
            return (long)mh$.invokeExact(image, octets, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobLSBFloat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_FLOAT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobLSBFloat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ReadBlobLSBFloat(Image *image)
     * }
     */
    public static FunctionDescriptor ReadBlobLSBFloat$descriptor() {
        return ReadBlobLSBFloat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ReadBlobLSBFloat(Image *image)
     * }
     */
    public static MethodHandle ReadBlobLSBFloat$handle() {
        return ReadBlobLSBFloat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ReadBlobLSBFloat(Image *image)
     * }
     */
    public static MemorySegment ReadBlobLSBFloat$address() {
        return ReadBlobLSBFloat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ReadBlobLSBFloat(Image *image)
     * }
     */
    public static float ReadBlobLSBFloat(MemorySegment image) {
        var mh$ = ReadBlobLSBFloat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobLSBFloat", image);
            }
            return (float)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobLSBFloats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobLSBFloats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ReadBlobLSBFloats(Image *image, size_t octets, float *data)
     * }
     */
    public static FunctionDescriptor ReadBlobLSBFloats$descriptor() {
        return ReadBlobLSBFloats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ReadBlobLSBFloats(Image *image, size_t octets, float *data)
     * }
     */
    public static MethodHandle ReadBlobLSBFloats$handle() {
        return ReadBlobLSBFloats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ReadBlobLSBFloats(Image *image, size_t octets, float *data)
     * }
     */
    public static MemorySegment ReadBlobLSBFloats$address() {
        return ReadBlobLSBFloats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ReadBlobLSBFloats(Image *image, size_t octets, float *data)
     * }
     */
    public static long ReadBlobLSBFloats(MemorySegment image, long octets, MemorySegment data) {
        var mh$ = ReadBlobLSBFloats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobLSBFloats", image, octets, data);
            }
            return (long)mh$.invokeExact(image, octets, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobMSBFloat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_FLOAT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobMSBFloat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ReadBlobMSBFloat(Image *image)
     * }
     */
    public static FunctionDescriptor ReadBlobMSBFloat$descriptor() {
        return ReadBlobMSBFloat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ReadBlobMSBFloat(Image *image)
     * }
     */
    public static MethodHandle ReadBlobMSBFloat$handle() {
        return ReadBlobMSBFloat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ReadBlobMSBFloat(Image *image)
     * }
     */
    public static MemorySegment ReadBlobMSBFloat$address() {
        return ReadBlobMSBFloat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ReadBlobMSBFloat(Image *image)
     * }
     */
    public static float ReadBlobMSBFloat(MemorySegment image) {
        var mh$ = ReadBlobMSBFloat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobMSBFloat", image);
            }
            return (float)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobMSBFloats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobMSBFloats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ReadBlobMSBFloats(Image *image, size_t octets, float *data)
     * }
     */
    public static FunctionDescriptor ReadBlobMSBFloats$descriptor() {
        return ReadBlobMSBFloats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ReadBlobMSBFloats(Image *image, size_t octets, float *data)
     * }
     */
    public static MethodHandle ReadBlobMSBFloats$handle() {
        return ReadBlobMSBFloats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ReadBlobMSBFloats(Image *image, size_t octets, float *data)
     * }
     */
    public static MemorySegment ReadBlobMSBFloats$address() {
        return ReadBlobMSBFloats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ReadBlobMSBFloats(Image *image, size_t octets, float *data)
     * }
     */
    public static long ReadBlobMSBFloats(MemorySegment image, long octets, MemorySegment data) {
        var mh$ = ReadBlobMSBFloats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobMSBFloats", image, octets, data);
            }
            return (long)mh$.invokeExact(image, octets, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobLSBDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobLSBDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ReadBlobLSBDouble(Image *image)
     * }
     */
    public static FunctionDescriptor ReadBlobLSBDouble$descriptor() {
        return ReadBlobLSBDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ReadBlobLSBDouble(Image *image)
     * }
     */
    public static MethodHandle ReadBlobLSBDouble$handle() {
        return ReadBlobLSBDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ReadBlobLSBDouble(Image *image)
     * }
     */
    public static MemorySegment ReadBlobLSBDouble$address() {
        return ReadBlobLSBDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ReadBlobLSBDouble(Image *image)
     * }
     */
    public static double ReadBlobLSBDouble(MemorySegment image) {
        var mh$ = ReadBlobLSBDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobLSBDouble", image);
            }
            return (double)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobLSBDoubles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobLSBDoubles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ReadBlobLSBDoubles(Image *image, size_t octets, double *data)
     * }
     */
    public static FunctionDescriptor ReadBlobLSBDoubles$descriptor() {
        return ReadBlobLSBDoubles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ReadBlobLSBDoubles(Image *image, size_t octets, double *data)
     * }
     */
    public static MethodHandle ReadBlobLSBDoubles$handle() {
        return ReadBlobLSBDoubles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ReadBlobLSBDoubles(Image *image, size_t octets, double *data)
     * }
     */
    public static MemorySegment ReadBlobLSBDoubles$address() {
        return ReadBlobLSBDoubles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ReadBlobLSBDoubles(Image *image, size_t octets, double *data)
     * }
     */
    public static long ReadBlobLSBDoubles(MemorySegment image, long octets, MemorySegment data) {
        var mh$ = ReadBlobLSBDoubles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobLSBDoubles", image, octets, data);
            }
            return (long)mh$.invokeExact(image, octets, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobMSBDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobMSBDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ReadBlobMSBDouble(Image *image)
     * }
     */
    public static FunctionDescriptor ReadBlobMSBDouble$descriptor() {
        return ReadBlobMSBDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ReadBlobMSBDouble(Image *image)
     * }
     */
    public static MethodHandle ReadBlobMSBDouble$handle() {
        return ReadBlobMSBDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ReadBlobMSBDouble(Image *image)
     * }
     */
    public static MemorySegment ReadBlobMSBDouble$address() {
        return ReadBlobMSBDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ReadBlobMSBDouble(Image *image)
     * }
     */
    public static double ReadBlobMSBDouble(MemorySegment image) {
        var mh$ = ReadBlobMSBDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobMSBDouble", image);
            }
            return (double)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobMSBDoubles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobMSBDoubles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ReadBlobMSBDoubles(Image *image, size_t octets, double *data)
     * }
     */
    public static FunctionDescriptor ReadBlobMSBDoubles$descriptor() {
        return ReadBlobMSBDoubles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ReadBlobMSBDoubles(Image *image, size_t octets, double *data)
     * }
     */
    public static MethodHandle ReadBlobMSBDoubles$handle() {
        return ReadBlobMSBDoubles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ReadBlobMSBDoubles(Image *image, size_t octets, double *data)
     * }
     */
    public static MemorySegment ReadBlobMSBDoubles$address() {
        return ReadBlobMSBDoubles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ReadBlobMSBDoubles(Image *image, size_t octets, double *data)
     * }
     */
    public static long ReadBlobMSBDoubles(MemorySegment image, long octets, MemorySegment data) {
        var mh$ = ReadBlobMSBDoubles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobMSBDoubles", image, octets, data);
            }
            return (long)mh$.invokeExact(image, octets, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadBlobString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadBlobString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ReadBlobString(Image *image, char *string)
     * }
     */
    public static FunctionDescriptor ReadBlobString$descriptor() {
        return ReadBlobString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ReadBlobString(Image *image, char *string)
     * }
     */
    public static MethodHandle ReadBlobString$handle() {
        return ReadBlobString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ReadBlobString(Image *image, char *string)
     * }
     */
    public static MemorySegment ReadBlobString$address() {
        return ReadBlobString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ReadBlobString(Image *image, char *string)
     * }
     */
    public static MemorySegment ReadBlobString(MemorySegment image, MemorySegment string) {
        var mh$ = ReadBlobString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadBlobString", image, string);
            }
            return (MemorySegment)mh$.invokeExact(image, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteBlobByte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_CHAR
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WriteBlobByte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t WriteBlobByte(Image *image, const magick_uint8_t value)
     * }
     */
    public static FunctionDescriptor WriteBlobByte$descriptor() {
        return WriteBlobByte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t WriteBlobByte(Image *image, const magick_uint8_t value)
     * }
     */
    public static MethodHandle WriteBlobByte$handle() {
        return WriteBlobByte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t WriteBlobByte(Image *image, const magick_uint8_t value)
     * }
     */
    public static MemorySegment WriteBlobByte$address() {
        return WriteBlobByte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t WriteBlobByte(Image *image, const magick_uint8_t value)
     * }
     */
    public static long WriteBlobByte(MemorySegment image, byte value) {
        var mh$ = WriteBlobByte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteBlobByte", image, value);
            }
            return (long)mh$.invokeExact(image, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteBlobFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WriteBlobFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int WriteBlobFile(Image *image, const char *filename)
     * }
     */
    public static FunctionDescriptor WriteBlobFile$descriptor() {
        return WriteBlobFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int WriteBlobFile(Image *image, const char *filename)
     * }
     */
    public static MethodHandle WriteBlobFile$handle() {
        return WriteBlobFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int WriteBlobFile(Image *image, const char *filename)
     * }
     */
    public static MemorySegment WriteBlobFile$address() {
        return WriteBlobFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int WriteBlobFile(Image *image, const char *filename)
     * }
     */
    public static int WriteBlobFile(MemorySegment image, MemorySegment filename) {
        var mh$ = WriteBlobFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteBlobFile", image, filename);
            }
            return (int)mh$.invokeExact(image, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteBlobLSBShort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_SHORT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WriteBlobLSBShort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBShort(Image *image, const magick_uint16_t value)
     * }
     */
    public static FunctionDescriptor WriteBlobLSBShort$descriptor() {
        return WriteBlobLSBShort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBShort(Image *image, const magick_uint16_t value)
     * }
     */
    public static MethodHandle WriteBlobLSBShort$handle() {
        return WriteBlobLSBShort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBShort(Image *image, const magick_uint16_t value)
     * }
     */
    public static MemorySegment WriteBlobLSBShort$address() {
        return WriteBlobLSBShort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBShort(Image *image, const magick_uint16_t value)
     * }
     */
    public static long WriteBlobLSBShort(MemorySegment image, short value) {
        var mh$ = WriteBlobLSBShort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteBlobLSBShort", image, value);
            }
            return (long)mh$.invokeExact(image, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteBlobLSBSignedShort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_SHORT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WriteBlobLSBSignedShort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBSignedShort(Image *image, const magick_int16_t value)
     * }
     */
    public static FunctionDescriptor WriteBlobLSBSignedShort$descriptor() {
        return WriteBlobLSBSignedShort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBSignedShort(Image *image, const magick_int16_t value)
     * }
     */
    public static MethodHandle WriteBlobLSBSignedShort$handle() {
        return WriteBlobLSBSignedShort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBSignedShort(Image *image, const magick_int16_t value)
     * }
     */
    public static MemorySegment WriteBlobLSBSignedShort$address() {
        return WriteBlobLSBSignedShort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBSignedShort(Image *image, const magick_int16_t value)
     * }
     */
    public static long WriteBlobLSBSignedShort(MemorySegment image, short value) {
        var mh$ = WriteBlobLSBSignedShort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteBlobLSBSignedShort", image, value);
            }
            return (long)mh$.invokeExact(image, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteBlobLSBLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WriteBlobLSBLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBLong(Image *image, const magick_uint32_t value)
     * }
     */
    public static FunctionDescriptor WriteBlobLSBLong$descriptor() {
        return WriteBlobLSBLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBLong(Image *image, const magick_uint32_t value)
     * }
     */
    public static MethodHandle WriteBlobLSBLong$handle() {
        return WriteBlobLSBLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBLong(Image *image, const magick_uint32_t value)
     * }
     */
    public static MemorySegment WriteBlobLSBLong$address() {
        return WriteBlobLSBLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBLong(Image *image, const magick_uint32_t value)
     * }
     */
    public static long WriteBlobLSBLong(MemorySegment image, int value) {
        var mh$ = WriteBlobLSBLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteBlobLSBLong", image, value);
            }
            return (long)mh$.invokeExact(image, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteBlobLSBSignedLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WriteBlobLSBSignedLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBSignedLong(Image *image, const magick_int32_t value)
     * }
     */
    public static FunctionDescriptor WriteBlobLSBSignedLong$descriptor() {
        return WriteBlobLSBSignedLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBSignedLong(Image *image, const magick_int32_t value)
     * }
     */
    public static MethodHandle WriteBlobLSBSignedLong$handle() {
        return WriteBlobLSBSignedLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBSignedLong(Image *image, const magick_int32_t value)
     * }
     */
    public static MemorySegment WriteBlobLSBSignedLong$address() {
        return WriteBlobLSBSignedLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBSignedLong(Image *image, const magick_int32_t value)
     * }
     */
    public static long WriteBlobLSBSignedLong(MemorySegment image, int value) {
        var mh$ = WriteBlobLSBSignedLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteBlobLSBSignedLong", image, value);
            }
            return (long)mh$.invokeExact(image, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteBlobLSBDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WriteBlobLSBDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBDouble(Image *image, double d)
     * }
     */
    public static FunctionDescriptor WriteBlobLSBDouble$descriptor() {
        return WriteBlobLSBDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBDouble(Image *image, double d)
     * }
     */
    public static MethodHandle WriteBlobLSBDouble$handle() {
        return WriteBlobLSBDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBDouble(Image *image, double d)
     * }
     */
    public static MemorySegment WriteBlobLSBDouble$address() {
        return WriteBlobLSBDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t WriteBlobLSBDouble(Image *image, double d)
     * }
     */
    public static long WriteBlobLSBDouble(MemorySegment image, double d) {
        var mh$ = WriteBlobLSBDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteBlobLSBDouble", image, d);
            }
            return (long)mh$.invokeExact(image, d);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteBlobMSBLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WriteBlobMSBLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t WriteBlobMSBLong(Image *image, const magick_uint32_t value)
     * }
     */
    public static FunctionDescriptor WriteBlobMSBLong$descriptor() {
        return WriteBlobMSBLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t WriteBlobMSBLong(Image *image, const magick_uint32_t value)
     * }
     */
    public static MethodHandle WriteBlobMSBLong$handle() {
        return WriteBlobMSBLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t WriteBlobMSBLong(Image *image, const magick_uint32_t value)
     * }
     */
    public static MemorySegment WriteBlobMSBLong$address() {
        return WriteBlobMSBLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t WriteBlobMSBLong(Image *image, const magick_uint32_t value)
     * }
     */
    public static long WriteBlobMSBLong(MemorySegment image, int value) {
        var mh$ = WriteBlobMSBLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteBlobMSBLong", image, value);
            }
            return (long)mh$.invokeExact(image, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteBlobMSBSignedLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WriteBlobMSBSignedLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t WriteBlobMSBSignedLong(Image *image, const magick_int32_t value)
     * }
     */
    public static FunctionDescriptor WriteBlobMSBSignedLong$descriptor() {
        return WriteBlobMSBSignedLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t WriteBlobMSBSignedLong(Image *image, const magick_int32_t value)
     * }
     */
    public static MethodHandle WriteBlobMSBSignedLong$handle() {
        return WriteBlobMSBSignedLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t WriteBlobMSBSignedLong(Image *image, const magick_int32_t value)
     * }
     */
    public static MemorySegment WriteBlobMSBSignedLong$address() {
        return WriteBlobMSBSignedLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t WriteBlobMSBSignedLong(Image *image, const magick_int32_t value)
     * }
     */
    public static long WriteBlobMSBSignedLong(MemorySegment image, int value) {
        var mh$ = WriteBlobMSBSignedLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteBlobMSBSignedLong", image, value);
            }
            return (long)mh$.invokeExact(image, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteBlobMSBShort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_SHORT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WriteBlobMSBShort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t WriteBlobMSBShort(Image *image, const magick_uint16_t value)
     * }
     */
    public static FunctionDescriptor WriteBlobMSBShort$descriptor() {
        return WriteBlobMSBShort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t WriteBlobMSBShort(Image *image, const magick_uint16_t value)
     * }
     */
    public static MethodHandle WriteBlobMSBShort$handle() {
        return WriteBlobMSBShort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t WriteBlobMSBShort(Image *image, const magick_uint16_t value)
     * }
     */
    public static MemorySegment WriteBlobMSBShort$address() {
        return WriteBlobMSBShort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t WriteBlobMSBShort(Image *image, const magick_uint16_t value)
     * }
     */
    public static long WriteBlobMSBShort(MemorySegment image, short value) {
        var mh$ = WriteBlobMSBShort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteBlobMSBShort", image, value);
            }
            return (long)mh$.invokeExact(image, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteBlobMSBSignedShort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_SHORT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WriteBlobMSBSignedShort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t WriteBlobMSBSignedShort(Image *image, const magick_int16_t value)
     * }
     */
    public static FunctionDescriptor WriteBlobMSBSignedShort$descriptor() {
        return WriteBlobMSBSignedShort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t WriteBlobMSBSignedShort(Image *image, const magick_int16_t value)
     * }
     */
    public static MethodHandle WriteBlobMSBSignedShort$handle() {
        return WriteBlobMSBSignedShort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t WriteBlobMSBSignedShort(Image *image, const magick_int16_t value)
     * }
     */
    public static MemorySegment WriteBlobMSBSignedShort$address() {
        return WriteBlobMSBSignedShort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t WriteBlobMSBSignedShort(Image *image, const magick_int16_t value)
     * }
     */
    public static long WriteBlobMSBSignedShort(MemorySegment image, short value) {
        var mh$ = WriteBlobMSBSignedShort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteBlobMSBSignedShort", image, value);
            }
            return (long)mh$.invokeExact(image, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteBlobString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WriteBlobString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t WriteBlobString(Image *image, const char *string)
     * }
     */
    public static FunctionDescriptor WriteBlobString$descriptor() {
        return WriteBlobString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t WriteBlobString(Image *image, const char *string)
     * }
     */
    public static MethodHandle WriteBlobString$handle() {
        return WriteBlobString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t WriteBlobString(Image *image, const char *string)
     * }
     */
    public static MemorySegment WriteBlobString$address() {
        return WriteBlobString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t WriteBlobString(Image *image, const char *string)
     * }
     */
    public static long WriteBlobString(MemorySegment image, MemorySegment string) {
        var mh$ = WriteBlobString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteBlobString", image, string);
            }
            return (long)mh$.invokeExact(image, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BlobIsSeekable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("BlobIsSeekable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int BlobIsSeekable(const Image *image)
     * }
     */
    public static FunctionDescriptor BlobIsSeekable$descriptor() {
        return BlobIsSeekable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int BlobIsSeekable(const Image *image)
     * }
     */
    public static MethodHandle BlobIsSeekable$handle() {
        return BlobIsSeekable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int BlobIsSeekable(const Image *image)
     * }
     */
    public static MemorySegment BlobIsSeekable$address() {
        return BlobIsSeekable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int BlobIsSeekable(const Image *image)
     * }
     */
    public static int BlobIsSeekable(MemorySegment image) {
        var mh$ = BlobIsSeekable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BlobIsSeekable", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBlobClosable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetBlobClosable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void SetBlobClosable(Image *image, unsigned int closable)
     * }
     */
    public static FunctionDescriptor SetBlobClosable$descriptor() {
        return SetBlobClosable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void SetBlobClosable(Image *image, unsigned int closable)
     * }
     */
    public static MethodHandle SetBlobClosable$handle() {
        return SetBlobClosable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void SetBlobClosable(Image *image, unsigned int closable)
     * }
     */
    public static MemorySegment SetBlobClosable$address() {
        return SetBlobClosable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void SetBlobClosable(Image *image, unsigned int closable)
     * }
     */
    public static void SetBlobClosable(MemorySegment image, int closable) {
        var mh$ = SetBlobClosable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBlobClosable", image, closable);
            }
            mh$.invokeExact(image, closable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBlobTemporary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetBlobTemporary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void SetBlobTemporary(Image *image, unsigned int isTemporary)
     * }
     */
    public static FunctionDescriptor SetBlobTemporary$descriptor() {
        return SetBlobTemporary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void SetBlobTemporary(Image *image, unsigned int isTemporary)
     * }
     */
    public static MethodHandle SetBlobTemporary$handle() {
        return SetBlobTemporary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void SetBlobTemporary(Image *image, unsigned int isTemporary)
     * }
     */
    public static MemorySegment SetBlobTemporary$address() {
        return SetBlobTemporary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void SetBlobTemporary(Image *image, unsigned int isTemporary)
     * }
     */
    public static void SetBlobTemporary(MemorySegment image, int isTemporary) {
        var mh$ = SetBlobTemporary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBlobTemporary", image, isTemporary);
            }
            mh$.invokeExact(image, isTemporary);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBlobTemporary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetBlobTemporary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int GetBlobTemporary(const Image *image)
     * }
     */
    public static FunctionDescriptor GetBlobTemporary$descriptor() {
        return GetBlobTemporary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int GetBlobTemporary(const Image *image)
     * }
     */
    public static MethodHandle GetBlobTemporary$handle() {
        return GetBlobTemporary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int GetBlobTemporary(const Image *image)
     * }
     */
    public static MemorySegment GetBlobTemporary$address() {
        return GetBlobTemporary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int GetBlobTemporary(const Image *image)
     * }
     */
    public static int GetBlobTemporary(MemorySegment image) {
        var mh$ = GetBlobTemporary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBlobTemporary", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ReadMode = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ReadMode = 0
     * }
     */
    public static int ReadMode() {
        return ReadMode;
    }
    private static final int WriteMode = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WriteMode = 1
     * }
     */
    public static int WriteMode() {
        return WriteMode;
    }
    private static final int IOMode = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IOMode = 2
     * }
     */
    public static int IOMode() {
        return IOMode;
    }

    private static class UnmapBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("UnmapBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int UnmapBlob(void *map, const size_t length)
     * }
     */
    public static FunctionDescriptor UnmapBlob$descriptor() {
        return UnmapBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int UnmapBlob(void *map, const size_t length)
     * }
     */
    public static MethodHandle UnmapBlob$handle() {
        return UnmapBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int UnmapBlob(void *map, const size_t length)
     * }
     */
    public static MemorySegment UnmapBlob$address() {
        return UnmapBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int UnmapBlob(void *map, const size_t length)
     * }
     */
    public static int UnmapBlob(MemorySegment map, long length) {
        var mh$ = UnmapBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnmapBlob", map, length);
            }
            return (int)mh$.invokeExact(map, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MapBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *MapBlob(int file, const MapMode mode, magick_off_t offset, size_t length)
     * }
     */
    public static FunctionDescriptor MapBlob$descriptor() {
        return MapBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *MapBlob(int file, const MapMode mode, magick_off_t offset, size_t length)
     * }
     */
    public static MethodHandle MapBlob$handle() {
        return MapBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *MapBlob(int file, const MapMode mode, magick_off_t offset, size_t length)
     * }
     */
    public static MemorySegment MapBlob$address() {
        return MapBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *MapBlob(int file, const MapMode mode, magick_off_t offset, size_t length)
     * }
     */
    public static MemorySegment MapBlob(int file, int mode, long offset, long length) {
        var mh$ = MapBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapBlob", file, mode, offset, length);
            }
            return (MemorySegment)mh$.invokeExact(file, mode, offset, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BlobToFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("BlobToFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int BlobToFile(const char *filename, const void *blob, const size_t length, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor BlobToFile$descriptor() {
        return BlobToFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int BlobToFile(const char *filename, const void *blob, const size_t length, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle BlobToFile$handle() {
        return BlobToFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int BlobToFile(const char *filename, const void *blob, const size_t length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment BlobToFile$address() {
        return BlobToFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int BlobToFile(const char *filename, const void *blob, const size_t length, ExceptionInfo *exception)
     * }
     */
    public static int BlobToFile(MemorySegment filename, MemorySegment blob, long length, MemorySegment exception) {
        var mh$ = BlobToFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BlobToFile", filename, blob, length, exception);
            }
            return (int)mh$.invokeExact(filename, blob, length, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileToBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("FileToBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *FileToBlob(const char *filename, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor FileToBlob$descriptor() {
        return FileToBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *FileToBlob(const char *filename, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle FileToBlob$handle() {
        return FileToBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *FileToBlob(const char *filename, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment FileToBlob$address() {
        return FileToBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *FileToBlob(const char *filename, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment FileToBlob(MemorySegment filename, MemorySegment length, MemorySegment exception) {
        var mh$ = FileToBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileToBlob", filename, length, exception);
            }
            return (MemorySegment)mh$.invokeExact(filename, length, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BlobReserveSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("BlobReserveSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int BlobReserveSize(Image *image, magick_off_t size)
     * }
     */
    public static FunctionDescriptor BlobReserveSize$descriptor() {
        return BlobReserveSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int BlobReserveSize(Image *image, magick_off_t size)
     * }
     */
    public static MethodHandle BlobReserveSize$handle() {
        return BlobReserveSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int BlobReserveSize(Image *image, magick_off_t size)
     * }
     */
    public static MemorySegment BlobReserveSize$address() {
        return BlobReserveSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int BlobReserveSize(Image *image, magick_off_t size)
     * }
     */
    public static int BlobReserveSize(MemorySegment image, long size) {
        var mh$ = BlobReserveSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BlobReserveSize", image, size);
            }
            return (int)mh$.invokeExact(image, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageToFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ImageToFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ImageToFile(Image *image, const char *filename, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ImageToFile$descriptor() {
        return ImageToFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ImageToFile(Image *image, const char *filename, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ImageToFile$handle() {
        return ImageToFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ImageToFile(Image *image, const char *filename, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ImageToFile$address() {
        return ImageToFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ImageToFile(Image *image, const char *filename, ExceptionInfo *exception)
     * }
     */
    public static int ImageToFile(MemorySegment image, MemorySegment filename, MemorySegment exception) {
        var mh$ = ImageToFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageToFile", image, filename, exception);
            }
            return (int)mh$.invokeExact(image, filename, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConfigureBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetConfigureBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *GetConfigureBlob(const char *filename, char *path, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetConfigureBlob$descriptor() {
        return GetConfigureBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *GetConfigureBlob(const char *filename, char *path, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetConfigureBlob$handle() {
        return GetConfigureBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *GetConfigureBlob(const char *filename, char *path, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetConfigureBlob$address() {
        return GetConfigureBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *GetConfigureBlob(const char *filename, char *path, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetConfigureBlob(MemorySegment filename, MemorySegment path, MemorySegment length, MemorySegment exception) {
        var mh$ = GetConfigureBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConfigureBlob", filename, path, length, exception);
            }
            return (MemorySegment)mh$.invokeExact(filename, path, length, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MSBOrderLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MSBOrderLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MSBOrderLong(unsigned char *buffer, const size_t length)
     * }
     */
    public static FunctionDescriptor MSBOrderLong$descriptor() {
        return MSBOrderLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MSBOrderLong(unsigned char *buffer, const size_t length)
     * }
     */
    public static MethodHandle MSBOrderLong$handle() {
        return MSBOrderLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MSBOrderLong(unsigned char *buffer, const size_t length)
     * }
     */
    public static MemorySegment MSBOrderLong$address() {
        return MSBOrderLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MSBOrderLong(unsigned char *buffer, const size_t length)
     * }
     */
    public static void MSBOrderLong(MemorySegment buffer, long length) {
        var mh$ = MSBOrderLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MSBOrderLong", buffer, length);
            }
            mh$.invokeExact(buffer, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MSBOrderShort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MSBOrderShort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MSBOrderShort(unsigned char *p, const size_t length)
     * }
     */
    public static FunctionDescriptor MSBOrderShort$descriptor() {
        return MSBOrderShort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MSBOrderShort(unsigned char *p, const size_t length)
     * }
     */
    public static MethodHandle MSBOrderShort$handle() {
        return MSBOrderShort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MSBOrderShort(unsigned char *p, const size_t length)
     * }
     */
    public static MemorySegment MSBOrderShort$address() {
        return MSBOrderShort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MSBOrderShort(unsigned char *p, const size_t length)
     * }
     */
    public static void MSBOrderShort(MemorySegment p, long length) {
        var mh$ = MSBOrderShort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MSBOrderShort", p, length);
            }
            mh$.invokeExact(p, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisassociateBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DisassociateBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DisassociateBlob(Image *)
     * }
     */
    public static FunctionDescriptor DisassociateBlob$descriptor() {
        return DisassociateBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DisassociateBlob(Image *)
     * }
     */
    public static MethodHandle DisassociateBlob$handle() {
        return DisassociateBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DisassociateBlob(Image *)
     * }
     */
    public static MemorySegment DisassociateBlob$address() {
        return DisassociateBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DisassociateBlob(Image *)
     * }
     */
    public static void DisassociateBlob(MemorySegment x0) {
        var mh$ = DisassociateBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisassociateBlob", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CdlImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CdlImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int CdlImage(Image *image, const char *cdl)
     * }
     */
    public static FunctionDescriptor CdlImage$descriptor() {
        return CdlImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int CdlImage(Image *image, const char *cdl)
     * }
     */
    public static MethodHandle CdlImage$handle() {
        return CdlImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int CdlImage(Image *image, const char *cdl)
     * }
     */
    public static MemorySegment CdlImage$address() {
        return CdlImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int CdlImage(Image *image, const char *cdl)
     * }
     */
    public static int CdlImage(MemorySegment image, MemorySegment cdl) {
        var mh$ = CdlImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CdlImage", image, cdl);
            }
            return (int)mh$.invokeExact(image, cdl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportImageChannel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ExportImageChannel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ExportImageChannel(const Image *image, const ChannelType channel, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ExportImageChannel$descriptor() {
        return ExportImageChannel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ExportImageChannel(const Image *image, const ChannelType channel, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ExportImageChannel$handle() {
        return ExportImageChannel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ExportImageChannel(const Image *image, const ChannelType channel, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ExportImageChannel$address() {
        return ExportImageChannel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ExportImageChannel(const Image *image, const ChannelType channel, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ExportImageChannel(MemorySegment image, int channel, MemorySegment exception) {
        var mh$ = ExportImageChannel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportImageChannel", image, channel, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, channel, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageChannelDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageChannelDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int GetImageChannelDepth(const Image *image, const ChannelType channel, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetImageChannelDepth$descriptor() {
        return GetImageChannelDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int GetImageChannelDepth(const Image *image, const ChannelType channel, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetImageChannelDepth$handle() {
        return GetImageChannelDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int GetImageChannelDepth(const Image *image, const ChannelType channel, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetImageChannelDepth$address() {
        return GetImageChannelDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int GetImageChannelDepth(const Image *image, const ChannelType channel, ExceptionInfo *exception)
     * }
     */
    public static int GetImageChannelDepth(MemorySegment image, int channel, MemorySegment exception) {
        var mh$ = GetImageChannelDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageChannelDepth", image, channel, exception);
            }
            return (int)mh$.invokeExact(image, channel, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChannelImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ChannelImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ChannelImage(Image *image, const ChannelType channel)
     * }
     */
    public static FunctionDescriptor ChannelImage$descriptor() {
        return ChannelImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ChannelImage(Image *image, const ChannelType channel)
     * }
     */
    public static MethodHandle ChannelImage$handle() {
        return ChannelImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ChannelImage(Image *image, const ChannelType channel)
     * }
     */
    public static MemorySegment ChannelImage$address() {
        return ChannelImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ChannelImage(Image *image, const ChannelType channel)
     * }
     */
    public static int ChannelImage(MemorySegment image, int channel) {
        var mh$ = ChannelImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChannelImage", image, channel);
            }
            return (int)mh$.invokeExact(image, channel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImportImageChannel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ImportImageChannel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ImportImageChannel(const Image *src_image, Image *dst_image, const ChannelType channel)
     * }
     */
    public static FunctionDescriptor ImportImageChannel$descriptor() {
        return ImportImageChannel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ImportImageChannel(const Image *src_image, Image *dst_image, const ChannelType channel)
     * }
     */
    public static MethodHandle ImportImageChannel$handle() {
        return ImportImageChannel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ImportImageChannel(const Image *src_image, Image *dst_image, const ChannelType channel)
     * }
     */
    public static MemorySegment ImportImageChannel$address() {
        return ImportImageChannel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ImportImageChannel(const Image *src_image, Image *dst_image, const ChannelType channel)
     * }
     */
    public static int ImportImageChannel(MemorySegment src_image, MemorySegment dst_image, int channel) {
        var mh$ = ImportImageChannel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImportImageChannel", src_image, dst_image, channel);
            }
            return (int)mh$.invokeExact(src_image, dst_image, channel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImportImageChannelsMasked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ImportImageChannelsMasked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ImportImageChannelsMasked(const Image *source_image, Image *update_image, const ChannelType channels)
     * }
     */
    public static FunctionDescriptor ImportImageChannelsMasked$descriptor() {
        return ImportImageChannelsMasked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ImportImageChannelsMasked(const Image *source_image, Image *update_image, const ChannelType channels)
     * }
     */
    public static MethodHandle ImportImageChannelsMasked$handle() {
        return ImportImageChannelsMasked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ImportImageChannelsMasked(const Image *source_image, Image *update_image, const ChannelType channels)
     * }
     */
    public static MemorySegment ImportImageChannelsMasked$address() {
        return ImportImageChannelsMasked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ImportImageChannelsMasked(const Image *source_image, Image *update_image, const ChannelType channels)
     * }
     */
    public static int ImportImageChannelsMasked(MemorySegment source_image, MemorySegment update_image, int channels) {
        var mh$ = ImportImageChannelsMasked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImportImageChannelsMasked", source_image, update_image, channels);
            }
            return (int)mh$.invokeExact(source_image, update_image, channels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetImageChannelDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetImageChannelDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SetImageChannelDepth(Image *image, const ChannelType channel, const unsigned int depth)
     * }
     */
    public static FunctionDescriptor SetImageChannelDepth$descriptor() {
        return SetImageChannelDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SetImageChannelDepth(Image *image, const ChannelType channel, const unsigned int depth)
     * }
     */
    public static MethodHandle SetImageChannelDepth$handle() {
        return SetImageChannelDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SetImageChannelDepth(Image *image, const ChannelType channel, const unsigned int depth)
     * }
     */
    public static MemorySegment SetImageChannelDepth$address() {
        return SetImageChannelDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SetImageChannelDepth(Image *image, const ChannelType channel, const unsigned int depth)
     * }
     */
    public static int SetImageChannelDepth(MemorySegment image, int channel, int depth) {
        var mh$ = SetImageChannelDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetImageChannelDepth", image, channel, depth);
            }
            return (int)mh$.invokeExact(image, channel, depth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetColorHistogram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetColorHistogram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HistogramColorPacket *GetColorHistogram(const Image *image, unsigned long *colors, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetColorHistogram$descriptor() {
        return GetColorHistogram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HistogramColorPacket *GetColorHistogram(const Image *image, unsigned long *colors, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetColorHistogram$handle() {
        return GetColorHistogram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HistogramColorPacket *GetColorHistogram(const Image *image, unsigned long *colors, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetColorHistogram$address() {
        return GetColorHistogram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HistogramColorPacket *GetColorHistogram(const Image *image, unsigned long *colors, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetColorHistogram(MemorySegment image, MemorySegment colors, MemorySegment exception) {
        var mh$ = GetColorHistogram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetColorHistogram", image, colors, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, colors, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberColors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetNumberColors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long GetNumberColors(const Image *image, FILE *file, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetNumberColors$descriptor() {
        return GetNumberColors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long GetNumberColors(const Image *image, FILE *file, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetNumberColors$handle() {
        return GetNumberColors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long GetNumberColors(const Image *image, FILE *file, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetNumberColors$address() {
        return GetNumberColors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long GetNumberColors(const Image *image, FILE *file, ExceptionInfo *exception)
     * }
     */
    public static long GetNumberColors(MemorySegment image, MemorySegment file, MemorySegment exception) {
        var mh$ = GetNumberColors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberColors", image, file, exception);
            }
            return (long)mh$.invokeExact(image, file, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetColorTuple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetColorTuple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void GetColorTuple(const PixelPacket *color, const unsigned int depth, const unsigned int matte, const unsigned int hex, char *tuple)
     * }
     */
    public static FunctionDescriptor GetColorTuple$descriptor() {
        return GetColorTuple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void GetColorTuple(const PixelPacket *color, const unsigned int depth, const unsigned int matte, const unsigned int hex, char *tuple)
     * }
     */
    public static MethodHandle GetColorTuple$handle() {
        return GetColorTuple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void GetColorTuple(const PixelPacket *color, const unsigned int depth, const unsigned int matte, const unsigned int hex, char *tuple)
     * }
     */
    public static MemorySegment GetColorTuple$address() {
        return GetColorTuple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void GetColorTuple(const PixelPacket *color, const unsigned int depth, const unsigned int matte, const unsigned int hex, char *tuple)
     * }
     */
    public static void GetColorTuple(MemorySegment color, int depth, int matte, int hex, MemorySegment tuple) {
        var mh$ = GetColorTuple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetColorTuple", color, depth, matte, hex, tuple);
            }
            mh$.invokeExact(color, depth, matte, hex, tuple);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsPaletteImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IsPaletteImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IsPaletteImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor IsPaletteImage$descriptor() {
        return IsPaletteImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IsPaletteImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle IsPaletteImage$handle() {
        return IsPaletteImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IsPaletteImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment IsPaletteImage$address() {
        return IsPaletteImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IsPaletteImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static int IsPaletteImage(MemorySegment image, MemorySegment exception) {
        var mh$ = IsPaletteImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsPaletteImage", image, exception);
            }
            return (int)mh$.invokeExact(image, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UndefinedCompliance = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedCompliance = 0
     * }
     */
    public static int UndefinedCompliance() {
        return UndefinedCompliance;
    }
    private static final int NoCompliance = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NoCompliance = 0
     * }
     */
    public static int NoCompliance() {
        return NoCompliance;
    }
    private static final int SVGCompliance = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SVGCompliance = 1
     * }
     */
    public static int SVGCompliance() {
        return SVGCompliance;
    }
    private static final int X11Compliance = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.X11Compliance = 2
     * }
     */
    public static int X11Compliance() {
        return X11Compliance;
    }
    private static final int XPMCompliance = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.XPMCompliance = 4
     * }
     */
    public static int XPMCompliance() {
        return XPMCompliance;
    }
    private static final int AllCompliance = (int)65535L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AllCompliance = 65535
     * }
     */
    public static int AllCompliance() {
        return AllCompliance;
    }

    private static class GetColorList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetColorList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char **GetColorList(const char *pattern, unsigned long *number_colors)
     * }
     */
    public static FunctionDescriptor GetColorList$descriptor() {
        return GetColorList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char **GetColorList(const char *pattern, unsigned long *number_colors)
     * }
     */
    public static MethodHandle GetColorList$handle() {
        return GetColorList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char **GetColorList(const char *pattern, unsigned long *number_colors)
     * }
     */
    public static MemorySegment GetColorList$address() {
        return GetColorList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char **GetColorList(const char *pattern, unsigned long *number_colors)
     * }
     */
    public static MemorySegment GetColorList(MemorySegment pattern, MemorySegment number_colors) {
        var mh$ = GetColorList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetColorList", pattern, number_colors);
            }
            return (MemorySegment)mh$.invokeExact(pattern, number_colors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryColorDatabase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("QueryColorDatabase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int QueryColorDatabase(const char *name, PixelPacket *color, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor QueryColorDatabase$descriptor() {
        return QueryColorDatabase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int QueryColorDatabase(const char *name, PixelPacket *color, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle QueryColorDatabase$handle() {
        return QueryColorDatabase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int QueryColorDatabase(const char *name, PixelPacket *color, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment QueryColorDatabase$address() {
        return QueryColorDatabase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int QueryColorDatabase(const char *name, PixelPacket *color, ExceptionInfo *exception)
     * }
     */
    public static int QueryColorDatabase(MemorySegment name, MemorySegment color, MemorySegment exception) {
        var mh$ = QueryColorDatabase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryColorDatabase", name, color, exception);
            }
            return (int)mh$.invokeExact(name, color, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryColorname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("QueryColorname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int QueryColorname(const Image *image, const PixelPacket *color, const ComplianceType compliance, char *name, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor QueryColorname$descriptor() {
        return QueryColorname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int QueryColorname(const Image *image, const PixelPacket *color, const ComplianceType compliance, char *name, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle QueryColorname$handle() {
        return QueryColorname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int QueryColorname(const Image *image, const PixelPacket *color, const ComplianceType compliance, char *name, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment QueryColorname$address() {
        return QueryColorname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int QueryColorname(const Image *image, const PixelPacket *color, const ComplianceType compliance, char *name, ExceptionInfo *exception)
     * }
     */
    public static int QueryColorname(MemorySegment image, MemorySegment color, int compliance, MemorySegment name, MemorySegment exception) {
        var mh$ = QueryColorname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryColorname", image, color, compliance, name, exception);
            }
            return (int)mh$.invokeExact(image, color, compliance, name, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateImageColormap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AllocateImageColormap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int AllocateImageColormap(Image *, const unsigned long colors)
     * }
     */
    public static FunctionDescriptor AllocateImageColormap$descriptor() {
        return AllocateImageColormap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int AllocateImageColormap(Image *, const unsigned long colors)
     * }
     */
    public static MethodHandle AllocateImageColormap$handle() {
        return AllocateImageColormap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int AllocateImageColormap(Image *, const unsigned long colors)
     * }
     */
    public static MemorySegment AllocateImageColormap$address() {
        return AllocateImageColormap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int AllocateImageColormap(Image *, const unsigned long colors)
     * }
     */
    public static int AllocateImageColormap(MemorySegment x0, long colors) {
        var mh$ = AllocateImageColormap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateImageColormap", x0, colors);
            }
            return (int)mh$.invokeExact(x0, colors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CycleColormapImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CycleColormapImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int CycleColormapImage(Image *image, const int amount)
     * }
     */
    public static FunctionDescriptor CycleColormapImage$descriptor() {
        return CycleColormapImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int CycleColormapImage(Image *image, const int amount)
     * }
     */
    public static MethodHandle CycleColormapImage$handle() {
        return CycleColormapImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int CycleColormapImage(Image *image, const int amount)
     * }
     */
    public static MemorySegment CycleColormapImage$address() {
        return CycleColormapImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int CycleColormapImage(Image *image, const int amount)
     * }
     */
    public static int CycleColormapImage(MemorySegment image, int amount) {
        var mh$ = CycleColormapImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CycleColormapImage", image, amount);
            }
            return (int)mh$.invokeExact(image, amount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReallocateImageColormap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReallocateImageColormap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ReallocateImageColormap(Image *, const unsigned int colors)
     * }
     */
    public static FunctionDescriptor ReallocateImageColormap$descriptor() {
        return ReallocateImageColormap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ReallocateImageColormap(Image *, const unsigned int colors)
     * }
     */
    public static MethodHandle ReallocateImageColormap$handle() {
        return ReallocateImageColormap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ReallocateImageColormap(Image *, const unsigned int colors)
     * }
     */
    public static MemorySegment ReallocateImageColormap$address() {
        return ReallocateImageColormap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ReallocateImageColormap(Image *, const unsigned int colors)
     * }
     */
    public static int ReallocateImageColormap(MemorySegment x0, int colors) {
        var mh$ = ReallocateImageColormap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReallocateImageColormap", x0, colors);
            }
            return (int)mh$.invokeExact(x0, colors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplaceImageColormap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReplaceImageColormap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ReplaceImageColormap(Image *image, const PixelPacket *colormap, const unsigned int colors)
     * }
     */
    public static FunctionDescriptor ReplaceImageColormap$descriptor() {
        return ReplaceImageColormap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ReplaceImageColormap(Image *image, const PixelPacket *colormap, const unsigned int colors)
     * }
     */
    public static MethodHandle ReplaceImageColormap$handle() {
        return ReplaceImageColormap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ReplaceImageColormap(Image *image, const PixelPacket *colormap, const unsigned int colors)
     * }
     */
    public static MemorySegment ReplaceImageColormap$address() {
        return ReplaceImageColormap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ReplaceImageColormap(Image *image, const PixelPacket *colormap, const unsigned int colors)
     * }
     */
    public static int ReplaceImageColormap(MemorySegment image, MemorySegment colormap, int colors) {
        var mh$ = ReplaceImageColormap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplaceImageColormap", image, colormap, colors);
            }
            return (int)mh$.invokeExact(image, colormap, colors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SortColormapByIntensity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SortColormapByIntensity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SortColormapByIntensity(Image *image)
     * }
     */
    public static FunctionDescriptor SortColormapByIntensity$descriptor() {
        return SortColormapByIntensity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SortColormapByIntensity(Image *image)
     * }
     */
    public static MethodHandle SortColormapByIntensity$handle() {
        return SortColormapByIntensity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SortColormapByIntensity(Image *image)
     * }
     */
    public static MemorySegment SortColormapByIntensity$address() {
        return SortColormapByIntensity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SortColormapByIntensity(Image *image)
     * }
     */
    public static int SortColormapByIntensity(MemorySegment image) {
        var mh$ = SortColormapByIntensity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SortColormapByIntensity", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimateImageCommand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AnimateImageCommand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int AnimateImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor AnimateImageCommand$descriptor() {
        return AnimateImageCommand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int AnimateImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle AnimateImageCommand$handle() {
        return AnimateImageCommand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int AnimateImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment AnimateImageCommand$address() {
        return AnimateImageCommand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int AnimateImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static int AnimateImageCommand(MemorySegment image_info, int argc, MemorySegment argv, MemorySegment metadata, MemorySegment exception) {
        var mh$ = AnimateImageCommand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimateImageCommand", image_info, argc, argv, metadata, exception);
            }
            return (int)mh$.invokeExact(image_info, argc, argv, metadata, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BenchmarkImageCommand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("BenchmarkImageCommand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int BenchmarkImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor BenchmarkImageCommand$descriptor() {
        return BenchmarkImageCommand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int BenchmarkImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle BenchmarkImageCommand$handle() {
        return BenchmarkImageCommand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int BenchmarkImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment BenchmarkImageCommand$address() {
        return BenchmarkImageCommand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int BenchmarkImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static int BenchmarkImageCommand(MemorySegment image_info, int argc, MemorySegment argv, MemorySegment metadata, MemorySegment exception) {
        var mh$ = BenchmarkImageCommand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BenchmarkImageCommand", image_info, argc, argv, metadata, exception);
            }
            return (int)mh$.invokeExact(image_info, argc, argv, metadata, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareImageCommand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CompareImageCommand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int CompareImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor CompareImageCommand$descriptor() {
        return CompareImageCommand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int CompareImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle CompareImageCommand$handle() {
        return CompareImageCommand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int CompareImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment CompareImageCommand$address() {
        return CompareImageCommand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int CompareImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static int CompareImageCommand(MemorySegment image_info, int argc, MemorySegment argv, MemorySegment metadata, MemorySegment exception) {
        var mh$ = CompareImageCommand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareImageCommand", image_info, argc, argv, metadata, exception);
            }
            return (int)mh$.invokeExact(image_info, argc, argv, metadata, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompositeImageCommand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CompositeImageCommand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int CompositeImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor CompositeImageCommand$descriptor() {
        return CompositeImageCommand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int CompositeImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle CompositeImageCommand$handle() {
        return CompositeImageCommand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int CompositeImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment CompositeImageCommand$address() {
        return CompositeImageCommand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int CompositeImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static int CompositeImageCommand(MemorySegment image_info, int argc, MemorySegment argv, MemorySegment metadata, MemorySegment exception) {
        var mh$ = CompositeImageCommand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompositeImageCommand", image_info, argc, argv, metadata, exception);
            }
            return (int)mh$.invokeExact(image_info, argc, argv, metadata, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConjureImageCommand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ConjureImageCommand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ConjureImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ConjureImageCommand$descriptor() {
        return ConjureImageCommand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ConjureImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ConjureImageCommand$handle() {
        return ConjureImageCommand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ConjureImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ConjureImageCommand$address() {
        return ConjureImageCommand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ConjureImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static int ConjureImageCommand(MemorySegment image_info, int argc, MemorySegment argv, MemorySegment metadata, MemorySegment exception) {
        var mh$ = ConjureImageCommand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConjureImageCommand", image_info, argc, argv, metadata, exception);
            }
            return (int)mh$.invokeExact(image_info, argc, argv, metadata, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertImageCommand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ConvertImageCommand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ConvertImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ConvertImageCommand$descriptor() {
        return ConvertImageCommand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ConvertImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ConvertImageCommand$handle() {
        return ConvertImageCommand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ConvertImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ConvertImageCommand$address() {
        return ConvertImageCommand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ConvertImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static int ConvertImageCommand(MemorySegment image_info, int argc, MemorySegment argv, MemorySegment metadata, MemorySegment exception) {
        var mh$ = ConvertImageCommand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertImageCommand", image_info, argc, argv, metadata, exception);
            }
            return (int)mh$.invokeExact(image_info, argc, argv, metadata, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisplayImageCommand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DisplayImageCommand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int DisplayImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor DisplayImageCommand$descriptor() {
        return DisplayImageCommand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int DisplayImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle DisplayImageCommand$handle() {
        return DisplayImageCommand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int DisplayImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment DisplayImageCommand$address() {
        return DisplayImageCommand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int DisplayImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static int DisplayImageCommand(MemorySegment image_info, int argc, MemorySegment argv, MemorySegment metadata, MemorySegment exception) {
        var mh$ = DisplayImageCommand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisplayImageCommand", image_info, argc, argv, metadata, exception);
            }
            return (int)mh$.invokeExact(image_info, argc, argv, metadata, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IdentifyImageCommand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IdentifyImageCommand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IdentifyImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor IdentifyImageCommand$descriptor() {
        return IdentifyImageCommand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IdentifyImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle IdentifyImageCommand$handle() {
        return IdentifyImageCommand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IdentifyImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment IdentifyImageCommand$address() {
        return IdentifyImageCommand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IdentifyImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static int IdentifyImageCommand(MemorySegment image_info, int argc, MemorySegment argv, MemorySegment metadata, MemorySegment exception) {
        var mh$ = IdentifyImageCommand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IdentifyImageCommand", image_info, argc, argv, metadata, exception);
            }
            return (int)mh$.invokeExact(image_info, argc, argv, metadata, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImportImageCommand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ImportImageCommand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ImportImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ImportImageCommand$descriptor() {
        return ImportImageCommand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ImportImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ImportImageCommand$handle() {
        return ImportImageCommand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ImportImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ImportImageCommand$address() {
        return ImportImageCommand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ImportImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static int ImportImageCommand(MemorySegment image_info, int argc, MemorySegment argv, MemorySegment metadata, MemorySegment exception) {
        var mh$ = ImportImageCommand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImportImageCommand", image_info, argc, argv, metadata, exception);
            }
            return (int)mh$.invokeExact(image_info, argc, argv, metadata, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickCommand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickCommand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MagickCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor MagickCommand$descriptor() {
        return MagickCommand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MagickCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle MagickCommand$handle() {
        return MagickCommand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MagickCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment MagickCommand$address() {
        return MagickCommand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MagickCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static int MagickCommand(MemorySegment image_info, int argc, MemorySegment argv, MemorySegment metadata, MemorySegment exception) {
        var mh$ = MagickCommand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickCommand", image_info, argc, argv, metadata, exception);
            }
            return (int)mh$.invokeExact(image_info, argc, argv, metadata, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MogrifyImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MogrifyImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MogrifyImage(const ImageInfo *, int, char **, Image **)
     * }
     */
    public static FunctionDescriptor MogrifyImage$descriptor() {
        return MogrifyImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MogrifyImage(const ImageInfo *, int, char **, Image **)
     * }
     */
    public static MethodHandle MogrifyImage$handle() {
        return MogrifyImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MogrifyImage(const ImageInfo *, int, char **, Image **)
     * }
     */
    public static MemorySegment MogrifyImage$address() {
        return MogrifyImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MogrifyImage(const ImageInfo *, int, char **, Image **)
     * }
     */
    public static int MogrifyImage(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = MogrifyImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MogrifyImage", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MogrifyImageCommand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MogrifyImageCommand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MogrifyImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor MogrifyImageCommand$descriptor() {
        return MogrifyImageCommand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MogrifyImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle MogrifyImageCommand$handle() {
        return MogrifyImageCommand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MogrifyImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment MogrifyImageCommand$address() {
        return MogrifyImageCommand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MogrifyImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static int MogrifyImageCommand(MemorySegment image_info, int argc, MemorySegment argv, MemorySegment metadata, MemorySegment exception) {
        var mh$ = MogrifyImageCommand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MogrifyImageCommand", image_info, argc, argv, metadata, exception);
            }
            return (int)mh$.invokeExact(image_info, argc, argv, metadata, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MogrifyImages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MogrifyImages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MogrifyImages(const ImageInfo *, int, char **, Image **)
     * }
     */
    public static FunctionDescriptor MogrifyImages$descriptor() {
        return MogrifyImages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MogrifyImages(const ImageInfo *, int, char **, Image **)
     * }
     */
    public static MethodHandle MogrifyImages$handle() {
        return MogrifyImages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MogrifyImages(const ImageInfo *, int, char **, Image **)
     * }
     */
    public static MemorySegment MogrifyImages$address() {
        return MogrifyImages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MogrifyImages(const ImageInfo *, int, char **, Image **)
     * }
     */
    public static int MogrifyImages(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = MogrifyImages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MogrifyImages", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MontageImageCommand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MontageImageCommand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MontageImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor MontageImageCommand$descriptor() {
        return MontageImageCommand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MontageImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle MontageImageCommand$handle() {
        return MontageImageCommand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MontageImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment MontageImageCommand$address() {
        return MontageImageCommand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MontageImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static int MontageImageCommand(MemorySegment image_info, int argc, MemorySegment argv, MemorySegment metadata, MemorySegment exception) {
        var mh$ = MontageImageCommand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MontageImageCommand", image_info, argc, argv, metadata, exception);
            }
            return (int)mh$.invokeExact(image_info, argc, argv, metadata, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeImageCommand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("TimeImageCommand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int TimeImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor TimeImageCommand$descriptor() {
        return TimeImageCommand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int TimeImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle TimeImageCommand$handle() {
        return TimeImageCommand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int TimeImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment TimeImageCommand$address() {
        return TimeImageCommand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int TimeImageCommand(ImageInfo *image_info, int argc, char **argv, char **metadata, ExceptionInfo *exception)
     * }
     */
    public static int TimeImageCommand(MemorySegment image_info, int argc, MemorySegment argv, MemorySegment metadata, MemorySegment exception) {
        var mh$ = TimeImageCommand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeImageCommand", image_info, argc, argv, metadata, exception);
            }
            return (int)mh$.invokeExact(image_info, argc, argv, metadata, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GMCommand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GMCommand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int GMCommand(int argc, char **argv)
     * }
     */
    public static FunctionDescriptor GMCommand$descriptor() {
        return GMCommand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int GMCommand(int argc, char **argv)
     * }
     */
    public static MethodHandle GMCommand$handle() {
        return GMCommand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int GMCommand(int argc, char **argv)
     * }
     */
    public static MemorySegment GMCommand$address() {
        return GMCommand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int GMCommand(int argc, char **argv)
     * }
     */
    public static int GMCommand(int argc, MemorySegment argv) {
        var mh$ = GMCommand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GMCommand", argc, argv);
            }
            return (int)mh$.invokeExact(argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UndefinedHighlightStyle = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedHighlightStyle = 0
     * }
     */
    public static int UndefinedHighlightStyle() {
        return UndefinedHighlightStyle;
    }
    private static final int AssignHighlightStyle = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AssignHighlightStyle = 1
     * }
     */
    public static int AssignHighlightStyle() {
        return AssignHighlightStyle;
    }
    private static final int ThresholdHighlightStyle = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ThresholdHighlightStyle = 2
     * }
     */
    public static int ThresholdHighlightStyle() {
        return ThresholdHighlightStyle;
    }
    private static final int TintHighlightStyle = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TintHighlightStyle = 3
     * }
     */
    public static int TintHighlightStyle() {
        return TintHighlightStyle;
    }
    private static final int XorHighlightStyle = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.XorHighlightStyle = 4
     * }
     */
    public static int XorHighlightStyle() {
        return XorHighlightStyle;
    }

    private static class InitializeDifferenceImageOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("InitializeDifferenceImageOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void InitializeDifferenceImageOptions(DifferenceImageOptions *options, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor InitializeDifferenceImageOptions$descriptor() {
        return InitializeDifferenceImageOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void InitializeDifferenceImageOptions(DifferenceImageOptions *options, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle InitializeDifferenceImageOptions$handle() {
        return InitializeDifferenceImageOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void InitializeDifferenceImageOptions(DifferenceImageOptions *options, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment InitializeDifferenceImageOptions$address() {
        return InitializeDifferenceImageOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void InitializeDifferenceImageOptions(DifferenceImageOptions *options, ExceptionInfo *exception)
     * }
     */
    public static void InitializeDifferenceImageOptions(MemorySegment options, MemorySegment exception) {
        var mh$ = InitializeDifferenceImageOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeDifferenceImageOptions", options, exception);
            }
            mh$.invokeExact(options, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DifferenceImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DifferenceImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *DifferenceImage(const Image *reference_image, const Image *compare_image, const DifferenceImageOptions *difference_options, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor DifferenceImage$descriptor() {
        return DifferenceImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *DifferenceImage(const Image *reference_image, const Image *compare_image, const DifferenceImageOptions *difference_options, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle DifferenceImage$handle() {
        return DifferenceImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *DifferenceImage(const Image *reference_image, const Image *compare_image, const DifferenceImageOptions *difference_options, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment DifferenceImage$address() {
        return DifferenceImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *DifferenceImage(const Image *reference_image, const Image *compare_image, const DifferenceImageOptions *difference_options, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment DifferenceImage(MemorySegment reference_image, MemorySegment compare_image, MemorySegment difference_options, MemorySegment exception) {
        var mh$ = DifferenceImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DifferenceImage", reference_image, compare_image, difference_options, exception);
            }
            return (MemorySegment)mh$.invokeExact(reference_image, compare_image, difference_options, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UndefinedMetric = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedMetric = 0
     * }
     */
    public static int UndefinedMetric() {
        return UndefinedMetric;
    }
    private static final int MeanAbsoluteErrorMetric = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MeanAbsoluteErrorMetric = 1
     * }
     */
    public static int MeanAbsoluteErrorMetric() {
        return MeanAbsoluteErrorMetric;
    }
    private static final int MeanSquaredErrorMetric = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MeanSquaredErrorMetric = 2
     * }
     */
    public static int MeanSquaredErrorMetric() {
        return MeanSquaredErrorMetric;
    }
    private static final int PeakAbsoluteErrorMetric = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PeakAbsoluteErrorMetric = 3
     * }
     */
    public static int PeakAbsoluteErrorMetric() {
        return PeakAbsoluteErrorMetric;
    }
    private static final int PeakSignalToNoiseRatioMetric = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PeakSignalToNoiseRatioMetric = 4
     * }
     */
    public static int PeakSignalToNoiseRatioMetric() {
        return PeakSignalToNoiseRatioMetric;
    }
    private static final int RootMeanSquaredErrorMetric = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RootMeanSquaredErrorMetric = 5
     * }
     */
    public static int RootMeanSquaredErrorMetric() {
        return RootMeanSquaredErrorMetric;
    }

    private static class InitializeDifferenceStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("InitializeDifferenceStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void InitializeDifferenceStatistics(DifferenceStatistics *difference_statistics, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor InitializeDifferenceStatistics$descriptor() {
        return InitializeDifferenceStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void InitializeDifferenceStatistics(DifferenceStatistics *difference_statistics, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle InitializeDifferenceStatistics$handle() {
        return InitializeDifferenceStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void InitializeDifferenceStatistics(DifferenceStatistics *difference_statistics, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment InitializeDifferenceStatistics$address() {
        return InitializeDifferenceStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void InitializeDifferenceStatistics(DifferenceStatistics *difference_statistics, ExceptionInfo *exception)
     * }
     */
    public static void InitializeDifferenceStatistics(MemorySegment difference_statistics, MemorySegment exception) {
        var mh$ = InitializeDifferenceStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeDifferenceStatistics", difference_statistics, exception);
            }
            mh$.invokeExact(difference_statistics, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageChannelDifference {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageChannelDifference");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int GetImageChannelDifference(const Image *reference_image, const Image *compare_image, const MetricType metric, DifferenceStatistics *statistics, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetImageChannelDifference$descriptor() {
        return GetImageChannelDifference.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int GetImageChannelDifference(const Image *reference_image, const Image *compare_image, const MetricType metric, DifferenceStatistics *statistics, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetImageChannelDifference$handle() {
        return GetImageChannelDifference.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int GetImageChannelDifference(const Image *reference_image, const Image *compare_image, const MetricType metric, DifferenceStatistics *statistics, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetImageChannelDifference$address() {
        return GetImageChannelDifference.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int GetImageChannelDifference(const Image *reference_image, const Image *compare_image, const MetricType metric, DifferenceStatistics *statistics, ExceptionInfo *exception)
     * }
     */
    public static int GetImageChannelDifference(MemorySegment reference_image, MemorySegment compare_image, int metric, MemorySegment statistics, MemorySegment exception) {
        var mh$ = GetImageChannelDifference.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageChannelDifference", reference_image, compare_image, metric, statistics, exception);
            }
            return (int)mh$.invokeExact(reference_image, compare_image, metric, statistics, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageChannelDistortion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageChannelDistortion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int GetImageChannelDistortion(const Image *reference_image, const Image *compare_image, const ChannelType channel, const MetricType metric, double *distortion, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetImageChannelDistortion$descriptor() {
        return GetImageChannelDistortion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int GetImageChannelDistortion(const Image *reference_image, const Image *compare_image, const ChannelType channel, const MetricType metric, double *distortion, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetImageChannelDistortion$handle() {
        return GetImageChannelDistortion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int GetImageChannelDistortion(const Image *reference_image, const Image *compare_image, const ChannelType channel, const MetricType metric, double *distortion, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetImageChannelDistortion$address() {
        return GetImageChannelDistortion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int GetImageChannelDistortion(const Image *reference_image, const Image *compare_image, const ChannelType channel, const MetricType metric, double *distortion, ExceptionInfo *exception)
     * }
     */
    public static int GetImageChannelDistortion(MemorySegment reference_image, MemorySegment compare_image, int channel, int metric, MemorySegment distortion, MemorySegment exception) {
        var mh$ = GetImageChannelDistortion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageChannelDistortion", reference_image, compare_image, channel, metric, distortion, exception);
            }
            return (int)mh$.invokeExact(reference_image, compare_image, channel, metric, distortion, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageDistortion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageDistortion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int GetImageDistortion(const Image *reference_image, const Image *compare_image, const MetricType metric, double *distortion, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetImageDistortion$descriptor() {
        return GetImageDistortion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int GetImageDistortion(const Image *reference_image, const Image *compare_image, const MetricType metric, double *distortion, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetImageDistortion$handle() {
        return GetImageDistortion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int GetImageDistortion(const Image *reference_image, const Image *compare_image, const MetricType metric, double *distortion, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetImageDistortion$address() {
        return GetImageDistortion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int GetImageDistortion(const Image *reference_image, const Image *compare_image, const MetricType metric, double *distortion, ExceptionInfo *exception)
     * }
     */
    public static int GetImageDistortion(MemorySegment reference_image, MemorySegment compare_image, int metric, MemorySegment distortion, MemorySegment exception) {
        var mh$ = GetImageDistortion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageDistortion", reference_image, compare_image, metric, distortion, exception);
            }
            return (int)mh$.invokeExact(reference_image, compare_image, metric, distortion, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsImagesEqual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IsImagesEqual");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IsImagesEqual(Image *, const Image *)
     * }
     */
    public static FunctionDescriptor IsImagesEqual$descriptor() {
        return IsImagesEqual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IsImagesEqual(Image *, const Image *)
     * }
     */
    public static MethodHandle IsImagesEqual$handle() {
        return IsImagesEqual.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IsImagesEqual(Image *, const Image *)
     * }
     */
    public static MemorySegment IsImagesEqual$address() {
        return IsImagesEqual.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IsImagesEqual(Image *, const Image *)
     * }
     */
    public static int IsImagesEqual(MemorySegment x0, MemorySegment x1) {
        var mh$ = IsImagesEqual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsImagesEqual", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompositeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CompositeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int CompositeImage(Image *canvas_image, const CompositeOperator compose, const Image *update_image, const long x_offset, const long y_offset)
     * }
     */
    public static FunctionDescriptor CompositeImage$descriptor() {
        return CompositeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int CompositeImage(Image *canvas_image, const CompositeOperator compose, const Image *update_image, const long x_offset, const long y_offset)
     * }
     */
    public static MethodHandle CompositeImage$handle() {
        return CompositeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int CompositeImage(Image *canvas_image, const CompositeOperator compose, const Image *update_image, const long x_offset, const long y_offset)
     * }
     */
    public static MemorySegment CompositeImage$address() {
        return CompositeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int CompositeImage(Image *canvas_image, const CompositeOperator compose, const Image *update_image, const long x_offset, const long y_offset)
     * }
     */
    public static int CompositeImage(MemorySegment canvas_image, int compose, MemorySegment update_image, long x_offset, long y_offset) {
        var mh$ = CompositeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompositeImage", canvas_image, compose, update_image, x_offset, y_offset);
            }
            return (int)mh$.invokeExact(canvas_image, compose, update_image, x_offset, y_offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompositeImageRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CompositeImageRegion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int CompositeImageRegion(const CompositeOperator compose, const CompositeOptions_t *options, const unsigned long columns, const unsigned long rows, const Image *update_image, const long update_x, const long update_y, Image *canvas_image, const long canvas_x, const long canvas_y, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor CompositeImageRegion$descriptor() {
        return CompositeImageRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int CompositeImageRegion(const CompositeOperator compose, const CompositeOptions_t *options, const unsigned long columns, const unsigned long rows, const Image *update_image, const long update_x, const long update_y, Image *canvas_image, const long canvas_x, const long canvas_y, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle CompositeImageRegion$handle() {
        return CompositeImageRegion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int CompositeImageRegion(const CompositeOperator compose, const CompositeOptions_t *options, const unsigned long columns, const unsigned long rows, const Image *update_image, const long update_x, const long update_y, Image *canvas_image, const long canvas_x, const long canvas_y, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment CompositeImageRegion$address() {
        return CompositeImageRegion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int CompositeImageRegion(const CompositeOperator compose, const CompositeOptions_t *options, const unsigned long columns, const unsigned long rows, const Image *update_image, const long update_x, const long update_y, Image *canvas_image, const long canvas_x, const long canvas_y, ExceptionInfo *exception)
     * }
     */
    public static int CompositeImageRegion(int compose, MemorySegment options, long columns, long rows, MemorySegment update_image, long update_x, long update_y, MemorySegment canvas_image, long canvas_x, long canvas_y, MemorySegment exception) {
        var mh$ = CompositeImageRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompositeImageRegion", compose, options, columns, rows, update_image, update_x, update_y, canvas_image, canvas_x, canvas_y, exception);
            }
            return (int)mh$.invokeExact(compose, options, columns, rows, update_image, update_x, update_y, canvas_image, canvas_x, canvas_y, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickCompositeImageUnderColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickCompositeImageUnderColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MagickCompositeImageUnderColor(Image *image, const PixelPacket *undercolor, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor MagickCompositeImageUnderColor$descriptor() {
        return MagickCompositeImageUnderColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MagickCompositeImageUnderColor(Image *image, const PixelPacket *undercolor, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle MagickCompositeImageUnderColor$handle() {
        return MagickCompositeImageUnderColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MagickCompositeImageUnderColor(Image *image, const PixelPacket *undercolor, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment MagickCompositeImageUnderColor$address() {
        return MagickCompositeImageUnderColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MagickCompositeImageUnderColor(Image *image, const PixelPacket *undercolor, ExceptionInfo *exception)
     * }
     */
    public static int MagickCompositeImageUnderColor(MemorySegment image, MemorySegment undercolor, MemorySegment exception) {
        var mh$ = MagickCompositeImageUnderColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickCompositeImageUnderColor", image, undercolor, exception);
            }
            return (int)mh$.invokeExact(image, undercolor, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Ascii85WriteByteHook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_CHAR,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("Ascii85WriteByteHook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int Ascii85WriteByteHook(Image *image, const magick_uint8_t code, void *info)
     * }
     */
    public static FunctionDescriptor Ascii85WriteByteHook$descriptor() {
        return Ascii85WriteByteHook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int Ascii85WriteByteHook(Image *image, const magick_uint8_t code, void *info)
     * }
     */
    public static MethodHandle Ascii85WriteByteHook$handle() {
        return Ascii85WriteByteHook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int Ascii85WriteByteHook(Image *image, const magick_uint8_t code, void *info)
     * }
     */
    public static MemorySegment Ascii85WriteByteHook$address() {
        return Ascii85WriteByteHook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int Ascii85WriteByteHook(Image *image, const magick_uint8_t code, void *info)
     * }
     */
    public static int Ascii85WriteByteHook(MemorySegment image, byte code, MemorySegment info) {
        var mh$ = Ascii85WriteByteHook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Ascii85WriteByteHook", image, code, info);
            }
            return (int)mh$.invokeExact(image, code, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BlobWriteByteHook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_CHAR,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("BlobWriteByteHook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int BlobWriteByteHook(Image *image, const magick_uint8_t code, void *info)
     * }
     */
    public static FunctionDescriptor BlobWriteByteHook$descriptor() {
        return BlobWriteByteHook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int BlobWriteByteHook(Image *image, const magick_uint8_t code, void *info)
     * }
     */
    public static MethodHandle BlobWriteByteHook$handle() {
        return BlobWriteByteHook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int BlobWriteByteHook(Image *image, const magick_uint8_t code, void *info)
     * }
     */
    public static MemorySegment BlobWriteByteHook$address() {
        return BlobWriteByteHook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int BlobWriteByteHook(Image *image, const magick_uint8_t code, void *info)
     * }
     */
    public static int BlobWriteByteHook(MemorySegment image, byte code, MemorySegment info) {
        var mh$ = BlobWriteByteHook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BlobWriteByteHook", image, code, info);
            }
            return (int)mh$.invokeExact(image, code, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HuffmanDecodeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("HuffmanDecodeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int HuffmanDecodeImage(Image *image)
     * }
     */
    public static FunctionDescriptor HuffmanDecodeImage$descriptor() {
        return HuffmanDecodeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int HuffmanDecodeImage(Image *image)
     * }
     */
    public static MethodHandle HuffmanDecodeImage$handle() {
        return HuffmanDecodeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int HuffmanDecodeImage(Image *image)
     * }
     */
    public static MemorySegment HuffmanDecodeImage$address() {
        return HuffmanDecodeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int HuffmanDecodeImage(Image *image)
     * }
     */
    public static int HuffmanDecodeImage(MemorySegment image) {
        var mh$ = HuffmanDecodeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HuffmanDecodeImage", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HuffmanEncodeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("HuffmanEncodeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int HuffmanEncodeImage(const ImageInfo *image_info, Image *image)
     * }
     */
    public static FunctionDescriptor HuffmanEncodeImage$descriptor() {
        return HuffmanEncodeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int HuffmanEncodeImage(const ImageInfo *image_info, Image *image)
     * }
     */
    public static MethodHandle HuffmanEncodeImage$handle() {
        return HuffmanEncodeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int HuffmanEncodeImage(const ImageInfo *image_info, Image *image)
     * }
     */
    public static MemorySegment HuffmanEncodeImage$address() {
        return HuffmanEncodeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int HuffmanEncodeImage(const ImageInfo *image_info, Image *image)
     * }
     */
    public static int HuffmanEncodeImage(MemorySegment image_info, MemorySegment image) {
        var mh$ = HuffmanEncodeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HuffmanEncodeImage", image_info, image);
            }
            return (int)mh$.invokeExact(image_info, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HuffmanEncode2Image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("HuffmanEncode2Image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int HuffmanEncode2Image(const ImageInfo *image_info, Image *image, WriteByteHook write_byte, void *info)
     * }
     */
    public static FunctionDescriptor HuffmanEncode2Image$descriptor() {
        return HuffmanEncode2Image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int HuffmanEncode2Image(const ImageInfo *image_info, Image *image, WriteByteHook write_byte, void *info)
     * }
     */
    public static MethodHandle HuffmanEncode2Image$handle() {
        return HuffmanEncode2Image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int HuffmanEncode2Image(const ImageInfo *image_info, Image *image, WriteByteHook write_byte, void *info)
     * }
     */
    public static MemorySegment HuffmanEncode2Image$address() {
        return HuffmanEncode2Image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int HuffmanEncode2Image(const ImageInfo *image_info, Image *image, WriteByteHook write_byte, void *info)
     * }
     */
    public static int HuffmanEncode2Image(MemorySegment image_info, MemorySegment image, MemorySegment write_byte, MemorySegment info) {
        var mh$ = HuffmanEncode2Image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HuffmanEncode2Image", image_info, image, write_byte, info);
            }
            return (int)mh$.invokeExact(image_info, image, write_byte, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LZWEncodeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("LZWEncodeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int LZWEncodeImage(Image *image, const size_t length, magick_uint8_t *pixels)
     * }
     */
    public static FunctionDescriptor LZWEncodeImage$descriptor() {
        return LZWEncodeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int LZWEncodeImage(Image *image, const size_t length, magick_uint8_t *pixels)
     * }
     */
    public static MethodHandle LZWEncodeImage$handle() {
        return LZWEncodeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int LZWEncodeImage(Image *image, const size_t length, magick_uint8_t *pixels)
     * }
     */
    public static MemorySegment LZWEncodeImage$address() {
        return LZWEncodeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int LZWEncodeImage(Image *image, const size_t length, magick_uint8_t *pixels)
     * }
     */
    public static int LZWEncodeImage(MemorySegment image, long length, MemorySegment pixels) {
        var mh$ = LZWEncodeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LZWEncodeImage", image, length, pixels);
            }
            return (int)mh$.invokeExact(image, length, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LZWEncode2Image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("LZWEncode2Image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int LZWEncode2Image(Image *image, const size_t length, magick_uint8_t *pixels, WriteByteHook write_byte, void *info)
     * }
     */
    public static FunctionDescriptor LZWEncode2Image$descriptor() {
        return LZWEncode2Image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int LZWEncode2Image(Image *image, const size_t length, magick_uint8_t *pixels, WriteByteHook write_byte, void *info)
     * }
     */
    public static MethodHandle LZWEncode2Image$handle() {
        return LZWEncode2Image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int LZWEncode2Image(Image *image, const size_t length, magick_uint8_t *pixels, WriteByteHook write_byte, void *info)
     * }
     */
    public static MemorySegment LZWEncode2Image$address() {
        return LZWEncode2Image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int LZWEncode2Image(Image *image, const size_t length, magick_uint8_t *pixels, WriteByteHook write_byte, void *info)
     * }
     */
    public static int LZWEncode2Image(MemorySegment image, long length, MemorySegment pixels, MemorySegment write_byte, MemorySegment info) {
        var mh$ = LZWEncode2Image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LZWEncode2Image", image, length, pixels, write_byte, info);
            }
            return (int)mh$.invokeExact(image, length, pixels, write_byte, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PackbitsEncodeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PackbitsEncodeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int PackbitsEncodeImage(Image *image, const size_t length, magick_uint8_t *pixels)
     * }
     */
    public static FunctionDescriptor PackbitsEncodeImage$descriptor() {
        return PackbitsEncodeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int PackbitsEncodeImage(Image *image, const size_t length, magick_uint8_t *pixels)
     * }
     */
    public static MethodHandle PackbitsEncodeImage$handle() {
        return PackbitsEncodeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int PackbitsEncodeImage(Image *image, const size_t length, magick_uint8_t *pixels)
     * }
     */
    public static MemorySegment PackbitsEncodeImage$address() {
        return PackbitsEncodeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int PackbitsEncodeImage(Image *image, const size_t length, magick_uint8_t *pixels)
     * }
     */
    public static int PackbitsEncodeImage(MemorySegment image, long length, MemorySegment pixels) {
        var mh$ = PackbitsEncodeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PackbitsEncodeImage", image, length, pixels);
            }
            return (int)mh$.invokeExact(image, length, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PackbitsEncode2Image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PackbitsEncode2Image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int PackbitsEncode2Image(Image *image, const size_t length, magick_uint8_t *pixels, WriteByteHook write_byte, void *info)
     * }
     */
    public static FunctionDescriptor PackbitsEncode2Image$descriptor() {
        return PackbitsEncode2Image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int PackbitsEncode2Image(Image *image, const size_t length, magick_uint8_t *pixels, WriteByteHook write_byte, void *info)
     * }
     */
    public static MethodHandle PackbitsEncode2Image$handle() {
        return PackbitsEncode2Image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int PackbitsEncode2Image(Image *image, const size_t length, magick_uint8_t *pixels, WriteByteHook write_byte, void *info)
     * }
     */
    public static MemorySegment PackbitsEncode2Image$address() {
        return PackbitsEncode2Image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int PackbitsEncode2Image(Image *image, const size_t length, magick_uint8_t *pixels, WriteByteHook write_byte, void *info)
     * }
     */
    public static int PackbitsEncode2Image(MemorySegment image, long length, MemorySegment pixels, MemorySegment write_byte, MemorySegment info) {
        var mh$ = PackbitsEncode2Image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PackbitsEncode2Image", image, length, pixels, write_byte, info);
            }
            return (int)mh$.invokeExact(image, length, pixels, write_byte, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageToHuffman2DBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ImageToHuffman2DBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned char *ImageToHuffman2DBlob(const Image *image, const ImageInfo *image_info, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ImageToHuffman2DBlob$descriptor() {
        return ImageToHuffman2DBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned char *ImageToHuffman2DBlob(const Image *image, const ImageInfo *image_info, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ImageToHuffman2DBlob$handle() {
        return ImageToHuffman2DBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned char *ImageToHuffman2DBlob(const Image *image, const ImageInfo *image_info, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ImageToHuffman2DBlob$address() {
        return ImageToHuffman2DBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned char *ImageToHuffman2DBlob(const Image *image, const ImageInfo *image_info, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ImageToHuffman2DBlob(MemorySegment image, MemorySegment image_info, MemorySegment length, MemorySegment exception) {
        var mh$ = ImageToHuffman2DBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageToHuffman2DBlob", image, image_info, length, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, image_info, length, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageToJPEGBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ImageToJPEGBlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned char *ImageToJPEGBlob(const Image *image, const ImageInfo *image_info, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ImageToJPEGBlob$descriptor() {
        return ImageToJPEGBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned char *ImageToJPEGBlob(const Image *image, const ImageInfo *image_info, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ImageToJPEGBlob$handle() {
        return ImageToJPEGBlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned char *ImageToJPEGBlob(const Image *image, const ImageInfo *image_info, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ImageToJPEGBlob$address() {
        return ImageToJPEGBlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned char *ImageToJPEGBlob(const Image *image, const ImageInfo *image_info, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ImageToJPEGBlob(MemorySegment image, MemorySegment image_info, MemorySegment length, MemorySegment exception) {
        var mh$ = ImageToJPEGBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageToJPEGBlob", image, image_info, length, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, image_info, length, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Ascii85Encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_CHAR
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("Ascii85Encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void Ascii85Encode(Image *image, const magick_uint8_t code)
     * }
     */
    public static FunctionDescriptor Ascii85Encode$descriptor() {
        return Ascii85Encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void Ascii85Encode(Image *image, const magick_uint8_t code)
     * }
     */
    public static MethodHandle Ascii85Encode$handle() {
        return Ascii85Encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void Ascii85Encode(Image *image, const magick_uint8_t code)
     * }
     */
    public static MemorySegment Ascii85Encode$address() {
        return Ascii85Encode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void Ascii85Encode(Image *image, const magick_uint8_t code)
     * }
     */
    public static void Ascii85Encode(MemorySegment image, byte code) {
        var mh$ = Ascii85Encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Ascii85Encode", image, code);
            }
            mh$.invokeExact(image, code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Ascii85Flush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("Ascii85Flush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void Ascii85Flush(Image *image)
     * }
     */
    public static FunctionDescriptor Ascii85Flush$descriptor() {
        return Ascii85Flush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void Ascii85Flush(Image *image)
     * }
     */
    public static MethodHandle Ascii85Flush$handle() {
        return Ascii85Flush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void Ascii85Flush(Image *image)
     * }
     */
    public static MemorySegment Ascii85Flush$address() {
        return Ascii85Flush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void Ascii85Flush(Image *image)
     * }
     */
    public static void Ascii85Flush(MemorySegment image) {
        var mh$ = Ascii85Flush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Ascii85Flush", image);
            }
            mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Ascii85Initialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("Ascii85Initialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void Ascii85Initialize(Image *image)
     * }
     */
    public static FunctionDescriptor Ascii85Initialize$descriptor() {
        return Ascii85Initialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void Ascii85Initialize(Image *image)
     * }
     */
    public static MethodHandle Ascii85Initialize$handle() {
        return Ascii85Initialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void Ascii85Initialize(Image *image)
     * }
     */
    public static MemorySegment Ascii85Initialize$address() {
        return Ascii85Initialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void Ascii85Initialize(Image *image)
     * }
     */
    public static void Ascii85Initialize(MemorySegment image) {
        var mh$ = Ascii85Initialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Ascii85Initialize", image);
            }
            mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UndefinedConfirmAccessMode = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedConfirmAccessMode = 0
     * }
     */
    public static int UndefinedConfirmAccessMode() {
        return UndefinedConfirmAccessMode;
    }
    private static final int FileExecuteConfirmAccessMode = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FileExecuteConfirmAccessMode = 1
     * }
     */
    public static int FileExecuteConfirmAccessMode() {
        return FileExecuteConfirmAccessMode;
    }
    private static final int FileReadConfirmAccessMode = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FileReadConfirmAccessMode = 2
     * }
     */
    public static int FileReadConfirmAccessMode() {
        return FileReadConfirmAccessMode;
    }
    private static final int FileWriteConfirmAccessMode = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FileWriteConfirmAccessMode = 3
     * }
     */
    public static int FileWriteConfirmAccessMode() {
        return FileWriteConfirmAccessMode;
    }
    private static final int URLGetFTPConfirmAccessMode = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.URLGetFTPConfirmAccessMode = 4
     * }
     */
    public static int URLGetFTPConfirmAccessMode() {
        return URLGetFTPConfirmAccessMode;
    }
    private static final int URLGetFileConfirmAccessMode = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.URLGetFileConfirmAccessMode = 5
     * }
     */
    public static int URLGetFileConfirmAccessMode() {
        return URLGetFileConfirmAccessMode;
    }
    private static final int URLGetHTTPConfirmAccessMode = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.URLGetHTTPConfirmAccessMode = 6
     * }
     */
    public static int URLGetHTTPConfirmAccessMode() {
        return URLGetHTTPConfirmAccessMode;
    }

    private static class MagickConfirmAccess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickConfirmAccess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MagickConfirmAccess(const ConfirmAccessMode mode, const char *path, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor MagickConfirmAccess$descriptor() {
        return MagickConfirmAccess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MagickConfirmAccess(const ConfirmAccessMode mode, const char *path, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle MagickConfirmAccess$handle() {
        return MagickConfirmAccess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MagickConfirmAccess(const ConfirmAccessMode mode, const char *path, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment MagickConfirmAccess$address() {
        return MagickConfirmAccess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MagickConfirmAccess(const ConfirmAccessMode mode, const char *path, ExceptionInfo *exception)
     * }
     */
    public static int MagickConfirmAccess(int mode, MemorySegment path, MemorySegment exception) {
        var mh$ = MagickConfirmAccess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickConfirmAccess", mode, path, exception);
            }
            return (int)mh$.invokeExact(mode, path, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickSetConfirmAccessHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickSetConfirmAccessHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ConfirmAccessHandler MagickSetConfirmAccessHandler(ConfirmAccessHandler handler)
     * }
     */
    public static FunctionDescriptor MagickSetConfirmAccessHandler$descriptor() {
        return MagickSetConfirmAccessHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ConfirmAccessHandler MagickSetConfirmAccessHandler(ConfirmAccessHandler handler)
     * }
     */
    public static MethodHandle MagickSetConfirmAccessHandler$handle() {
        return MagickSetConfirmAccessHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ConfirmAccessHandler MagickSetConfirmAccessHandler(ConfirmAccessHandler handler)
     * }
     */
    public static MemorySegment MagickSetConfirmAccessHandler$address() {
        return MagickSetConfirmAccessHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ConfirmAccessHandler MagickSetConfirmAccessHandler(ConfirmAccessHandler handler)
     * }
     */
    public static MemorySegment MagickSetConfirmAccessHandler(MemorySegment handler) {
        var mh$ = MagickSetConfirmAccessHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickSetConfirmAccessHandler", handler);
            }
            return (MemorySegment)mh$.invokeExact(handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UndefinedQuantum = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedQuantum = 0
     * }
     */
    public static int UndefinedQuantum() {
        return UndefinedQuantum;
    }
    private static final int IndexQuantum = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IndexQuantum = 1
     * }
     */
    public static int IndexQuantum() {
        return IndexQuantum;
    }
    private static final int GrayQuantum = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GrayQuantum = 2
     * }
     */
    public static int GrayQuantum() {
        return GrayQuantum;
    }
    private static final int IndexAlphaQuantum = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IndexAlphaQuantum = 3
     * }
     */
    public static int IndexAlphaQuantum() {
        return IndexAlphaQuantum;
    }
    private static final int GrayAlphaQuantum = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GrayAlphaQuantum = 4
     * }
     */
    public static int GrayAlphaQuantum() {
        return GrayAlphaQuantum;
    }
    private static final int RedQuantum = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RedQuantum = 5
     * }
     */
    public static int RedQuantum() {
        return RedQuantum;
    }
    private static final int CyanQuantum = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CyanQuantum = 6
     * }
     */
    public static int CyanQuantum() {
        return CyanQuantum;
    }
    private static final int GreenQuantum = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GreenQuantum = 7
     * }
     */
    public static int GreenQuantum() {
        return GreenQuantum;
    }
    private static final int YellowQuantum = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.YellowQuantum = 8
     * }
     */
    public static int YellowQuantum() {
        return YellowQuantum;
    }
    private static final int BlueQuantum = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BlueQuantum = 9
     * }
     */
    public static int BlueQuantum() {
        return BlueQuantum;
    }
    private static final int MagentaQuantum = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MagentaQuantum = 10
     * }
     */
    public static int MagentaQuantum() {
        return MagentaQuantum;
    }
    private static final int AlphaQuantum = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AlphaQuantum = 11
     * }
     */
    public static int AlphaQuantum() {
        return AlphaQuantum;
    }
    private static final int BlackQuantum = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BlackQuantum = 12
     * }
     */
    public static int BlackQuantum() {
        return BlackQuantum;
    }
    private static final int RGBQuantum = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RGBQuantum = 13
     * }
     */
    public static int RGBQuantum() {
        return RGBQuantum;
    }
    private static final int RGBAQuantum = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RGBAQuantum = 14
     * }
     */
    public static int RGBAQuantum() {
        return RGBAQuantum;
    }
    private static final int CMYKQuantum = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CMYKQuantum = 15
     * }
     */
    public static int CMYKQuantum() {
        return CMYKQuantum;
    }
    private static final int CMYKAQuantum = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CMYKAQuantum = 16
     * }
     */
    public static int CMYKAQuantum() {
        return CMYKAQuantum;
    }
    private static final int CIEYQuantum = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CIEYQuantum = 17
     * }
     */
    public static int CIEYQuantum() {
        return CIEYQuantum;
    }
    private static final int CIEXYZQuantum = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CIEXYZQuantum = 18
     * }
     */
    public static int CIEXYZQuantum() {
        return CIEXYZQuantum;
    }
    private static final int UndefinedQuantumSampleType = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedQuantumSampleType = 0
     * }
     */
    public static int UndefinedQuantumSampleType() {
        return UndefinedQuantumSampleType;
    }
    private static final int UnsignedQuantumSampleType = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UnsignedQuantumSampleType = 1
     * }
     */
    public static int UnsignedQuantumSampleType() {
        return UnsignedQuantumSampleType;
    }
    private static final int FloatQuantumSampleType = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FloatQuantumSampleType = 2
     * }
     */
    public static int FloatQuantumSampleType() {
        return FloatQuantumSampleType;
    }
    private static final int CharPixel = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CharPixel = 0
     * }
     */
    public static int CharPixel() {
        return CharPixel;
    }
    private static final int ShortPixel = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ShortPixel = 1
     * }
     */
    public static int ShortPixel() {
        return ShortPixel;
    }
    private static final int IntegerPixel = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IntegerPixel = 2
     * }
     */
    public static int IntegerPixel() {
        return IntegerPixel;
    }
    private static final int LongPixel = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LongPixel = 3
     * }
     */
    public static int LongPixel() {
        return LongPixel;
    }
    private static final int FloatPixel = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FloatPixel = 4
     * }
     */
    public static int FloatPixel() {
        return FloatPixel;
    }
    private static final int DoublePixel = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DoublePixel = 5
     * }
     */
    public static int DoublePixel() {
        return DoublePixel;
    }

    private static class StorageTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StorageTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *StorageTypeToString(const StorageType storage_type)
     * }
     */
    public static FunctionDescriptor StorageTypeToString$descriptor() {
        return StorageTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *StorageTypeToString(const StorageType storage_type)
     * }
     */
    public static MethodHandle StorageTypeToString$handle() {
        return StorageTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *StorageTypeToString(const StorageType storage_type)
     * }
     */
    public static MemorySegment StorageTypeToString$address() {
        return StorageTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *StorageTypeToString(const StorageType storage_type)
     * }
     */
    public static MemorySegment StorageTypeToString(int storage_type) {
        var mh$ = StorageTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StorageTypeToString", storage_type);
            }
            return (MemorySegment)mh$.invokeExact(storage_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuantumSampleTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("QuantumSampleTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *QuantumSampleTypeToString(const QuantumSampleType sample_type)
     * }
     */
    public static FunctionDescriptor QuantumSampleTypeToString$descriptor() {
        return QuantumSampleTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *QuantumSampleTypeToString(const QuantumSampleType sample_type)
     * }
     */
    public static MethodHandle QuantumSampleTypeToString$handle() {
        return QuantumSampleTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *QuantumSampleTypeToString(const QuantumSampleType sample_type)
     * }
     */
    public static MemorySegment QuantumSampleTypeToString$address() {
        return QuantumSampleTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *QuantumSampleTypeToString(const QuantumSampleType sample_type)
     * }
     */
    public static MemorySegment QuantumSampleTypeToString(int sample_type) {
        var mh$ = QuantumSampleTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuantumSampleTypeToString", sample_type);
            }
            return (MemorySegment)mh$.invokeExact(sample_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuantumTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("QuantumTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *QuantumTypeToString(const QuantumType quantum_type)
     * }
     */
    public static FunctionDescriptor QuantumTypeToString$descriptor() {
        return QuantumTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *QuantumTypeToString(const QuantumType quantum_type)
     * }
     */
    public static MethodHandle QuantumTypeToString$handle() {
        return QuantumTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *QuantumTypeToString(const QuantumType quantum_type)
     * }
     */
    public static MemorySegment QuantumTypeToString$address() {
        return QuantumTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *QuantumTypeToString(const QuantumType quantum_type)
     * }
     */
    public static MemorySegment QuantumTypeToString(int quantum_type) {
        var mh$ = QuantumTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuantumTypeToString", quantum_type);
            }
            return (MemorySegment)mh$.invokeExact(quantum_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConstituteImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ConstituteImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ConstituteImage(const unsigned long width, const unsigned long height, const char *map, const StorageType type, const void *pixels, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ConstituteImage$descriptor() {
        return ConstituteImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ConstituteImage(const unsigned long width, const unsigned long height, const char *map, const StorageType type, const void *pixels, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ConstituteImage$handle() {
        return ConstituteImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ConstituteImage(const unsigned long width, const unsigned long height, const char *map, const StorageType type, const void *pixels, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ConstituteImage$address() {
        return ConstituteImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ConstituteImage(const unsigned long width, const unsigned long height, const char *map, const StorageType type, const void *pixels, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ConstituteImage(long width, long height, MemorySegment map, int type, MemorySegment pixels, MemorySegment exception) {
        var mh$ = ConstituteImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConstituteImage", width, height, map, type, pixels, exception);
            }
            return (MemorySegment)mh$.invokeExact(width, height, map, type, pixels, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConstituteTextureImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ConstituteTextureImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ConstituteTextureImage(const unsigned long columns, const unsigned long rows, const Image *texture, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ConstituteTextureImage$descriptor() {
        return ConstituteTextureImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ConstituteTextureImage(const unsigned long columns, const unsigned long rows, const Image *texture, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ConstituteTextureImage$handle() {
        return ConstituteTextureImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ConstituteTextureImage(const unsigned long columns, const unsigned long rows, const Image *texture, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ConstituteTextureImage$address() {
        return ConstituteTextureImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ConstituteTextureImage(const unsigned long columns, const unsigned long rows, const Image *texture, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ConstituteTextureImage(long columns, long rows, MemorySegment texture, MemorySegment exception) {
        var mh$ = ConstituteTextureImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConstituteTextureImage", columns, rows, texture, exception);
            }
            return (MemorySegment)mh$.invokeExact(columns, rows, texture, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PingImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PingImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *PingImage(const ImageInfo *image_info, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor PingImage$descriptor() {
        return PingImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *PingImage(const ImageInfo *image_info, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle PingImage$handle() {
        return PingImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *PingImage(const ImageInfo *image_info, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment PingImage$address() {
        return PingImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *PingImage(const ImageInfo *image_info, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment PingImage(MemorySegment image_info, MemorySegment exception) {
        var mh$ = PingImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PingImage", image_info, exception);
            }
            return (MemorySegment)mh$.invokeExact(image_info, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ReadImage(const ImageInfo *image_info, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ReadImage$descriptor() {
        return ReadImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ReadImage(const ImageInfo *image_info, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ReadImage$handle() {
        return ReadImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ReadImage(const ImageInfo *image_info, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ReadImage$address() {
        return ReadImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ReadImage(const ImageInfo *image_info, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ReadImage(MemorySegment image_info, MemorySegment exception) {
        var mh$ = ReadImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadImage", image_info, exception);
            }
            return (MemorySegment)mh$.invokeExact(image_info, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadInlineImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReadInlineImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ReadInlineImage(const ImageInfo *image_info, const char *content, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ReadInlineImage$descriptor() {
        return ReadInlineImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ReadInlineImage(const ImageInfo *image_info, const char *content, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ReadInlineImage$handle() {
        return ReadInlineImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ReadInlineImage(const ImageInfo *image_info, const char *content, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ReadInlineImage$address() {
        return ReadInlineImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ReadInlineImage(const ImageInfo *image_info, const char *content, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ReadInlineImage(MemorySegment image_info, MemorySegment content, MemorySegment exception) {
        var mh$ = ReadInlineImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadInlineImage", image_info, content, exception);
            }
            return (MemorySegment)mh$.invokeExact(image_info, content, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DispatchImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DispatchImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int DispatchImage(const Image *image, const long x_offset, const long y_offset, const unsigned long columns, const unsigned long rows, const char *map, const StorageType type, void *pixels, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor DispatchImage$descriptor() {
        return DispatchImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int DispatchImage(const Image *image, const long x_offset, const long y_offset, const unsigned long columns, const unsigned long rows, const char *map, const StorageType type, void *pixels, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle DispatchImage$handle() {
        return DispatchImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int DispatchImage(const Image *image, const long x_offset, const long y_offset, const unsigned long columns, const unsigned long rows, const char *map, const StorageType type, void *pixels, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment DispatchImage$address() {
        return DispatchImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int DispatchImage(const Image *image, const long x_offset, const long y_offset, const unsigned long columns, const unsigned long rows, const char *map, const StorageType type, void *pixels, ExceptionInfo *exception)
     * }
     */
    public static int DispatchImage(MemorySegment image, long x_offset, long y_offset, long columns, long rows, MemorySegment map, int type, MemorySegment pixels, MemorySegment exception) {
        var mh$ = DispatchImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DispatchImage", image, x_offset, y_offset, columns, rows, map, type, pixels, exception);
            }
            return (int)mh$.invokeExact(image, x_offset, y_offset, columns, rows, map, type, pixels, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportImagePixelArea {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ExportImagePixelArea");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ExportImagePixelArea(const Image *image, const QuantumType quantum_type, const unsigned int quantum_size, unsigned char *destination, const ExportPixelAreaOptions *options, ExportPixelAreaInfo *export_info)
     * }
     */
    public static FunctionDescriptor ExportImagePixelArea$descriptor() {
        return ExportImagePixelArea.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ExportImagePixelArea(const Image *image, const QuantumType quantum_type, const unsigned int quantum_size, unsigned char *destination, const ExportPixelAreaOptions *options, ExportPixelAreaInfo *export_info)
     * }
     */
    public static MethodHandle ExportImagePixelArea$handle() {
        return ExportImagePixelArea.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ExportImagePixelArea(const Image *image, const QuantumType quantum_type, const unsigned int quantum_size, unsigned char *destination, const ExportPixelAreaOptions *options, ExportPixelAreaInfo *export_info)
     * }
     */
    public static MemorySegment ExportImagePixelArea$address() {
        return ExportImagePixelArea.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ExportImagePixelArea(const Image *image, const QuantumType quantum_type, const unsigned int quantum_size, unsigned char *destination, const ExportPixelAreaOptions *options, ExportPixelAreaInfo *export_info)
     * }
     */
    public static int ExportImagePixelArea(MemorySegment image, int quantum_type, int quantum_size, MemorySegment destination, MemorySegment options, MemorySegment export_info) {
        var mh$ = ExportImagePixelArea.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportImagePixelArea", image, quantum_type, quantum_size, destination, options, export_info);
            }
            return (int)mh$.invokeExact(image, quantum_type, quantum_size, destination, options, export_info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportViewPixelArea {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ExportViewPixelArea");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ExportViewPixelArea(const ViewInfo *view, const QuantumType quantum_type, const unsigned int quantum_size, unsigned char *destination, const ExportPixelAreaOptions *options, ExportPixelAreaInfo *export_info)
     * }
     */
    public static FunctionDescriptor ExportViewPixelArea$descriptor() {
        return ExportViewPixelArea.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ExportViewPixelArea(const ViewInfo *view, const QuantumType quantum_type, const unsigned int quantum_size, unsigned char *destination, const ExportPixelAreaOptions *options, ExportPixelAreaInfo *export_info)
     * }
     */
    public static MethodHandle ExportViewPixelArea$handle() {
        return ExportViewPixelArea.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ExportViewPixelArea(const ViewInfo *view, const QuantumType quantum_type, const unsigned int quantum_size, unsigned char *destination, const ExportPixelAreaOptions *options, ExportPixelAreaInfo *export_info)
     * }
     */
    public static MemorySegment ExportViewPixelArea$address() {
        return ExportViewPixelArea.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ExportViewPixelArea(const ViewInfo *view, const QuantumType quantum_type, const unsigned int quantum_size, unsigned char *destination, const ExportPixelAreaOptions *options, ExportPixelAreaInfo *export_info)
     * }
     */
    public static int ExportViewPixelArea(MemorySegment view, int quantum_type, int quantum_size, MemorySegment destination, MemorySegment options, MemorySegment export_info) {
        var mh$ = ExportViewPixelArea.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportViewPixelArea", view, quantum_type, quantum_size, destination, options, export_info);
            }
            return (int)mh$.invokeExact(view, quantum_type, quantum_size, destination, options, export_info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImportImagePixelArea {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ImportImagePixelArea");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ImportImagePixelArea(Image *image, const QuantumType quantum_type, const unsigned int quantum_size, const unsigned char *source, const ImportPixelAreaOptions *options, ImportPixelAreaInfo *import_info)
     * }
     */
    public static FunctionDescriptor ImportImagePixelArea$descriptor() {
        return ImportImagePixelArea.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ImportImagePixelArea(Image *image, const QuantumType quantum_type, const unsigned int quantum_size, const unsigned char *source, const ImportPixelAreaOptions *options, ImportPixelAreaInfo *import_info)
     * }
     */
    public static MethodHandle ImportImagePixelArea$handle() {
        return ImportImagePixelArea.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ImportImagePixelArea(Image *image, const QuantumType quantum_type, const unsigned int quantum_size, const unsigned char *source, const ImportPixelAreaOptions *options, ImportPixelAreaInfo *import_info)
     * }
     */
    public static MemorySegment ImportImagePixelArea$address() {
        return ImportImagePixelArea.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ImportImagePixelArea(Image *image, const QuantumType quantum_type, const unsigned int quantum_size, const unsigned char *source, const ImportPixelAreaOptions *options, ImportPixelAreaInfo *import_info)
     * }
     */
    public static int ImportImagePixelArea(MemorySegment image, int quantum_type, int quantum_size, MemorySegment source, MemorySegment options, MemorySegment import_info) {
        var mh$ = ImportImagePixelArea.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImportImagePixelArea", image, quantum_type, quantum_size, source, options, import_info);
            }
            return (int)mh$.invokeExact(image, quantum_type, quantum_size, source, options, import_info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImportViewPixelArea {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ImportViewPixelArea");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ImportViewPixelArea(ViewInfo *view, const QuantumType quantum_type, const unsigned int quantum_size, const unsigned char *source, const ImportPixelAreaOptions *options, ImportPixelAreaInfo *import_info)
     * }
     */
    public static FunctionDescriptor ImportViewPixelArea$descriptor() {
        return ImportViewPixelArea.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ImportViewPixelArea(ViewInfo *view, const QuantumType quantum_type, const unsigned int quantum_size, const unsigned char *source, const ImportPixelAreaOptions *options, ImportPixelAreaInfo *import_info)
     * }
     */
    public static MethodHandle ImportViewPixelArea$handle() {
        return ImportViewPixelArea.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ImportViewPixelArea(ViewInfo *view, const QuantumType quantum_type, const unsigned int quantum_size, const unsigned char *source, const ImportPixelAreaOptions *options, ImportPixelAreaInfo *import_info)
     * }
     */
    public static MemorySegment ImportViewPixelArea$address() {
        return ImportViewPixelArea.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ImportViewPixelArea(ViewInfo *view, const QuantumType quantum_type, const unsigned int quantum_size, const unsigned char *source, const ImportPixelAreaOptions *options, ImportPixelAreaInfo *import_info)
     * }
     */
    public static int ImportViewPixelArea(MemorySegment view, int quantum_type, int quantum_size, MemorySegment source, MemorySegment options, MemorySegment import_info) {
        var mh$ = ImportViewPixelArea.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImportViewPixelArea", view, quantum_type, quantum_size, source, options, import_info);
            }
            return (int)mh$.invokeExact(view, quantum_type, quantum_size, source, options, import_info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WriteImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int WriteImage(const ImageInfo *image_info, Image *image)
     * }
     */
    public static FunctionDescriptor WriteImage$descriptor() {
        return WriteImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int WriteImage(const ImageInfo *image_info, Image *image)
     * }
     */
    public static MethodHandle WriteImage$handle() {
        return WriteImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int WriteImage(const ImageInfo *image_info, Image *image)
     * }
     */
    public static MemorySegment WriteImage$address() {
        return WriteImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int WriteImage(const ImageInfo *image_info, Image *image)
     * }
     */
    public static int WriteImage(MemorySegment image_info, MemorySegment image) {
        var mh$ = WriteImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteImage", image_info, image);
            }
            return (int)mh$.invokeExact(image_info, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteImages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WriteImages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int WriteImages(const ImageInfo *image_info, Image *image, const char *filename, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor WriteImages$descriptor() {
        return WriteImages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int WriteImages(const ImageInfo *image_info, Image *image, const char *filename, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle WriteImages$handle() {
        return WriteImages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int WriteImages(const ImageInfo *image_info, Image *image, const char *filename, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment WriteImages$address() {
        return WriteImages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int WriteImages(const ImageInfo *image_info, Image *image, const char *filename, ExceptionInfo *exception)
     * }
     */
    public static int WriteImages(MemorySegment image_info, MemorySegment image, MemorySegment filename, MemorySegment exception) {
        var mh$ = WriteImages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteImages", image_info, image, filename, exception);
            }
            return (int)mh$.invokeExact(image_info, image, filename, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteImagesFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WriteImagesFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int WriteImagesFile(const ImageInfo *image_info, Image *image, FILE *file, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor WriteImagesFile$descriptor() {
        return WriteImagesFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int WriteImagesFile(const ImageInfo *image_info, Image *image, FILE *file, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle WriteImagesFile$handle() {
        return WriteImagesFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int WriteImagesFile(const ImageInfo *image_info, Image *image, FILE *file, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment WriteImagesFile$address() {
        return WriteImagesFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int WriteImagesFile(const ImageInfo *image_info, Image *image, FILE *file, ExceptionInfo *exception)
     * }
     */
    public static int WriteImagesFile(MemorySegment image_info, MemorySegment image, MemorySegment file, MemorySegment exception) {
        var mh$ = WriteImagesFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteImagesFile", image_info, image, file, exception);
            }
            return (int)mh$.invokeExact(image_info, image, file, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExportPixelAreaOptionsInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ExportPixelAreaOptionsInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ExportPixelAreaOptionsInit(ExportPixelAreaOptions *options)
     * }
     */
    public static FunctionDescriptor ExportPixelAreaOptionsInit$descriptor() {
        return ExportPixelAreaOptionsInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ExportPixelAreaOptionsInit(ExportPixelAreaOptions *options)
     * }
     */
    public static MethodHandle ExportPixelAreaOptionsInit$handle() {
        return ExportPixelAreaOptionsInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ExportPixelAreaOptionsInit(ExportPixelAreaOptions *options)
     * }
     */
    public static MemorySegment ExportPixelAreaOptionsInit$address() {
        return ExportPixelAreaOptionsInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ExportPixelAreaOptionsInit(ExportPixelAreaOptions *options)
     * }
     */
    public static void ExportPixelAreaOptionsInit(MemorySegment options) {
        var mh$ = ExportPixelAreaOptionsInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExportPixelAreaOptionsInit", options);
            }
            mh$.invokeExact(options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImportPixelAreaOptionsInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ImportPixelAreaOptionsInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ImportPixelAreaOptionsInit(ImportPixelAreaOptions *options)
     * }
     */
    public static FunctionDescriptor ImportPixelAreaOptionsInit$descriptor() {
        return ImportPixelAreaOptionsInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ImportPixelAreaOptionsInit(ImportPixelAreaOptions *options)
     * }
     */
    public static MethodHandle ImportPixelAreaOptionsInit$handle() {
        return ImportPixelAreaOptionsInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ImportPixelAreaOptionsInit(ImportPixelAreaOptions *options)
     * }
     */
    public static MemorySegment ImportPixelAreaOptionsInit$address() {
        return ImportPixelAreaOptionsInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ImportPixelAreaOptionsInit(ImportPixelAreaOptions *options)
     * }
     */
    public static void ImportPixelAreaOptionsInit(MemorySegment options) {
        var mh$ = ImportPixelAreaOptionsInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImportPixelAreaOptionsInit", options);
            }
            mh$.invokeExact(options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickFindRawImageMinMax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickFindRawImageMinMax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MagickFindRawImageMinMax(Image *image, EndianType endian, unsigned long width, unsigned long height, StorageType type, unsigned int scanline_octets, void *scanline_buffer, double *min, double *max)
     * }
     */
    public static FunctionDescriptor MagickFindRawImageMinMax$descriptor() {
        return MagickFindRawImageMinMax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MagickFindRawImageMinMax(Image *image, EndianType endian, unsigned long width, unsigned long height, StorageType type, unsigned int scanline_octets, void *scanline_buffer, double *min, double *max)
     * }
     */
    public static MethodHandle MagickFindRawImageMinMax$handle() {
        return MagickFindRawImageMinMax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MagickFindRawImageMinMax(Image *image, EndianType endian, unsigned long width, unsigned long height, StorageType type, unsigned int scanline_octets, void *scanline_buffer, double *min, double *max)
     * }
     */
    public static MemorySegment MagickFindRawImageMinMax$address() {
        return MagickFindRawImageMinMax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MagickFindRawImageMinMax(Image *image, EndianType endian, unsigned long width, unsigned long height, StorageType type, unsigned int scanline_octets, void *scanline_buffer, double *min, double *max)
     * }
     */
    public static int MagickFindRawImageMinMax(MemorySegment image, int endian, long width, long height, int type, int scanline_octets, MemorySegment scanline_buffer, MemorySegment min, MemorySegment max) {
        var mh$ = MagickFindRawImageMinMax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickFindRawImageMinMax", image, endian, width, height, type, scanline_octets, scanline_buffer, min, max);
            }
            return (int)mh$.invokeExact(image, endian, width, height, type, scanline_octets, scanline_buffer, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetQuantumSamplesPerPixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetQuantumSamplesPerPixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MagickGetQuantumSamplesPerPixel(const QuantumType quantum_type)
     * }
     */
    public static FunctionDescriptor MagickGetQuantumSamplesPerPixel$descriptor() {
        return MagickGetQuantumSamplesPerPixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MagickGetQuantumSamplesPerPixel(const QuantumType quantum_type)
     * }
     */
    public static MethodHandle MagickGetQuantumSamplesPerPixel$handle() {
        return MagickGetQuantumSamplesPerPixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MagickGetQuantumSamplesPerPixel(const QuantumType quantum_type)
     * }
     */
    public static MemorySegment MagickGetQuantumSamplesPerPixel$address() {
        return MagickGetQuantumSamplesPerPixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MagickGetQuantumSamplesPerPixel(const QuantumType quantum_type)
     * }
     */
    public static int MagickGetQuantumSamplesPerPixel(int quantum_type) {
        var mh$ = MagickGetQuantumSamplesPerPixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetQuantumSamplesPerPixel", quantum_type);
            }
            return (int)mh$.invokeExact(quantum_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BorderImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("BorderImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *BorderImage(const Image *, const RectangleInfo *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor BorderImage$descriptor() {
        return BorderImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *BorderImage(const Image *, const RectangleInfo *, ExceptionInfo *)
     * }
     */
    public static MethodHandle BorderImage$handle() {
        return BorderImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *BorderImage(const Image *, const RectangleInfo *, ExceptionInfo *)
     * }
     */
    public static MemorySegment BorderImage$address() {
        return BorderImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *BorderImage(const Image *, const RectangleInfo *, ExceptionInfo *)
     * }
     */
    public static MemorySegment BorderImage(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = BorderImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BorderImage", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FrameImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("FrameImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *FrameImage(const Image *, const FrameInfo *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor FrameImage$descriptor() {
        return FrameImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *FrameImage(const Image *, const FrameInfo *, ExceptionInfo *)
     * }
     */
    public static MethodHandle FrameImage$handle() {
        return FrameImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *FrameImage(const Image *, const FrameInfo *, ExceptionInfo *)
     * }
     */
    public static MemorySegment FrameImage$address() {
        return FrameImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *FrameImage(const Image *, const FrameInfo *, ExceptionInfo *)
     * }
     */
    public static MemorySegment FrameImage(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = FrameImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FrameImage", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RaiseImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("RaiseImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int RaiseImage(Image *, const RectangleInfo *, const int)
     * }
     */
    public static FunctionDescriptor RaiseImage$descriptor() {
        return RaiseImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int RaiseImage(Image *, const RectangleInfo *, const int)
     * }
     */
    public static MethodHandle RaiseImage$handle() {
        return RaiseImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int RaiseImage(Image *, const RectangleInfo *, const int)
     * }
     */
    public static MemorySegment RaiseImage$address() {
        return RaiseImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int RaiseImage(Image *, const RectangleInfo *, const int)
     * }
     */
    public static int RaiseImage(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = RaiseImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RaiseImage", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDelegateCommand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetDelegateCommand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *GetDelegateCommand(const ImageInfo *image_info, Image *image, const char *decode, const char *encode, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetDelegateCommand$descriptor() {
        return GetDelegateCommand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *GetDelegateCommand(const ImageInfo *image_info, Image *image, const char *decode, const char *encode, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetDelegateCommand$handle() {
        return GetDelegateCommand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *GetDelegateCommand(const ImageInfo *image_info, Image *image, const char *decode, const char *encode, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetDelegateCommand$address() {
        return GetDelegateCommand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *GetDelegateCommand(const ImageInfo *image_info, Image *image, const char *decode, const char *encode, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetDelegateCommand(MemorySegment image_info, MemorySegment image, MemorySegment decode, MemorySegment encode, MemorySegment exception) {
        var mh$ = GetDelegateCommand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDelegateCommand", image_info, image, decode, encode, exception);
            }
            return (MemorySegment)mh$.invokeExact(image_info, image, decode, encode, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDelegateInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetDelegateInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const DelegateInfo *GetDelegateInfo(const char *decode, const char *encode, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetDelegateInfo$descriptor() {
        return GetDelegateInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const DelegateInfo *GetDelegateInfo(const char *decode, const char *encode, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetDelegateInfo$handle() {
        return GetDelegateInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const DelegateInfo *GetDelegateInfo(const char *decode, const char *encode, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetDelegateInfo$address() {
        return GetDelegateInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const DelegateInfo *GetDelegateInfo(const char *decode, const char *encode, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetDelegateInfo(MemorySegment decode, MemorySegment encode, MemorySegment exception) {
        var mh$ = GetDelegateInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDelegateInfo", decode, encode, exception);
            }
            return (MemorySegment)mh$.invokeExact(decode, encode, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPostscriptDelegateInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetPostscriptDelegateInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const DelegateInfo *GetPostscriptDelegateInfo(const ImageInfo *image_info, unsigned int *antialias, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetPostscriptDelegateInfo$descriptor() {
        return GetPostscriptDelegateInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const DelegateInfo *GetPostscriptDelegateInfo(const ImageInfo *image_info, unsigned int *antialias, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetPostscriptDelegateInfo$handle() {
        return GetPostscriptDelegateInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const DelegateInfo *GetPostscriptDelegateInfo(const ImageInfo *image_info, unsigned int *antialias, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetPostscriptDelegateInfo$address() {
        return GetPostscriptDelegateInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const DelegateInfo *GetPostscriptDelegateInfo(const ImageInfo *image_info, unsigned int *antialias, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetPostscriptDelegateInfo(MemorySegment image_info, MemorySegment antialias, MemorySegment exception) {
        var mh$ = GetPostscriptDelegateInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPostscriptDelegateInfo", image_info, antialias, exception);
            }
            return (MemorySegment)mh$.invokeExact(image_info, antialias, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDelegateInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetDelegateInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern DelegateInfo *SetDelegateInfo(DelegateInfo *)
     * }
     */
    public static FunctionDescriptor SetDelegateInfo$descriptor() {
        return SetDelegateInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern DelegateInfo *SetDelegateInfo(DelegateInfo *)
     * }
     */
    public static MethodHandle SetDelegateInfo$handle() {
        return SetDelegateInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern DelegateInfo *SetDelegateInfo(DelegateInfo *)
     * }
     */
    public static MemorySegment SetDelegateInfo$address() {
        return SetDelegateInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern DelegateInfo *SetDelegateInfo(DelegateInfo *)
     * }
     */
    public static MemorySegment SetDelegateInfo(MemorySegment x0) {
        var mh$ = SetDelegateInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDelegateInfo", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InvokePostscriptDelegate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("InvokePostscriptDelegate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int InvokePostscriptDelegate(const unsigned int verbose, const char *command, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor InvokePostscriptDelegate$descriptor() {
        return InvokePostscriptDelegate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int InvokePostscriptDelegate(const unsigned int verbose, const char *command, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle InvokePostscriptDelegate$handle() {
        return InvokePostscriptDelegate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int InvokePostscriptDelegate(const unsigned int verbose, const char *command, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment InvokePostscriptDelegate$address() {
        return InvokePostscriptDelegate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int InvokePostscriptDelegate(const unsigned int verbose, const char *command, ExceptionInfo *exception)
     * }
     */
    public static int InvokePostscriptDelegate(int verbose, MemorySegment command, MemorySegment exception) {
        var mh$ = InvokePostscriptDelegate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InvokePostscriptDelegate", verbose, command, exception);
            }
            return (int)mh$.invokeExact(verbose, command, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InvokeDelegate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("InvokeDelegate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int InvokeDelegate(ImageInfo *image_info, Image *image, const char *decode, const char *encode, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor InvokeDelegate$descriptor() {
        return InvokeDelegate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int InvokeDelegate(ImageInfo *image_info, Image *image, const char *decode, const char *encode, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle InvokeDelegate$handle() {
        return InvokeDelegate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int InvokeDelegate(ImageInfo *image_info, Image *image, const char *decode, const char *encode, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment InvokeDelegate$address() {
        return InvokeDelegate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int InvokeDelegate(ImageInfo *image_info, Image *image, const char *decode, const char *encode, ExceptionInfo *exception)
     * }
     */
    public static int InvokeDelegate(MemorySegment image_info, MemorySegment image, MemorySegment decode, MemorySegment encode, MemorySegment exception) {
        var mh$ = InvokeDelegate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InvokeDelegate", image_info, image, decode, encode, exception);
            }
            return (int)mh$.invokeExact(image_info, image, decode, encode, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ListDelegateInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ListDelegateInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ListDelegateInfo(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ListDelegateInfo$descriptor() {
        return ListDelegateInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ListDelegateInfo(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ListDelegateInfo$handle() {
        return ListDelegateInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ListDelegateInfo(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ListDelegateInfo$address() {
        return ListDelegateInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ListDelegateInfo(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static int ListDelegateInfo(MemorySegment file, MemorySegment exception) {
        var mh$ = ListDelegateInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ListDelegateInfo", file, exception);
            }
            return (int)mh$.invokeExact(file, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PopImagePixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PopImagePixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int PopImagePixels(const Image *, const QuantumType, unsigned char *)
     * }
     */
    public static FunctionDescriptor PopImagePixels$descriptor() {
        return PopImagePixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int PopImagePixels(const Image *, const QuantumType, unsigned char *)
     * }
     */
    public static MethodHandle PopImagePixels$handle() {
        return PopImagePixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int PopImagePixels(const Image *, const QuantumType, unsigned char *)
     * }
     */
    public static MemorySegment PopImagePixels$address() {
        return PopImagePixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int PopImagePixels(const Image *, const QuantumType, unsigned char *)
     * }
     */
    public static int PopImagePixels(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = PopImagePixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PopImagePixels", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PushImagePixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PushImagePixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int PushImagePixels(Image *, const QuantumType, const unsigned char *)
     * }
     */
    public static FunctionDescriptor PushImagePixels$descriptor() {
        return PushImagePixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int PushImagePixels(Image *, const QuantumType, const unsigned char *)
     * }
     */
    public static MethodHandle PushImagePixels$handle() {
        return PushImagePixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int PushImagePixels(Image *, const QuantumType, const unsigned char *)
     * }
     */
    public static MemorySegment PushImagePixels$address() {
        return PushImagePixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int PushImagePixels(Image *, const QuantumType, const unsigned char *)
     * }
     */
    public static int PushImagePixels(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = PushImagePixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PushImagePixels", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AcquireMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AcquireMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *AcquireMemory(const size_t)
     * }
     */
    public static FunctionDescriptor AcquireMemory$descriptor() {
        return AcquireMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *AcquireMemory(const size_t)
     * }
     */
    public static MethodHandle AcquireMemory$handle() {
        return AcquireMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *AcquireMemory(const size_t)
     * }
     */
    public static MemorySegment AcquireMemory$address() {
        return AcquireMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *AcquireMemory(const size_t)
     * }
     */
    public static MemorySegment AcquireMemory(long x0) {
        var mh$ = AcquireMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireMemory", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloneMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CloneMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *CloneMemory(void *, const void *, const size_t)
     * }
     */
    public static FunctionDescriptor CloneMemory$descriptor() {
        return CloneMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *CloneMemory(void *, const void *, const size_t)
     * }
     */
    public static MethodHandle CloneMemory$handle() {
        return CloneMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *CloneMemory(void *, const void *, const size_t)
     * }
     */
    public static MemorySegment CloneMemory$address() {
        return CloneMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *CloneMemory(void *, const void *, const size_t)
     * }
     */
    public static MemorySegment CloneMemory(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = CloneMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloneMemory", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LiberateMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("LiberateMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void LiberateMemory(void **)
     * }
     */
    public static FunctionDescriptor LiberateMemory$descriptor() {
        return LiberateMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void LiberateMemory(void **)
     * }
     */
    public static MethodHandle LiberateMemory$handle() {
        return LiberateMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void LiberateMemory(void **)
     * }
     */
    public static MemorySegment LiberateMemory$address() {
        return LiberateMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void LiberateMemory(void **)
     * }
     */
    public static void LiberateMemory(MemorySegment x0) {
        var mh$ = LiberateMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LiberateMemory", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReacquireMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReacquireMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ReacquireMemory(void **, const size_t)
     * }
     */
    public static FunctionDescriptor ReacquireMemory$descriptor() {
        return ReacquireMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ReacquireMemory(void **, const size_t)
     * }
     */
    public static MethodHandle ReacquireMemory$handle() {
        return ReacquireMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ReacquireMemory(void **, const size_t)
     * }
     */
    public static MemorySegment ReacquireMemory$address() {
        return ReacquireMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ReacquireMemory(void **, const size_t)
     * }
     */
    public static void ReacquireMemory(MemorySegment x0, long x1) {
        var mh$ = ReacquireMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReacquireMemory", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AcquireCacheView {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AcquireCacheView");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const PixelPacket *AcquireCacheView(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor AcquireCacheView$descriptor() {
        return AcquireCacheView.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const PixelPacket *AcquireCacheView(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle AcquireCacheView$handle() {
        return AcquireCacheView.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const PixelPacket *AcquireCacheView(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment AcquireCacheView$address() {
        return AcquireCacheView.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const PixelPacket *AcquireCacheView(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment AcquireCacheView(MemorySegment view, long x, long y, long columns, long rows, MemorySegment exception) {
        var mh$ = AcquireCacheView.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireCacheView", view, x, y, columns, rows, exception);
            }
            return (MemorySegment)mh$.invokeExact(view, x, y, columns, rows, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCacheView {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetCacheView");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelPacket *GetCacheView(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows)
     * }
     */
    public static FunctionDescriptor GetCacheView$descriptor() {
        return GetCacheView.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelPacket *GetCacheView(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows)
     * }
     */
    public static MethodHandle GetCacheView$handle() {
        return GetCacheView.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelPacket *GetCacheView(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows)
     * }
     */
    public static MemorySegment GetCacheView$address() {
        return GetCacheView.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelPacket *GetCacheView(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows)
     * }
     */
    public static MemorySegment GetCacheView(MemorySegment view, long x, long y, long columns, long rows) {
        var mh$ = GetCacheView.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCacheView", view, x, y, columns, rows);
            }
            return (MemorySegment)mh$.invokeExact(view, x, y, columns, rows);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCacheView {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetCacheView");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelPacket *SetCacheView(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows)
     * }
     */
    public static FunctionDescriptor SetCacheView$descriptor() {
        return SetCacheView.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelPacket *SetCacheView(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows)
     * }
     */
    public static MethodHandle SetCacheView$handle() {
        return SetCacheView.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelPacket *SetCacheView(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows)
     * }
     */
    public static MemorySegment SetCacheView$address() {
        return SetCacheView.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelPacket *SetCacheView(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows)
     * }
     */
    public static MemorySegment SetCacheView(MemorySegment view, long x, long y, long columns, long rows) {
        var mh$ = SetCacheView.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCacheView", view, x, y, columns, rows);
            }
            return (MemorySegment)mh$.invokeExact(view, x, y, columns, rows);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SyncCacheView {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SyncCacheView");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SyncCacheView(ViewInfo *view)
     * }
     */
    public static FunctionDescriptor SyncCacheView$descriptor() {
        return SyncCacheView.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SyncCacheView(ViewInfo *view)
     * }
     */
    public static MethodHandle SyncCacheView$handle() {
        return SyncCacheView.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SyncCacheView(ViewInfo *view)
     * }
     */
    public static MemorySegment SyncCacheView$address() {
        return SyncCacheView.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SyncCacheView(ViewInfo *view)
     * }
     */
    public static int SyncCacheView(MemorySegment view) {
        var mh$ = SyncCacheView.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SyncCacheView", view);
            }
            return (int)mh$.invokeExact(view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DescribeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DescribeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int DescribeImage(Image *image, FILE *file, const unsigned int verbose)
     * }
     */
    public static FunctionDescriptor DescribeImage$descriptor() {
        return DescribeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int DescribeImage(Image *image, FILE *file, const unsigned int verbose)
     * }
     */
    public static MethodHandle DescribeImage$handle() {
        return DescribeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int DescribeImage(Image *image, FILE *file, const unsigned int verbose)
     * }
     */
    public static MemorySegment DescribeImage$address() {
        return DescribeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int DescribeImage(Image *image, FILE *file, const unsigned int verbose)
     * }
     */
    public static int DescribeImage(MemorySegment image, MemorySegment file, int verbose) {
        var mh$ = DescribeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DescribeImage", image, file, verbose);
            }
            return (int)mh$.invokeExact(image, file, verbose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int NormalStretch = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NormalStretch = 0
     * }
     */
    public static int NormalStretch() {
        return NormalStretch;
    }
    private static final int UltraCondensedStretch = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UltraCondensedStretch = 1
     * }
     */
    public static int UltraCondensedStretch() {
        return UltraCondensedStretch;
    }
    private static final int ExtraCondensedStretch = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ExtraCondensedStretch = 2
     * }
     */
    public static int ExtraCondensedStretch() {
        return ExtraCondensedStretch;
    }
    private static final int CondensedStretch = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CondensedStretch = 3
     * }
     */
    public static int CondensedStretch() {
        return CondensedStretch;
    }
    private static final int SemiCondensedStretch = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SemiCondensedStretch = 4
     * }
     */
    public static int SemiCondensedStretch() {
        return SemiCondensedStretch;
    }
    private static final int SemiExpandedStretch = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SemiExpandedStretch = 5
     * }
     */
    public static int SemiExpandedStretch() {
        return SemiExpandedStretch;
    }
    private static final int ExpandedStretch = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ExpandedStretch = 6
     * }
     */
    public static int ExpandedStretch() {
        return ExpandedStretch;
    }
    private static final int ExtraExpandedStretch = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ExtraExpandedStretch = 7
     * }
     */
    public static int ExtraExpandedStretch() {
        return ExtraExpandedStretch;
    }
    private static final int UltraExpandedStretch = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UltraExpandedStretch = 8
     * }
     */
    public static int UltraExpandedStretch() {
        return UltraExpandedStretch;
    }
    private static final int AnyStretch = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AnyStretch = 9
     * }
     */
    public static int AnyStretch() {
        return AnyStretch;
    }
    private static final int NormalStyle = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NormalStyle = 0
     * }
     */
    public static int NormalStyle() {
        return NormalStyle;
    }
    private static final int ItalicStyle = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ItalicStyle = 1
     * }
     */
    public static int ItalicStyle() {
        return ItalicStyle;
    }
    private static final int ObliqueStyle = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ObliqueStyle = 2
     * }
     */
    public static int ObliqueStyle() {
        return ObliqueStyle;
    }
    private static final int AnyStyle = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AnyStyle = 3
     * }
     */
    public static int AnyStyle() {
        return AnyStyle;
    }

    private static class GetTypeList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetTypeList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char **GetTypeList(const char *, unsigned long *)
     * }
     */
    public static FunctionDescriptor GetTypeList$descriptor() {
        return GetTypeList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char **GetTypeList(const char *, unsigned long *)
     * }
     */
    public static MethodHandle GetTypeList$handle() {
        return GetTypeList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char **GetTypeList(const char *, unsigned long *)
     * }
     */
    public static MemorySegment GetTypeList$address() {
        return GetTypeList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char **GetTypeList(const char *, unsigned long *)
     * }
     */
    public static MemorySegment GetTypeList(MemorySegment x0, MemorySegment x1) {
        var mh$ = GetTypeList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTypeList", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ListTypeInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ListTypeInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ListTypeInfo(FILE *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor ListTypeInfo$descriptor() {
        return ListTypeInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ListTypeInfo(FILE *, ExceptionInfo *)
     * }
     */
    public static MethodHandle ListTypeInfo$handle() {
        return ListTypeInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ListTypeInfo(FILE *, ExceptionInfo *)
     * }
     */
    public static MemorySegment ListTypeInfo$address() {
        return ListTypeInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ListTypeInfo(FILE *, ExceptionInfo *)
     * }
     */
    public static int ListTypeInfo(MemorySegment x0, MemorySegment x1) {
        var mh$ = ListTypeInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ListTypeInfo", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTypeInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetTypeInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const TypeInfo *GetTypeInfo(const char *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor GetTypeInfo$descriptor() {
        return GetTypeInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const TypeInfo *GetTypeInfo(const char *, ExceptionInfo *)
     * }
     */
    public static MethodHandle GetTypeInfo$handle() {
        return GetTypeInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const TypeInfo *GetTypeInfo(const char *, ExceptionInfo *)
     * }
     */
    public static MemorySegment GetTypeInfo$address() {
        return GetTypeInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const TypeInfo *GetTypeInfo(const char *, ExceptionInfo *)
     * }
     */
    public static MemorySegment GetTypeInfo(MemorySegment x0, MemorySegment x1) {
        var mh$ = GetTypeInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTypeInfo", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTypeInfoByFamily {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetTypeInfoByFamily");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const TypeInfo *GetTypeInfoByFamily(const char *, const StyleType, const StretchType, const unsigned long, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor GetTypeInfoByFamily$descriptor() {
        return GetTypeInfoByFamily.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const TypeInfo *GetTypeInfoByFamily(const char *, const StyleType, const StretchType, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MethodHandle GetTypeInfoByFamily$handle() {
        return GetTypeInfoByFamily.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const TypeInfo *GetTypeInfoByFamily(const char *, const StyleType, const StretchType, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MemorySegment GetTypeInfoByFamily$address() {
        return GetTypeInfoByFamily.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const TypeInfo *GetTypeInfoByFamily(const char *, const StyleType, const StretchType, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MemorySegment GetTypeInfoByFamily(MemorySegment x0, int x1, int x2, long x3, MemorySegment x4) {
        var mh$ = GetTypeInfoByFamily.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTypeInfoByFamily", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UndefinedAlign = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedAlign = 0
     * }
     */
    public static int UndefinedAlign() {
        return UndefinedAlign;
    }
    private static final int LeftAlign = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LeftAlign = 1
     * }
     */
    public static int LeftAlign() {
        return LeftAlign;
    }
    private static final int CenterAlign = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CenterAlign = 2
     * }
     */
    public static int CenterAlign() {
        return CenterAlign;
    }
    private static final int RightAlign = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RightAlign = 3
     * }
     */
    public static int RightAlign() {
        return RightAlign;
    }
    private static final int UserSpace = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UserSpace = 0
     * }
     */
    public static int UserSpace() {
        return UserSpace;
    }
    private static final int UserSpaceOnUse = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UserSpaceOnUse = 1
     * }
     */
    public static int UserSpaceOnUse() {
        return UserSpaceOnUse;
    }
    private static final int ObjectBoundingBox = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ObjectBoundingBox = 2
     * }
     */
    public static int ObjectBoundingBox() {
        return ObjectBoundingBox;
    }
    private static final int NoDecoration = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NoDecoration = 0
     * }
     */
    public static int NoDecoration() {
        return NoDecoration;
    }
    private static final int UnderlineDecoration = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UnderlineDecoration = 1
     * }
     */
    public static int UnderlineDecoration() {
        return UnderlineDecoration;
    }
    private static final int OverlineDecoration = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OverlineDecoration = 2
     * }
     */
    public static int OverlineDecoration() {
        return OverlineDecoration;
    }
    private static final int LineThroughDecoration = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LineThroughDecoration = 3
     * }
     */
    public static int LineThroughDecoration() {
        return LineThroughDecoration;
    }
    private static final int UndefinedRule = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedRule = 0
     * }
     */
    public static int UndefinedRule() {
        return UndefinedRule;
    }
    private static final int EvenOddRule = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EvenOddRule = 1
     * }
     */
    public static int EvenOddRule() {
        return EvenOddRule;
    }
    private static final int NonZeroRule = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NonZeroRule = 2
     * }
     */
    public static int NonZeroRule() {
        return NonZeroRule;
    }
    private static final int UndefinedGradient = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedGradient = 0
     * }
     */
    public static int UndefinedGradient() {
        return UndefinedGradient;
    }
    private static final int LinearGradient = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LinearGradient = 1
     * }
     */
    public static int LinearGradient() {
        return LinearGradient;
    }
    private static final int RadialGradient = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RadialGradient = 2
     * }
     */
    public static int RadialGradient() {
        return RadialGradient;
    }
    private static final int UndefinedCap = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedCap = 0
     * }
     */
    public static int UndefinedCap() {
        return UndefinedCap;
    }
    private static final int ButtCap = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ButtCap = 1
     * }
     */
    public static int ButtCap() {
        return ButtCap;
    }
    private static final int RoundCap = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RoundCap = 2
     * }
     */
    public static int RoundCap() {
        return RoundCap;
    }
    private static final int SquareCap = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SquareCap = 3
     * }
     */
    public static int SquareCap() {
        return SquareCap;
    }
    private static final int UndefinedJoin = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedJoin = 0
     * }
     */
    public static int UndefinedJoin() {
        return UndefinedJoin;
    }
    private static final int MiterJoin = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MiterJoin = 1
     * }
     */
    public static int MiterJoin() {
        return MiterJoin;
    }
    private static final int RoundJoin = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RoundJoin = 2
     * }
     */
    public static int RoundJoin() {
        return RoundJoin;
    }
    private static final int BevelJoin = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BevelJoin = 3
     * }
     */
    public static int BevelJoin() {
        return BevelJoin;
    }
    private static final int PointMethod = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PointMethod = 0
     * }
     */
    public static int PointMethod() {
        return PointMethod;
    }
    private static final int ReplaceMethod = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ReplaceMethod = 1
     * }
     */
    public static int ReplaceMethod() {
        return ReplaceMethod;
    }
    private static final int FloodfillMethod = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FloodfillMethod = 2
     * }
     */
    public static int FloodfillMethod() {
        return FloodfillMethod;
    }
    private static final int FillToBorderMethod = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FillToBorderMethod = 3
     * }
     */
    public static int FillToBorderMethod() {
        return FillToBorderMethod;
    }
    private static final int ResetMethod = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ResetMethod = 4
     * }
     */
    public static int ResetMethod() {
        return ResetMethod;
    }
    private static final int UndefinedPrimitive = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedPrimitive = 0
     * }
     */
    public static int UndefinedPrimitive() {
        return UndefinedPrimitive;
    }
    private static final int PointPrimitive = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PointPrimitive = 1
     * }
     */
    public static int PointPrimitive() {
        return PointPrimitive;
    }
    private static final int LinePrimitive = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LinePrimitive = 2
     * }
     */
    public static int LinePrimitive() {
        return LinePrimitive;
    }
    private static final int RectanglePrimitive = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RectanglePrimitive = 3
     * }
     */
    public static int RectanglePrimitive() {
        return RectanglePrimitive;
    }
    private static final int RoundRectanglePrimitive = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RoundRectanglePrimitive = 4
     * }
     */
    public static int RoundRectanglePrimitive() {
        return RoundRectanglePrimitive;
    }
    private static final int ArcPrimitive = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ArcPrimitive = 5
     * }
     */
    public static int ArcPrimitive() {
        return ArcPrimitive;
    }
    private static final int EllipsePrimitive = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EllipsePrimitive = 6
     * }
     */
    public static int EllipsePrimitive() {
        return EllipsePrimitive;
    }
    private static final int CirclePrimitive = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CirclePrimitive = 7
     * }
     */
    public static int CirclePrimitive() {
        return CirclePrimitive;
    }
    private static final int PolylinePrimitive = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PolylinePrimitive = 8
     * }
     */
    public static int PolylinePrimitive() {
        return PolylinePrimitive;
    }
    private static final int PolygonPrimitive = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PolygonPrimitive = 9
     * }
     */
    public static int PolygonPrimitive() {
        return PolygonPrimitive;
    }
    private static final int BezierPrimitive = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BezierPrimitive = 10
     * }
     */
    public static int BezierPrimitive() {
        return BezierPrimitive;
    }
    private static final int ColorPrimitive = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ColorPrimitive = 11
     * }
     */
    public static int ColorPrimitive() {
        return ColorPrimitive;
    }
    private static final int MattePrimitive = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MattePrimitive = 12
     * }
     */
    public static int MattePrimitive() {
        return MattePrimitive;
    }
    private static final int TextPrimitive = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TextPrimitive = 13
     * }
     */
    public static int TextPrimitive() {
        return TextPrimitive;
    }
    private static final int ImagePrimitive = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ImagePrimitive = 14
     * }
     */
    public static int ImagePrimitive() {
        return ImagePrimitive;
    }
    private static final int PathPrimitive = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PathPrimitive = 15
     * }
     */
    public static int PathPrimitive() {
        return PathPrimitive;
    }
    private static final int UndefinedReference = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedReference = 0
     * }
     */
    public static int UndefinedReference() {
        return UndefinedReference;
    }
    private static final int GradientReference = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GradientReference = 1
     * }
     */
    public static int GradientReference() {
        return GradientReference;
    }
    private static final int UndefinedSpread = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedSpread = 0
     * }
     */
    public static int UndefinedSpread() {
        return UndefinedSpread;
    }
    private static final int PadSpread = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PadSpread = 1
     * }
     */
    public static int PadSpread() {
        return PadSpread;
    }
    private static final int ReflectSpead = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ReflectSpead = 2
     * }
     */
    public static int ReflectSpead() {
        return ReflectSpead;
    }
    private static final int RepeatSpread = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RepeatSpread = 3
     * }
     */
    public static int RepeatSpread() {
        return RepeatSpread;
    }

    private static class CloneDrawInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CloneDrawInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern DrawInfo *CloneDrawInfo(const ImageInfo *, const DrawInfo *)
     * }
     */
    public static FunctionDescriptor CloneDrawInfo$descriptor() {
        return CloneDrawInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern DrawInfo *CloneDrawInfo(const ImageInfo *, const DrawInfo *)
     * }
     */
    public static MethodHandle CloneDrawInfo$handle() {
        return CloneDrawInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern DrawInfo *CloneDrawInfo(const ImageInfo *, const DrawInfo *)
     * }
     */
    public static MemorySegment CloneDrawInfo$address() {
        return CloneDrawInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern DrawInfo *CloneDrawInfo(const ImageInfo *, const DrawInfo *)
     * }
     */
    public static MemorySegment CloneDrawInfo(MemorySegment x0, MemorySegment x1) {
        var mh$ = CloneDrawInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloneDrawInfo", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnnotateImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AnnotateImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int AnnotateImage(Image *, const DrawInfo *)
     * }
     */
    public static FunctionDescriptor AnnotateImage$descriptor() {
        return AnnotateImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int AnnotateImage(Image *, const DrawInfo *)
     * }
     */
    public static MethodHandle AnnotateImage$handle() {
        return AnnotateImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int AnnotateImage(Image *, const DrawInfo *)
     * }
     */
    public static MemorySegment AnnotateImage$address() {
        return AnnotateImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int AnnotateImage(Image *, const DrawInfo *)
     * }
     */
    public static int AnnotateImage(MemorySegment x0, MemorySegment x1) {
        var mh$ = AnnotateImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnnotateImage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawAffineImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawAffineImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int DrawAffineImage(Image *, const Image *, const AffineMatrix *)
     * }
     */
    public static FunctionDescriptor DrawAffineImage$descriptor() {
        return DrawAffineImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int DrawAffineImage(Image *, const Image *, const AffineMatrix *)
     * }
     */
    public static MethodHandle DrawAffineImage$handle() {
        return DrawAffineImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int DrawAffineImage(Image *, const Image *, const AffineMatrix *)
     * }
     */
    public static MemorySegment DrawAffineImage$address() {
        return DrawAffineImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int DrawAffineImage(Image *, const Image *, const AffineMatrix *)
     * }
     */
    public static int DrawAffineImage(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = DrawAffineImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawAffineImage", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawClipPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawClipPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int DrawClipPath(Image *, const DrawInfo *, const char *)
     * }
     */
    public static FunctionDescriptor DrawClipPath$descriptor() {
        return DrawClipPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int DrawClipPath(Image *, const DrawInfo *, const char *)
     * }
     */
    public static MethodHandle DrawClipPath$handle() {
        return DrawClipPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int DrawClipPath(Image *, const DrawInfo *, const char *)
     * }
     */
    public static MemorySegment DrawClipPath$address() {
        return DrawClipPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int DrawClipPath(Image *, const DrawInfo *, const char *)
     * }
     */
    public static int DrawClipPath(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = DrawClipPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawClipPath", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int DrawImage(Image *, const DrawInfo *)
     * }
     */
    public static FunctionDescriptor DrawImage$descriptor() {
        return DrawImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int DrawImage(Image *, const DrawInfo *)
     * }
     */
    public static MethodHandle DrawImage$handle() {
        return DrawImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int DrawImage(Image *, const DrawInfo *)
     * }
     */
    public static MemorySegment DrawImage$address() {
        return DrawImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int DrawImage(Image *, const DrawInfo *)
     * }
     */
    public static int DrawImage(MemorySegment x0, MemorySegment x1) {
        var mh$ = DrawImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawImage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPatternPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPatternPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int DrawPatternPath(Image *, const DrawInfo *, const char *, Image **)
     * }
     */
    public static FunctionDescriptor DrawPatternPath$descriptor() {
        return DrawPatternPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int DrawPatternPath(Image *, const DrawInfo *, const char *, Image **)
     * }
     */
    public static MethodHandle DrawPatternPath$handle() {
        return DrawPatternPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int DrawPatternPath(Image *, const DrawInfo *, const char *, Image **)
     * }
     */
    public static MemorySegment DrawPatternPath$address() {
        return DrawPatternPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int DrawPatternPath(Image *, const DrawInfo *, const char *, Image **)
     * }
     */
    public static int DrawPatternPath(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DrawPatternPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPatternPath", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTypeMetrics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetTypeMetrics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int GetTypeMetrics(Image *, const DrawInfo *, TypeMetric *)
     * }
     */
    public static FunctionDescriptor GetTypeMetrics$descriptor() {
        return GetTypeMetrics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int GetTypeMetrics(Image *, const DrawInfo *, TypeMetric *)
     * }
     */
    public static MethodHandle GetTypeMetrics$handle() {
        return GetTypeMetrics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int GetTypeMetrics(Image *, const DrawInfo *, TypeMetric *)
     * }
     */
    public static MemorySegment GetTypeMetrics$address() {
        return GetTypeMetrics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int GetTypeMetrics(Image *, const DrawInfo *, TypeMetric *)
     * }
     */
    public static int GetTypeMetrics(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = GetTypeMetrics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTypeMetrics", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyDrawInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DestroyDrawInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DestroyDrawInfo(DrawInfo *)
     * }
     */
    public static FunctionDescriptor DestroyDrawInfo$descriptor() {
        return DestroyDrawInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DestroyDrawInfo(DrawInfo *)
     * }
     */
    public static MethodHandle DestroyDrawInfo$handle() {
        return DestroyDrawInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DestroyDrawInfo(DrawInfo *)
     * }
     */
    public static MemorySegment DestroyDrawInfo$address() {
        return DestroyDrawInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DestroyDrawInfo(DrawInfo *)
     * }
     */
    public static void DestroyDrawInfo(MemorySegment x0) {
        var mh$ = DestroyDrawInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyDrawInfo", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDrawInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetDrawInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void GetDrawInfo(const ImageInfo *, DrawInfo *)
     * }
     */
    public static FunctionDescriptor GetDrawInfo$descriptor() {
        return GetDrawInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void GetDrawInfo(const ImageInfo *, DrawInfo *)
     * }
     */
    public static MethodHandle GetDrawInfo$handle() {
        return GetDrawInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void GetDrawInfo(const ImageInfo *, DrawInfo *)
     * }
     */
    public static MemorySegment GetDrawInfo$address() {
        return GetDrawInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void GetDrawInfo(const ImageInfo *, DrawInfo *)
     * }
     */
    public static void GetDrawInfo(MemorySegment x0, MemorySegment x1) {
        var mh$ = GetDrawInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDrawInfo", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawInfoGetClipPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawInfoGetClipPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char **DrawInfoGetClipPath(const DrawInfo *)
     * }
     */
    public static FunctionDescriptor DrawInfoGetClipPath$descriptor() {
        return DrawInfoGetClipPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char **DrawInfoGetClipPath(const DrawInfo *)
     * }
     */
    public static MethodHandle DrawInfoGetClipPath$handle() {
        return DrawInfoGetClipPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char **DrawInfoGetClipPath(const DrawInfo *)
     * }
     */
    public static MemorySegment DrawInfoGetClipPath$address() {
        return DrawInfoGetClipPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char **DrawInfoGetClipPath(const DrawInfo *)
     * }
     */
    public static MemorySegment DrawInfoGetClipPath(MemorySegment x0) {
        var mh$ = DrawInfoGetClipPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawInfoGetClipPath", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawInfoGetCompositePath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawInfoGetCompositePath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char **DrawInfoGetCompositePath(const DrawInfo *)
     * }
     */
    public static FunctionDescriptor DrawInfoGetCompositePath$descriptor() {
        return DrawInfoGetCompositePath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char **DrawInfoGetCompositePath(const DrawInfo *)
     * }
     */
    public static MethodHandle DrawInfoGetCompositePath$handle() {
        return DrawInfoGetCompositePath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char **DrawInfoGetCompositePath(const DrawInfo *)
     * }
     */
    public static MemorySegment DrawInfoGetCompositePath$address() {
        return DrawInfoGetCompositePath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char **DrawInfoGetCompositePath(const DrawInfo *)
     * }
     */
    public static MemorySegment DrawInfoGetCompositePath(MemorySegment x0) {
        var mh$ = DrawInfoGetCompositePath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawInfoGetCompositePath", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _DrawContext *DrawContext
     * }
     */
    public static final AddressLayout DrawContext = magick_wand_h.C_POINTER;

    private static class DrawGetClipUnits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetClipUnits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ClipPathUnits DrawGetClipUnits(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetClipUnits$descriptor() {
        return DrawGetClipUnits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ClipPathUnits DrawGetClipUnits(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetClipUnits$handle() {
        return DrawGetClipUnits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ClipPathUnits DrawGetClipUnits(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetClipUnits$address() {
        return DrawGetClipUnits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ClipPathUnits DrawGetClipUnits(DrawContext context)
     * }
     */
    public static int DrawGetClipUnits(MemorySegment context) {
        var mh$ = DrawGetClipUnits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetClipUnits", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPeekGraphicContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPeekGraphicContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern DrawInfo *DrawPeekGraphicContext(const DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawPeekGraphicContext$descriptor() {
        return DrawPeekGraphicContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern DrawInfo *DrawPeekGraphicContext(const DrawContext context)
     * }
     */
    public static MethodHandle DrawPeekGraphicContext$handle() {
        return DrawPeekGraphicContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern DrawInfo *DrawPeekGraphicContext(const DrawContext context)
     * }
     */
    public static MemorySegment DrawPeekGraphicContext$address() {
        return DrawPeekGraphicContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern DrawInfo *DrawPeekGraphicContext(const DrawContext context)
     * }
     */
    public static MemorySegment DrawPeekGraphicContext(MemorySegment context) {
        var mh$ = DrawPeekGraphicContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPeekGraphicContext", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetTextDecoration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetTextDecoration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern DecorationType DrawGetTextDecoration(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetTextDecoration$descriptor() {
        return DrawGetTextDecoration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern DecorationType DrawGetTextDecoration(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetTextDecoration$handle() {
        return DrawGetTextDecoration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern DecorationType DrawGetTextDecoration(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetTextDecoration$address() {
        return DrawGetTextDecoration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern DecorationType DrawGetTextDecoration(DrawContext context)
     * }
     */
    public static int DrawGetTextDecoration(MemorySegment context) {
        var mh$ = DrawGetTextDecoration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetTextDecoration", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawAllocateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawAllocateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern DrawContext DrawAllocateContext(const DrawInfo *draw_info, Image *image)
     * }
     */
    public static FunctionDescriptor DrawAllocateContext$descriptor() {
        return DrawAllocateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern DrawContext DrawAllocateContext(const DrawInfo *draw_info, Image *image)
     * }
     */
    public static MethodHandle DrawAllocateContext$handle() {
        return DrawAllocateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern DrawContext DrawAllocateContext(const DrawInfo *draw_info, Image *image)
     * }
     */
    public static MemorySegment DrawAllocateContext$address() {
        return DrawAllocateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern DrawContext DrawAllocateContext(const DrawInfo *draw_info, Image *image)
     * }
     */
    public static MemorySegment DrawAllocateContext(MemorySegment draw_info, MemorySegment image) {
        var mh$ = DrawAllocateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawAllocateContext", draw_info, image);
            }
            return (MemorySegment)mh$.invokeExact(draw_info, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetClipRule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetClipRule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FillRule DrawGetClipRule(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetClipRule$descriptor() {
        return DrawGetClipRule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FillRule DrawGetClipRule(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetClipRule$handle() {
        return DrawGetClipRule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FillRule DrawGetClipRule(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetClipRule$address() {
        return DrawGetClipRule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FillRule DrawGetClipRule(DrawContext context)
     * }
     */
    public static int DrawGetClipRule(MemorySegment context) {
        var mh$ = DrawGetClipRule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetClipRule", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetFillRule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetFillRule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FillRule DrawGetFillRule(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetFillRule$descriptor() {
        return DrawGetFillRule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FillRule DrawGetFillRule(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetFillRule$handle() {
        return DrawGetFillRule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FillRule DrawGetFillRule(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetFillRule$address() {
        return DrawGetFillRule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FillRule DrawGetFillRule(DrawContext context)
     * }
     */
    public static int DrawGetFillRule(MemorySegment context) {
        var mh$ = DrawGetFillRule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetFillRule", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetGravity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetGravity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GravityType DrawGetGravity(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetGravity$descriptor() {
        return DrawGetGravity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GravityType DrawGetGravity(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetGravity$handle() {
        return DrawGetGravity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GravityType DrawGetGravity(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetGravity$address() {
        return DrawGetGravity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GravityType DrawGetGravity(DrawContext context)
     * }
     */
    public static int DrawGetGravity(MemorySegment context) {
        var mh$ = DrawGetGravity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetGravity", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetStrokeLineCap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetStrokeLineCap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern LineCap DrawGetStrokeLineCap(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetStrokeLineCap$descriptor() {
        return DrawGetStrokeLineCap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern LineCap DrawGetStrokeLineCap(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetStrokeLineCap$handle() {
        return DrawGetStrokeLineCap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern LineCap DrawGetStrokeLineCap(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetStrokeLineCap$address() {
        return DrawGetStrokeLineCap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern LineCap DrawGetStrokeLineCap(DrawContext context)
     * }
     */
    public static int DrawGetStrokeLineCap(MemorySegment context) {
        var mh$ = DrawGetStrokeLineCap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetStrokeLineCap", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetStrokeLineJoin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetStrokeLineJoin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern LineJoin DrawGetStrokeLineJoin(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetStrokeLineJoin$descriptor() {
        return DrawGetStrokeLineJoin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern LineJoin DrawGetStrokeLineJoin(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetStrokeLineJoin$handle() {
        return DrawGetStrokeLineJoin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern LineJoin DrawGetStrokeLineJoin(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetStrokeLineJoin$address() {
        return DrawGetStrokeLineJoin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern LineJoin DrawGetStrokeLineJoin(DrawContext context)
     * }
     */
    public static int DrawGetStrokeLineJoin(MemorySegment context) {
        var mh$ = DrawGetStrokeLineJoin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetStrokeLineJoin", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetFillColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _PixelPacket.layout(),
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetFillColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelPacket DrawGetFillColor(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetFillColor$descriptor() {
        return DrawGetFillColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelPacket DrawGetFillColor(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetFillColor$handle() {
        return DrawGetFillColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelPacket DrawGetFillColor(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetFillColor$address() {
        return DrawGetFillColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelPacket DrawGetFillColor(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetFillColor(SegmentAllocator allocator, MemorySegment context) {
        var mh$ = DrawGetFillColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetFillColor", allocator, context);
            }
            return (MemorySegment)mh$.invokeExact(allocator, context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetStrokeColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _PixelPacket.layout(),
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetStrokeColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelPacket DrawGetStrokeColor(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetStrokeColor$descriptor() {
        return DrawGetStrokeColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelPacket DrawGetStrokeColor(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetStrokeColor$handle() {
        return DrawGetStrokeColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelPacket DrawGetStrokeColor(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetStrokeColor$address() {
        return DrawGetStrokeColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelPacket DrawGetStrokeColor(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetStrokeColor(SegmentAllocator allocator, MemorySegment context) {
        var mh$ = DrawGetStrokeColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetStrokeColor", allocator, context);
            }
            return (MemorySegment)mh$.invokeExact(allocator, context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetTextUnderColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _PixelPacket.layout(),
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetTextUnderColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelPacket DrawGetTextUnderColor(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetTextUnderColor$descriptor() {
        return DrawGetTextUnderColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelPacket DrawGetTextUnderColor(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetTextUnderColor$handle() {
        return DrawGetTextUnderColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelPacket DrawGetTextUnderColor(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetTextUnderColor$address() {
        return DrawGetTextUnderColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelPacket DrawGetTextUnderColor(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetTextUnderColor(SegmentAllocator allocator, MemorySegment context) {
        var mh$ = DrawGetTextUnderColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetTextUnderColor", allocator, context);
            }
            return (MemorySegment)mh$.invokeExact(allocator, context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetFontStretch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetFontStretch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern StretchType DrawGetFontStretch(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetFontStretch$descriptor() {
        return DrawGetFontStretch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern StretchType DrawGetFontStretch(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetFontStretch$handle() {
        return DrawGetFontStretch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern StretchType DrawGetFontStretch(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetFontStretch$address() {
        return DrawGetFontStretch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern StretchType DrawGetFontStretch(DrawContext context)
     * }
     */
    public static int DrawGetFontStretch(MemorySegment context) {
        var mh$ = DrawGetFontStretch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetFontStretch", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetFontStyle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetFontStyle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern StyleType DrawGetFontStyle(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetFontStyle$descriptor() {
        return DrawGetFontStyle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern StyleType DrawGetFontStyle(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetFontStyle$handle() {
        return DrawGetFontStyle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern StyleType DrawGetFontStyle(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetFontStyle$address() {
        return DrawGetFontStyle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern StyleType DrawGetFontStyle(DrawContext context)
     * }
     */
    public static int DrawGetFontStyle(MemorySegment context) {
        var mh$ = DrawGetFontStyle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetFontStyle", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetClipPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetClipPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *DrawGetClipPath(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetClipPath$descriptor() {
        return DrawGetClipPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *DrawGetClipPath(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetClipPath$handle() {
        return DrawGetClipPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *DrawGetClipPath(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetClipPath$address() {
        return DrawGetClipPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *DrawGetClipPath(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetClipPath(MemorySegment context) {
        var mh$ = DrawGetClipPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetClipPath", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetFont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *DrawGetFont(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetFont$descriptor() {
        return DrawGetFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *DrawGetFont(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetFont$handle() {
        return DrawGetFont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *DrawGetFont(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetFont$address() {
        return DrawGetFont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *DrawGetFont(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetFont(MemorySegment context) {
        var mh$ = DrawGetFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetFont", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetFontFamily {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetFontFamily");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *DrawGetFontFamily(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetFontFamily$descriptor() {
        return DrawGetFontFamily.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *DrawGetFontFamily(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetFontFamily$handle() {
        return DrawGetFontFamily.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *DrawGetFontFamily(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetFontFamily$address() {
        return DrawGetFontFamily.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *DrawGetFontFamily(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetFontFamily(MemorySegment context) {
        var mh$ = DrawGetFontFamily.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetFontFamily", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetTextEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetTextEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *DrawGetTextEncoding(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetTextEncoding$descriptor() {
        return DrawGetTextEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *DrawGetTextEncoding(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetTextEncoding$handle() {
        return DrawGetTextEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *DrawGetTextEncoding(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetTextEncoding$address() {
        return DrawGetTextEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *DrawGetTextEncoding(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetTextEncoding(MemorySegment context) {
        var mh$ = DrawGetTextEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetTextEncoding", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRender {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawRender");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int DrawRender(const DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawRender$descriptor() {
        return DrawRender.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int DrawRender(const DrawContext context)
     * }
     */
    public static MethodHandle DrawRender$handle() {
        return DrawRender.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int DrawRender(const DrawContext context)
     * }
     */
    public static MemorySegment DrawRender$address() {
        return DrawRender.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int DrawRender(const DrawContext context)
     * }
     */
    public static int DrawRender(MemorySegment context) {
        var mh$ = DrawRender.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRender", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetStrokeAntialias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetStrokeAntialias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int DrawGetStrokeAntialias(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetStrokeAntialias$descriptor() {
        return DrawGetStrokeAntialias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int DrawGetStrokeAntialias(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetStrokeAntialias$handle() {
        return DrawGetStrokeAntialias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int DrawGetStrokeAntialias(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetStrokeAntialias$address() {
        return DrawGetStrokeAntialias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int DrawGetStrokeAntialias(DrawContext context)
     * }
     */
    public static int DrawGetStrokeAntialias(MemorySegment context) {
        var mh$ = DrawGetStrokeAntialias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetStrokeAntialias", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetTextAntialias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetTextAntialias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int DrawGetTextAntialias(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetTextAntialias$descriptor() {
        return DrawGetTextAntialias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int DrawGetTextAntialias(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetTextAntialias$handle() {
        return DrawGetTextAntialias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int DrawGetTextAntialias(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetTextAntialias$address() {
        return DrawGetTextAntialias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int DrawGetTextAntialias(DrawContext context)
     * }
     */
    public static int DrawGetTextAntialias(MemorySegment context) {
        var mh$ = DrawGetTextAntialias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetTextAntialias", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetFontWeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetFontWeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long DrawGetFontWeight(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetFontWeight$descriptor() {
        return DrawGetFontWeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long DrawGetFontWeight(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetFontWeight$handle() {
        return DrawGetFontWeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long DrawGetFontWeight(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetFontWeight$address() {
        return DrawGetFontWeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long DrawGetFontWeight(DrawContext context)
     * }
     */
    public static long DrawGetFontWeight(MemorySegment context) {
        var mh$ = DrawGetFontWeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetFontWeight", context);
            }
            return (long)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetStrokeMiterLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetStrokeMiterLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long DrawGetStrokeMiterLimit(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetStrokeMiterLimit$descriptor() {
        return DrawGetStrokeMiterLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long DrawGetStrokeMiterLimit(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetStrokeMiterLimit$handle() {
        return DrawGetStrokeMiterLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long DrawGetStrokeMiterLimit(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetStrokeMiterLimit$address() {
        return DrawGetStrokeMiterLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long DrawGetStrokeMiterLimit(DrawContext context)
     * }
     */
    public static long DrawGetStrokeMiterLimit(MemorySegment context) {
        var mh$ = DrawGetStrokeMiterLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetStrokeMiterLimit", context);
            }
            return (long)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetFillOpacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetFillOpacity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double DrawGetFillOpacity(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetFillOpacity$descriptor() {
        return DrawGetFillOpacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double DrawGetFillOpacity(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetFillOpacity$handle() {
        return DrawGetFillOpacity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double DrawGetFillOpacity(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetFillOpacity$address() {
        return DrawGetFillOpacity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double DrawGetFillOpacity(DrawContext context)
     * }
     */
    public static double DrawGetFillOpacity(MemorySegment context) {
        var mh$ = DrawGetFillOpacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetFillOpacity", context);
            }
            return (double)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetFontSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetFontSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double DrawGetFontSize(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetFontSize$descriptor() {
        return DrawGetFontSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double DrawGetFontSize(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetFontSize$handle() {
        return DrawGetFontSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double DrawGetFontSize(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetFontSize$address() {
        return DrawGetFontSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double DrawGetFontSize(DrawContext context)
     * }
     */
    public static double DrawGetFontSize(MemorySegment context) {
        var mh$ = DrawGetFontSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetFontSize", context);
            }
            return (double)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetStrokeDashArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetStrokeDashArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double *DrawGetStrokeDashArray(DrawContext context, unsigned long *num_elems)
     * }
     */
    public static FunctionDescriptor DrawGetStrokeDashArray$descriptor() {
        return DrawGetStrokeDashArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double *DrawGetStrokeDashArray(DrawContext context, unsigned long *num_elems)
     * }
     */
    public static MethodHandle DrawGetStrokeDashArray$handle() {
        return DrawGetStrokeDashArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double *DrawGetStrokeDashArray(DrawContext context, unsigned long *num_elems)
     * }
     */
    public static MemorySegment DrawGetStrokeDashArray$address() {
        return DrawGetStrokeDashArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double *DrawGetStrokeDashArray(DrawContext context, unsigned long *num_elems)
     * }
     */
    public static MemorySegment DrawGetStrokeDashArray(MemorySegment context, MemorySegment num_elems) {
        var mh$ = DrawGetStrokeDashArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetStrokeDashArray", context, num_elems);
            }
            return (MemorySegment)mh$.invokeExact(context, num_elems);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetStrokeDashOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetStrokeDashOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double DrawGetStrokeDashOffset(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetStrokeDashOffset$descriptor() {
        return DrawGetStrokeDashOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double DrawGetStrokeDashOffset(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetStrokeDashOffset$handle() {
        return DrawGetStrokeDashOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double DrawGetStrokeDashOffset(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetStrokeDashOffset$address() {
        return DrawGetStrokeDashOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double DrawGetStrokeDashOffset(DrawContext context)
     * }
     */
    public static double DrawGetStrokeDashOffset(MemorySegment context) {
        var mh$ = DrawGetStrokeDashOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetStrokeDashOffset", context);
            }
            return (double)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetStrokeOpacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetStrokeOpacity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double DrawGetStrokeOpacity(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetStrokeOpacity$descriptor() {
        return DrawGetStrokeOpacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double DrawGetStrokeOpacity(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetStrokeOpacity$handle() {
        return DrawGetStrokeOpacity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double DrawGetStrokeOpacity(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetStrokeOpacity$address() {
        return DrawGetStrokeOpacity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double DrawGetStrokeOpacity(DrawContext context)
     * }
     */
    public static double DrawGetStrokeOpacity(MemorySegment context) {
        var mh$ = DrawGetStrokeOpacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetStrokeOpacity", context);
            }
            return (double)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawGetStrokeWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawGetStrokeWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double DrawGetStrokeWidth(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawGetStrokeWidth$descriptor() {
        return DrawGetStrokeWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double DrawGetStrokeWidth(DrawContext context)
     * }
     */
    public static MethodHandle DrawGetStrokeWidth$handle() {
        return DrawGetStrokeWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double DrawGetStrokeWidth(DrawContext context)
     * }
     */
    public static MemorySegment DrawGetStrokeWidth$address() {
        return DrawGetStrokeWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double DrawGetStrokeWidth(DrawContext context)
     * }
     */
    public static double DrawGetStrokeWidth(MemorySegment context) {
        var mh$ = DrawGetStrokeWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawGetStrokeWidth", context);
            }
            return (double)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawAffine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawAffine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawAffine(DrawContext context, const AffineMatrix *affine)
     * }
     */
    public static FunctionDescriptor DrawAffine$descriptor() {
        return DrawAffine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawAffine(DrawContext context, const AffineMatrix *affine)
     * }
     */
    public static MethodHandle DrawAffine$handle() {
        return DrawAffine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawAffine(DrawContext context, const AffineMatrix *affine)
     * }
     */
    public static MemorySegment DrawAffine$address() {
        return DrawAffine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawAffine(DrawContext context, const AffineMatrix *affine)
     * }
     */
    public static void DrawAffine(MemorySegment context, MemorySegment affine) {
        var mh$ = DrawAffine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawAffine", context, affine);
            }
            mh$.invokeExact(context, affine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawAnnotation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawAnnotation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawAnnotation(DrawContext context, const double x, const double y, const unsigned char *text)
     * }
     */
    public static FunctionDescriptor DrawAnnotation$descriptor() {
        return DrawAnnotation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawAnnotation(DrawContext context, const double x, const double y, const unsigned char *text)
     * }
     */
    public static MethodHandle DrawAnnotation$handle() {
        return DrawAnnotation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawAnnotation(DrawContext context, const double x, const double y, const unsigned char *text)
     * }
     */
    public static MemorySegment DrawAnnotation$address() {
        return DrawAnnotation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawAnnotation(DrawContext context, const double x, const double y, const unsigned char *text)
     * }
     */
    public static void DrawAnnotation(MemorySegment context, double x, double y, MemorySegment text) {
        var mh$ = DrawAnnotation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawAnnotation", context, x, y, text);
            }
            mh$.invokeExact(context, x, y, text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawArc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawArc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawArc(DrawContext context, const double sx, const double sy, const double ex, const double ey, const double sd, const double ed)
     * }
     */
    public static FunctionDescriptor DrawArc$descriptor() {
        return DrawArc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawArc(DrawContext context, const double sx, const double sy, const double ex, const double ey, const double sd, const double ed)
     * }
     */
    public static MethodHandle DrawArc$handle() {
        return DrawArc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawArc(DrawContext context, const double sx, const double sy, const double ex, const double ey, const double sd, const double ed)
     * }
     */
    public static MemorySegment DrawArc$address() {
        return DrawArc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawArc(DrawContext context, const double sx, const double sy, const double ex, const double ey, const double sd, const double ed)
     * }
     */
    public static void DrawArc(MemorySegment context, double sx, double sy, double ex, double ey, double sd, double ed) {
        var mh$ = DrawArc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawArc", context, sx, sy, ex, ey, sd, ed);
            }
            mh$.invokeExact(context, sx, sy, ex, ey, sd, ed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawBezier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawBezier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawBezier(DrawContext context, const unsigned long num_coords, const PointInfo *coordinates)
     * }
     */
    public static FunctionDescriptor DrawBezier$descriptor() {
        return DrawBezier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawBezier(DrawContext context, const unsigned long num_coords, const PointInfo *coordinates)
     * }
     */
    public static MethodHandle DrawBezier$handle() {
        return DrawBezier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawBezier(DrawContext context, const unsigned long num_coords, const PointInfo *coordinates)
     * }
     */
    public static MemorySegment DrawBezier$address() {
        return DrawBezier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawBezier(DrawContext context, const unsigned long num_coords, const PointInfo *coordinates)
     * }
     */
    public static void DrawBezier(MemorySegment context, long num_coords, MemorySegment coordinates) {
        var mh$ = DrawBezier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawBezier", context, num_coords, coordinates);
            }
            mh$.invokeExact(context, num_coords, coordinates);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCircle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawCircle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawCircle(DrawContext context, const double ox, const double oy, const double px, const double py)
     * }
     */
    public static FunctionDescriptor DrawCircle$descriptor() {
        return DrawCircle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawCircle(DrawContext context, const double ox, const double oy, const double px, const double py)
     * }
     */
    public static MethodHandle DrawCircle$handle() {
        return DrawCircle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawCircle(DrawContext context, const double ox, const double oy, const double px, const double py)
     * }
     */
    public static MemorySegment DrawCircle$address() {
        return DrawCircle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawCircle(DrawContext context, const double ox, const double oy, const double px, const double py)
     * }
     */
    public static void DrawCircle(MemorySegment context, double ox, double oy, double px, double py) {
        var mh$ = DrawCircle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCircle", context, ox, oy, px, py);
            }
            mh$.invokeExact(context, ox, oy, px, py);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawColor(DrawContext context, const double x, const double y, const PaintMethod paintMethod)
     * }
     */
    public static FunctionDescriptor DrawColor$descriptor() {
        return DrawColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawColor(DrawContext context, const double x, const double y, const PaintMethod paintMethod)
     * }
     */
    public static MethodHandle DrawColor$handle() {
        return DrawColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawColor(DrawContext context, const double x, const double y, const PaintMethod paintMethod)
     * }
     */
    public static MemorySegment DrawColor$address() {
        return DrawColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawColor(DrawContext context, const double x, const double y, const PaintMethod paintMethod)
     * }
     */
    public static void DrawColor(MemorySegment context, double x, double y, int paintMethod) {
        var mh$ = DrawColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawColor", context, x, y, paintMethod);
            }
            mh$.invokeExact(context, x, y, paintMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawComment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawComment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawComment(DrawContext context, const char *comment)
     * }
     */
    public static FunctionDescriptor DrawComment$descriptor() {
        return DrawComment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawComment(DrawContext context, const char *comment)
     * }
     */
    public static MethodHandle DrawComment$handle() {
        return DrawComment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawComment(DrawContext context, const char *comment)
     * }
     */
    public static MemorySegment DrawComment$address() {
        return DrawComment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawComment(DrawContext context, const char *comment)
     * }
     */
    public static void DrawComment(MemorySegment context, MemorySegment comment) {
        var mh$ = DrawComment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawComment", context, comment);
            }
            mh$.invokeExact(context, comment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawDestroyContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawDestroyContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawDestroyContext(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawDestroyContext$descriptor() {
        return DrawDestroyContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawDestroyContext(DrawContext context)
     * }
     */
    public static MethodHandle DrawDestroyContext$handle() {
        return DrawDestroyContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawDestroyContext(DrawContext context)
     * }
     */
    public static MemorySegment DrawDestroyContext$address() {
        return DrawDestroyContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawDestroyContext(DrawContext context)
     * }
     */
    public static void DrawDestroyContext(MemorySegment context) {
        var mh$ = DrawDestroyContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawDestroyContext", context);
            }
            mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawEllipse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawEllipse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawEllipse(DrawContext context, const double ox, const double oy, const double rx, const double ry, const double start, const double end)
     * }
     */
    public static FunctionDescriptor DrawEllipse$descriptor() {
        return DrawEllipse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawEllipse(DrawContext context, const double ox, const double oy, const double rx, const double ry, const double start, const double end)
     * }
     */
    public static MethodHandle DrawEllipse$handle() {
        return DrawEllipse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawEllipse(DrawContext context, const double ox, const double oy, const double rx, const double ry, const double start, const double end)
     * }
     */
    public static MemorySegment DrawEllipse$address() {
        return DrawEllipse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawEllipse(DrawContext context, const double ox, const double oy, const double rx, const double ry, const double start, const double end)
     * }
     */
    public static void DrawEllipse(MemorySegment context, double ox, double oy, double rx, double ry, double start, double end) {
        var mh$ = DrawEllipse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawEllipse", context, ox, oy, rx, ry, start, end);
            }
            mh$.invokeExact(context, ox, oy, rx, ry, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawComposite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawComposite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawComposite(DrawContext context, const CompositeOperator composite_operator, const double x, const double y, const double width, const double height, const Image *image)
     * }
     */
    public static FunctionDescriptor DrawComposite$descriptor() {
        return DrawComposite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawComposite(DrawContext context, const CompositeOperator composite_operator, const double x, const double y, const double width, const double height, const Image *image)
     * }
     */
    public static MethodHandle DrawComposite$handle() {
        return DrawComposite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawComposite(DrawContext context, const CompositeOperator composite_operator, const double x, const double y, const double width, const double height, const Image *image)
     * }
     */
    public static MemorySegment DrawComposite$address() {
        return DrawComposite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawComposite(DrawContext context, const CompositeOperator composite_operator, const double x, const double y, const double width, const double height, const Image *image)
     * }
     */
    public static void DrawComposite(MemorySegment context, int composite_operator, double x, double y, double width, double height, MemorySegment image) {
        var mh$ = DrawComposite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawComposite", context, composite_operator, x, y, width, height, image);
            }
            mh$.invokeExact(context, composite_operator, x, y, width, height, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawLine(DrawContext context, const double sx, const double sy, const double ex, const double ey)
     * }
     */
    public static FunctionDescriptor DrawLine$descriptor() {
        return DrawLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawLine(DrawContext context, const double sx, const double sy, const double ex, const double ey)
     * }
     */
    public static MethodHandle DrawLine$handle() {
        return DrawLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawLine(DrawContext context, const double sx, const double sy, const double ex, const double ey)
     * }
     */
    public static MemorySegment DrawLine$address() {
        return DrawLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawLine(DrawContext context, const double sx, const double sy, const double ex, const double ey)
     * }
     */
    public static void DrawLine(MemorySegment context, double sx, double sy, double ex, double ey) {
        var mh$ = DrawLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawLine", context, sx, sy, ex, ey);
            }
            mh$.invokeExact(context, sx, sy, ex, ey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawMatte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawMatte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawMatte(DrawContext context, const double x, const double y, const PaintMethod paint_method)
     * }
     */
    public static FunctionDescriptor DrawMatte$descriptor() {
        return DrawMatte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawMatte(DrawContext context, const double x, const double y, const PaintMethod paint_method)
     * }
     */
    public static MethodHandle DrawMatte$handle() {
        return DrawMatte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawMatte(DrawContext context, const double x, const double y, const PaintMethod paint_method)
     * }
     */
    public static MemorySegment DrawMatte$address() {
        return DrawMatte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawMatte(DrawContext context, const double x, const double y, const PaintMethod paint_method)
     * }
     */
    public static void DrawMatte(MemorySegment context, double x, double y, int paint_method) {
        var mh$ = DrawMatte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawMatte", context, x, y, paint_method);
            }
            mh$.invokeExact(context, x, y, paint_method);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathClose(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawPathClose$descriptor() {
        return DrawPathClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathClose(DrawContext context)
     * }
     */
    public static MethodHandle DrawPathClose$handle() {
        return DrawPathClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathClose(DrawContext context)
     * }
     */
    public static MemorySegment DrawPathClose$address() {
        return DrawPathClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathClose(DrawContext context)
     * }
     */
    public static void DrawPathClose(MemorySegment context) {
        var mh$ = DrawPathClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathClose", context);
            }
            mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathCurveToAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathCurveToAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToAbsolute(DrawContext context, const double x1, const double y1, const double x2, const double y2, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawPathCurveToAbsolute$descriptor() {
        return DrawPathCurveToAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToAbsolute(DrawContext context, const double x1, const double y1, const double x2, const double y2, const double x, const double y)
     * }
     */
    public static MethodHandle DrawPathCurveToAbsolute$handle() {
        return DrawPathCurveToAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToAbsolute(DrawContext context, const double x1, const double y1, const double x2, const double y2, const double x, const double y)
     * }
     */
    public static MemorySegment DrawPathCurveToAbsolute$address() {
        return DrawPathCurveToAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathCurveToAbsolute(DrawContext context, const double x1, const double y1, const double x2, const double y2, const double x, const double y)
     * }
     */
    public static void DrawPathCurveToAbsolute(MemorySegment context, double x1, double y1, double x2, double y2, double x, double y) {
        var mh$ = DrawPathCurveToAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathCurveToAbsolute", context, x1, y1, x2, y2, x, y);
            }
            mh$.invokeExact(context, x1, y1, x2, y2, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathCurveToRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathCurveToRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToRelative(DrawContext context, const double x1, const double y1, const double x2, const double y2, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawPathCurveToRelative$descriptor() {
        return DrawPathCurveToRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToRelative(DrawContext context, const double x1, const double y1, const double x2, const double y2, const double x, const double y)
     * }
     */
    public static MethodHandle DrawPathCurveToRelative$handle() {
        return DrawPathCurveToRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToRelative(DrawContext context, const double x1, const double y1, const double x2, const double y2, const double x, const double y)
     * }
     */
    public static MemorySegment DrawPathCurveToRelative$address() {
        return DrawPathCurveToRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathCurveToRelative(DrawContext context, const double x1, const double y1, const double x2, const double y2, const double x, const double y)
     * }
     */
    public static void DrawPathCurveToRelative(MemorySegment context, double x1, double y1, double x2, double y2, double x, double y) {
        var mh$ = DrawPathCurveToRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathCurveToRelative", context, x1, y1, x2, y2, x, y);
            }
            mh$.invokeExact(context, x1, y1, x2, y2, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathCurveToQuadraticBezierAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathCurveToQuadraticBezierAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToQuadraticBezierAbsolute(DrawContext context, const double x1, const double y1, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawPathCurveToQuadraticBezierAbsolute$descriptor() {
        return DrawPathCurveToQuadraticBezierAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToQuadraticBezierAbsolute(DrawContext context, const double x1, const double y1, const double x, const double y)
     * }
     */
    public static MethodHandle DrawPathCurveToQuadraticBezierAbsolute$handle() {
        return DrawPathCurveToQuadraticBezierAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToQuadraticBezierAbsolute(DrawContext context, const double x1, const double y1, const double x, const double y)
     * }
     */
    public static MemorySegment DrawPathCurveToQuadraticBezierAbsolute$address() {
        return DrawPathCurveToQuadraticBezierAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathCurveToQuadraticBezierAbsolute(DrawContext context, const double x1, const double y1, const double x, const double y)
     * }
     */
    public static void DrawPathCurveToQuadraticBezierAbsolute(MemorySegment context, double x1, double y1, double x, double y) {
        var mh$ = DrawPathCurveToQuadraticBezierAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathCurveToQuadraticBezierAbsolute", context, x1, y1, x, y);
            }
            mh$.invokeExact(context, x1, y1, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathCurveToQuadraticBezierRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathCurveToQuadraticBezierRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToQuadraticBezierRelative(DrawContext context, const double x1, const double y1, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawPathCurveToQuadraticBezierRelative$descriptor() {
        return DrawPathCurveToQuadraticBezierRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToQuadraticBezierRelative(DrawContext context, const double x1, const double y1, const double x, const double y)
     * }
     */
    public static MethodHandle DrawPathCurveToQuadraticBezierRelative$handle() {
        return DrawPathCurveToQuadraticBezierRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToQuadraticBezierRelative(DrawContext context, const double x1, const double y1, const double x, const double y)
     * }
     */
    public static MemorySegment DrawPathCurveToQuadraticBezierRelative$address() {
        return DrawPathCurveToQuadraticBezierRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathCurveToQuadraticBezierRelative(DrawContext context, const double x1, const double y1, const double x, const double y)
     * }
     */
    public static void DrawPathCurveToQuadraticBezierRelative(MemorySegment context, double x1, double y1, double x, double y) {
        var mh$ = DrawPathCurveToQuadraticBezierRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathCurveToQuadraticBezierRelative", context, x1, y1, x, y);
            }
            mh$.invokeExact(context, x1, y1, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathCurveToQuadraticBezierSmoothAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathCurveToQuadraticBezierSmoothAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToQuadraticBezierSmoothAbsolute(DrawContext context, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawPathCurveToQuadraticBezierSmoothAbsolute$descriptor() {
        return DrawPathCurveToQuadraticBezierSmoothAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToQuadraticBezierSmoothAbsolute(DrawContext context, const double x, const double y)
     * }
     */
    public static MethodHandle DrawPathCurveToQuadraticBezierSmoothAbsolute$handle() {
        return DrawPathCurveToQuadraticBezierSmoothAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToQuadraticBezierSmoothAbsolute(DrawContext context, const double x, const double y)
     * }
     */
    public static MemorySegment DrawPathCurveToQuadraticBezierSmoothAbsolute$address() {
        return DrawPathCurveToQuadraticBezierSmoothAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathCurveToQuadraticBezierSmoothAbsolute(DrawContext context, const double x, const double y)
     * }
     */
    public static void DrawPathCurveToQuadraticBezierSmoothAbsolute(MemorySegment context, double x, double y) {
        var mh$ = DrawPathCurveToQuadraticBezierSmoothAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathCurveToQuadraticBezierSmoothAbsolute", context, x, y);
            }
            mh$.invokeExact(context, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathCurveToQuadraticBezierSmoothRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathCurveToQuadraticBezierSmoothRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToQuadraticBezierSmoothRelative(DrawContext context, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawPathCurveToQuadraticBezierSmoothRelative$descriptor() {
        return DrawPathCurveToQuadraticBezierSmoothRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToQuadraticBezierSmoothRelative(DrawContext context, const double x, const double y)
     * }
     */
    public static MethodHandle DrawPathCurveToQuadraticBezierSmoothRelative$handle() {
        return DrawPathCurveToQuadraticBezierSmoothRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToQuadraticBezierSmoothRelative(DrawContext context, const double x, const double y)
     * }
     */
    public static MemorySegment DrawPathCurveToQuadraticBezierSmoothRelative$address() {
        return DrawPathCurveToQuadraticBezierSmoothRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathCurveToQuadraticBezierSmoothRelative(DrawContext context, const double x, const double y)
     * }
     */
    public static void DrawPathCurveToQuadraticBezierSmoothRelative(MemorySegment context, double x, double y) {
        var mh$ = DrawPathCurveToQuadraticBezierSmoothRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathCurveToQuadraticBezierSmoothRelative", context, x, y);
            }
            mh$.invokeExact(context, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathCurveToSmoothAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathCurveToSmoothAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToSmoothAbsolute(DrawContext context, const double x2, const double y2, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawPathCurveToSmoothAbsolute$descriptor() {
        return DrawPathCurveToSmoothAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToSmoothAbsolute(DrawContext context, const double x2, const double y2, const double x, const double y)
     * }
     */
    public static MethodHandle DrawPathCurveToSmoothAbsolute$handle() {
        return DrawPathCurveToSmoothAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToSmoothAbsolute(DrawContext context, const double x2, const double y2, const double x, const double y)
     * }
     */
    public static MemorySegment DrawPathCurveToSmoothAbsolute$address() {
        return DrawPathCurveToSmoothAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathCurveToSmoothAbsolute(DrawContext context, const double x2, const double y2, const double x, const double y)
     * }
     */
    public static void DrawPathCurveToSmoothAbsolute(MemorySegment context, double x2, double y2, double x, double y) {
        var mh$ = DrawPathCurveToSmoothAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathCurveToSmoothAbsolute", context, x2, y2, x, y);
            }
            mh$.invokeExact(context, x2, y2, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathCurveToSmoothRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathCurveToSmoothRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToSmoothRelative(DrawContext context, const double x2, const double y2, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawPathCurveToSmoothRelative$descriptor() {
        return DrawPathCurveToSmoothRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToSmoothRelative(DrawContext context, const double x2, const double y2, const double x, const double y)
     * }
     */
    public static MethodHandle DrawPathCurveToSmoothRelative$handle() {
        return DrawPathCurveToSmoothRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathCurveToSmoothRelative(DrawContext context, const double x2, const double y2, const double x, const double y)
     * }
     */
    public static MemorySegment DrawPathCurveToSmoothRelative$address() {
        return DrawPathCurveToSmoothRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathCurveToSmoothRelative(DrawContext context, const double x2, const double y2, const double x, const double y)
     * }
     */
    public static void DrawPathCurveToSmoothRelative(MemorySegment context, double x2, double y2, double x, double y) {
        var mh$ = DrawPathCurveToSmoothRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathCurveToSmoothRelative", context, x2, y2, x, y);
            }
            mh$.invokeExact(context, x2, y2, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathEllipticArcAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathEllipticArcAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathEllipticArcAbsolute(DrawContext context, const double rx, const double ry, const double x_axis_rotation, unsigned int large_arc_flag, unsigned int sweep_flag, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawPathEllipticArcAbsolute$descriptor() {
        return DrawPathEllipticArcAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathEllipticArcAbsolute(DrawContext context, const double rx, const double ry, const double x_axis_rotation, unsigned int large_arc_flag, unsigned int sweep_flag, const double x, const double y)
     * }
     */
    public static MethodHandle DrawPathEllipticArcAbsolute$handle() {
        return DrawPathEllipticArcAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathEllipticArcAbsolute(DrawContext context, const double rx, const double ry, const double x_axis_rotation, unsigned int large_arc_flag, unsigned int sweep_flag, const double x, const double y)
     * }
     */
    public static MemorySegment DrawPathEllipticArcAbsolute$address() {
        return DrawPathEllipticArcAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathEllipticArcAbsolute(DrawContext context, const double rx, const double ry, const double x_axis_rotation, unsigned int large_arc_flag, unsigned int sweep_flag, const double x, const double y)
     * }
     */
    public static void DrawPathEllipticArcAbsolute(MemorySegment context, double rx, double ry, double x_axis_rotation, int large_arc_flag, int sweep_flag, double x, double y) {
        var mh$ = DrawPathEllipticArcAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathEllipticArcAbsolute", context, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, x, y);
            }
            mh$.invokeExact(context, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathEllipticArcRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathEllipticArcRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathEllipticArcRelative(DrawContext context, const double rx, const double ry, const double x_axis_rotation, unsigned int large_arc_flag, unsigned int sweep_flag, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawPathEllipticArcRelative$descriptor() {
        return DrawPathEllipticArcRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathEllipticArcRelative(DrawContext context, const double rx, const double ry, const double x_axis_rotation, unsigned int large_arc_flag, unsigned int sweep_flag, const double x, const double y)
     * }
     */
    public static MethodHandle DrawPathEllipticArcRelative$handle() {
        return DrawPathEllipticArcRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathEllipticArcRelative(DrawContext context, const double rx, const double ry, const double x_axis_rotation, unsigned int large_arc_flag, unsigned int sweep_flag, const double x, const double y)
     * }
     */
    public static MemorySegment DrawPathEllipticArcRelative$address() {
        return DrawPathEllipticArcRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathEllipticArcRelative(DrawContext context, const double rx, const double ry, const double x_axis_rotation, unsigned int large_arc_flag, unsigned int sweep_flag, const double x, const double y)
     * }
     */
    public static void DrawPathEllipticArcRelative(MemorySegment context, double rx, double ry, double x_axis_rotation, int large_arc_flag, int sweep_flag, double x, double y) {
        var mh$ = DrawPathEllipticArcRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathEllipticArcRelative", context, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, x, y);
            }
            mh$.invokeExact(context, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathFinish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathFinish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathFinish(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawPathFinish$descriptor() {
        return DrawPathFinish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathFinish(DrawContext context)
     * }
     */
    public static MethodHandle DrawPathFinish$handle() {
        return DrawPathFinish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathFinish(DrawContext context)
     * }
     */
    public static MemorySegment DrawPathFinish$address() {
        return DrawPathFinish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathFinish(DrawContext context)
     * }
     */
    public static void DrawPathFinish(MemorySegment context) {
        var mh$ = DrawPathFinish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathFinish", context);
            }
            mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathLineToAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathLineToAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathLineToAbsolute(DrawContext context, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawPathLineToAbsolute$descriptor() {
        return DrawPathLineToAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathLineToAbsolute(DrawContext context, const double x, const double y)
     * }
     */
    public static MethodHandle DrawPathLineToAbsolute$handle() {
        return DrawPathLineToAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathLineToAbsolute(DrawContext context, const double x, const double y)
     * }
     */
    public static MemorySegment DrawPathLineToAbsolute$address() {
        return DrawPathLineToAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathLineToAbsolute(DrawContext context, const double x, const double y)
     * }
     */
    public static void DrawPathLineToAbsolute(MemorySegment context, double x, double y) {
        var mh$ = DrawPathLineToAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathLineToAbsolute", context, x, y);
            }
            mh$.invokeExact(context, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathLineToRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathLineToRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathLineToRelative(DrawContext context, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawPathLineToRelative$descriptor() {
        return DrawPathLineToRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathLineToRelative(DrawContext context, const double x, const double y)
     * }
     */
    public static MethodHandle DrawPathLineToRelative$handle() {
        return DrawPathLineToRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathLineToRelative(DrawContext context, const double x, const double y)
     * }
     */
    public static MemorySegment DrawPathLineToRelative$address() {
        return DrawPathLineToRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathLineToRelative(DrawContext context, const double x, const double y)
     * }
     */
    public static void DrawPathLineToRelative(MemorySegment context, double x, double y) {
        var mh$ = DrawPathLineToRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathLineToRelative", context, x, y);
            }
            mh$.invokeExact(context, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathLineToHorizontalAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathLineToHorizontalAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathLineToHorizontalAbsolute(DrawContext context, const double x)
     * }
     */
    public static FunctionDescriptor DrawPathLineToHorizontalAbsolute$descriptor() {
        return DrawPathLineToHorizontalAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathLineToHorizontalAbsolute(DrawContext context, const double x)
     * }
     */
    public static MethodHandle DrawPathLineToHorizontalAbsolute$handle() {
        return DrawPathLineToHorizontalAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathLineToHorizontalAbsolute(DrawContext context, const double x)
     * }
     */
    public static MemorySegment DrawPathLineToHorizontalAbsolute$address() {
        return DrawPathLineToHorizontalAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathLineToHorizontalAbsolute(DrawContext context, const double x)
     * }
     */
    public static void DrawPathLineToHorizontalAbsolute(MemorySegment context, double x) {
        var mh$ = DrawPathLineToHorizontalAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathLineToHorizontalAbsolute", context, x);
            }
            mh$.invokeExact(context, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathLineToHorizontalRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathLineToHorizontalRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathLineToHorizontalRelative(DrawContext context, const double x)
     * }
     */
    public static FunctionDescriptor DrawPathLineToHorizontalRelative$descriptor() {
        return DrawPathLineToHorizontalRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathLineToHorizontalRelative(DrawContext context, const double x)
     * }
     */
    public static MethodHandle DrawPathLineToHorizontalRelative$handle() {
        return DrawPathLineToHorizontalRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathLineToHorizontalRelative(DrawContext context, const double x)
     * }
     */
    public static MemorySegment DrawPathLineToHorizontalRelative$address() {
        return DrawPathLineToHorizontalRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathLineToHorizontalRelative(DrawContext context, const double x)
     * }
     */
    public static void DrawPathLineToHorizontalRelative(MemorySegment context, double x) {
        var mh$ = DrawPathLineToHorizontalRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathLineToHorizontalRelative", context, x);
            }
            mh$.invokeExact(context, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathLineToVerticalAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathLineToVerticalAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathLineToVerticalAbsolute(DrawContext context, const double y)
     * }
     */
    public static FunctionDescriptor DrawPathLineToVerticalAbsolute$descriptor() {
        return DrawPathLineToVerticalAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathLineToVerticalAbsolute(DrawContext context, const double y)
     * }
     */
    public static MethodHandle DrawPathLineToVerticalAbsolute$handle() {
        return DrawPathLineToVerticalAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathLineToVerticalAbsolute(DrawContext context, const double y)
     * }
     */
    public static MemorySegment DrawPathLineToVerticalAbsolute$address() {
        return DrawPathLineToVerticalAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathLineToVerticalAbsolute(DrawContext context, const double y)
     * }
     */
    public static void DrawPathLineToVerticalAbsolute(MemorySegment context, double y) {
        var mh$ = DrawPathLineToVerticalAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathLineToVerticalAbsolute", context, y);
            }
            mh$.invokeExact(context, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathLineToVerticalRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathLineToVerticalRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathLineToVerticalRelative(DrawContext context, const double y)
     * }
     */
    public static FunctionDescriptor DrawPathLineToVerticalRelative$descriptor() {
        return DrawPathLineToVerticalRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathLineToVerticalRelative(DrawContext context, const double y)
     * }
     */
    public static MethodHandle DrawPathLineToVerticalRelative$handle() {
        return DrawPathLineToVerticalRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathLineToVerticalRelative(DrawContext context, const double y)
     * }
     */
    public static MemorySegment DrawPathLineToVerticalRelative$address() {
        return DrawPathLineToVerticalRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathLineToVerticalRelative(DrawContext context, const double y)
     * }
     */
    public static void DrawPathLineToVerticalRelative(MemorySegment context, double y) {
        var mh$ = DrawPathLineToVerticalRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathLineToVerticalRelative", context, y);
            }
            mh$.invokeExact(context, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathMoveToAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathMoveToAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathMoveToAbsolute(DrawContext context, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawPathMoveToAbsolute$descriptor() {
        return DrawPathMoveToAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathMoveToAbsolute(DrawContext context, const double x, const double y)
     * }
     */
    public static MethodHandle DrawPathMoveToAbsolute$handle() {
        return DrawPathMoveToAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathMoveToAbsolute(DrawContext context, const double x, const double y)
     * }
     */
    public static MemorySegment DrawPathMoveToAbsolute$address() {
        return DrawPathMoveToAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathMoveToAbsolute(DrawContext context, const double x, const double y)
     * }
     */
    public static void DrawPathMoveToAbsolute(MemorySegment context, double x, double y) {
        var mh$ = DrawPathMoveToAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathMoveToAbsolute", context, x, y);
            }
            mh$.invokeExact(context, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathMoveToRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathMoveToRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathMoveToRelative(DrawContext context, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawPathMoveToRelative$descriptor() {
        return DrawPathMoveToRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathMoveToRelative(DrawContext context, const double x, const double y)
     * }
     */
    public static MethodHandle DrawPathMoveToRelative$handle() {
        return DrawPathMoveToRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathMoveToRelative(DrawContext context, const double x, const double y)
     * }
     */
    public static MemorySegment DrawPathMoveToRelative$address() {
        return DrawPathMoveToRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathMoveToRelative(DrawContext context, const double x, const double y)
     * }
     */
    public static void DrawPathMoveToRelative(MemorySegment context, double x, double y) {
        var mh$ = DrawPathMoveToRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathMoveToRelative", context, x, y);
            }
            mh$.invokeExact(context, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPathStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPathStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPathStart(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawPathStart$descriptor() {
        return DrawPathStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPathStart(DrawContext context)
     * }
     */
    public static MethodHandle DrawPathStart$handle() {
        return DrawPathStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPathStart(DrawContext context)
     * }
     */
    public static MemorySegment DrawPathStart$address() {
        return DrawPathStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPathStart(DrawContext context)
     * }
     */
    public static void DrawPathStart(MemorySegment context) {
        var mh$ = DrawPathStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPathStart", context);
            }
            mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPoint(DrawContext context, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawPoint$descriptor() {
        return DrawPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPoint(DrawContext context, const double x, const double y)
     * }
     */
    public static MethodHandle DrawPoint$handle() {
        return DrawPoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPoint(DrawContext context, const double x, const double y)
     * }
     */
    public static MemorySegment DrawPoint$address() {
        return DrawPoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPoint(DrawContext context, const double x, const double y)
     * }
     */
    public static void DrawPoint(MemorySegment context, double x, double y) {
        var mh$ = DrawPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPoint", context, x, y);
            }
            mh$.invokeExact(context, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPolygon(DrawContext context, const unsigned long num_coords, const PointInfo *coordinates)
     * }
     */
    public static FunctionDescriptor DrawPolygon$descriptor() {
        return DrawPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPolygon(DrawContext context, const unsigned long num_coords, const PointInfo *coordinates)
     * }
     */
    public static MethodHandle DrawPolygon$handle() {
        return DrawPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPolygon(DrawContext context, const unsigned long num_coords, const PointInfo *coordinates)
     * }
     */
    public static MemorySegment DrawPolygon$address() {
        return DrawPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPolygon(DrawContext context, const unsigned long num_coords, const PointInfo *coordinates)
     * }
     */
    public static void DrawPolygon(MemorySegment context, long num_coords, MemorySegment coordinates) {
        var mh$ = DrawPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPolygon", context, num_coords, coordinates);
            }
            mh$.invokeExact(context, num_coords, coordinates);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPolyline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPolyline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPolyline(DrawContext context, const unsigned long num_coords, const PointInfo *coordinates)
     * }
     */
    public static FunctionDescriptor DrawPolyline$descriptor() {
        return DrawPolyline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPolyline(DrawContext context, const unsigned long num_coords, const PointInfo *coordinates)
     * }
     */
    public static MethodHandle DrawPolyline$handle() {
        return DrawPolyline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPolyline(DrawContext context, const unsigned long num_coords, const PointInfo *coordinates)
     * }
     */
    public static MemorySegment DrawPolyline$address() {
        return DrawPolyline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPolyline(DrawContext context, const unsigned long num_coords, const PointInfo *coordinates)
     * }
     */
    public static void DrawPolyline(MemorySegment context, long num_coords, MemorySegment coordinates) {
        var mh$ = DrawPolyline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPolyline", context, num_coords, coordinates);
            }
            mh$.invokeExact(context, num_coords, coordinates);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPopClipPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPopClipPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPopClipPath(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawPopClipPath$descriptor() {
        return DrawPopClipPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPopClipPath(DrawContext context)
     * }
     */
    public static MethodHandle DrawPopClipPath$handle() {
        return DrawPopClipPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPopClipPath(DrawContext context)
     * }
     */
    public static MemorySegment DrawPopClipPath$address() {
        return DrawPopClipPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPopClipPath(DrawContext context)
     * }
     */
    public static void DrawPopClipPath(MemorySegment context) {
        var mh$ = DrawPopClipPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPopClipPath", context);
            }
            mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPopDefs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPopDefs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPopDefs(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawPopDefs$descriptor() {
        return DrawPopDefs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPopDefs(DrawContext context)
     * }
     */
    public static MethodHandle DrawPopDefs$handle() {
        return DrawPopDefs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPopDefs(DrawContext context)
     * }
     */
    public static MemorySegment DrawPopDefs$address() {
        return DrawPopDefs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPopDefs(DrawContext context)
     * }
     */
    public static void DrawPopDefs(MemorySegment context) {
        var mh$ = DrawPopDefs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPopDefs", context);
            }
            mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPopGraphicContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPopGraphicContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPopGraphicContext(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawPopGraphicContext$descriptor() {
        return DrawPopGraphicContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPopGraphicContext(DrawContext context)
     * }
     */
    public static MethodHandle DrawPopGraphicContext$handle() {
        return DrawPopGraphicContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPopGraphicContext(DrawContext context)
     * }
     */
    public static MemorySegment DrawPopGraphicContext$address() {
        return DrawPopGraphicContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPopGraphicContext(DrawContext context)
     * }
     */
    public static void DrawPopGraphicContext(MemorySegment context) {
        var mh$ = DrawPopGraphicContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPopGraphicContext", context);
            }
            mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPopPattern {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPopPattern");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPopPattern(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawPopPattern$descriptor() {
        return DrawPopPattern.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPopPattern(DrawContext context)
     * }
     */
    public static MethodHandle DrawPopPattern$handle() {
        return DrawPopPattern.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPopPattern(DrawContext context)
     * }
     */
    public static MemorySegment DrawPopPattern$address() {
        return DrawPopPattern.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPopPattern(DrawContext context)
     * }
     */
    public static void DrawPopPattern(MemorySegment context) {
        var mh$ = DrawPopPattern.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPopPattern", context);
            }
            mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPushClipPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPushClipPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPushClipPath(DrawContext context, const char *clip_path_id)
     * }
     */
    public static FunctionDescriptor DrawPushClipPath$descriptor() {
        return DrawPushClipPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPushClipPath(DrawContext context, const char *clip_path_id)
     * }
     */
    public static MethodHandle DrawPushClipPath$handle() {
        return DrawPushClipPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPushClipPath(DrawContext context, const char *clip_path_id)
     * }
     */
    public static MemorySegment DrawPushClipPath$address() {
        return DrawPushClipPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPushClipPath(DrawContext context, const char *clip_path_id)
     * }
     */
    public static void DrawPushClipPath(MemorySegment context, MemorySegment clip_path_id) {
        var mh$ = DrawPushClipPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPushClipPath", context, clip_path_id);
            }
            mh$.invokeExact(context, clip_path_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPushDefs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPushDefs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPushDefs(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawPushDefs$descriptor() {
        return DrawPushDefs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPushDefs(DrawContext context)
     * }
     */
    public static MethodHandle DrawPushDefs$handle() {
        return DrawPushDefs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPushDefs(DrawContext context)
     * }
     */
    public static MemorySegment DrawPushDefs$address() {
        return DrawPushDefs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPushDefs(DrawContext context)
     * }
     */
    public static void DrawPushDefs(MemorySegment context) {
        var mh$ = DrawPushDefs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPushDefs", context);
            }
            mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPushGraphicContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPushGraphicContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPushGraphicContext(DrawContext context)
     * }
     */
    public static FunctionDescriptor DrawPushGraphicContext$descriptor() {
        return DrawPushGraphicContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPushGraphicContext(DrawContext context)
     * }
     */
    public static MethodHandle DrawPushGraphicContext$handle() {
        return DrawPushGraphicContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPushGraphicContext(DrawContext context)
     * }
     */
    public static MemorySegment DrawPushGraphicContext$address() {
        return DrawPushGraphicContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPushGraphicContext(DrawContext context)
     * }
     */
    public static void DrawPushGraphicContext(MemorySegment context) {
        var mh$ = DrawPushGraphicContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPushGraphicContext", context);
            }
            mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawPushPattern {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawPushPattern");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawPushPattern(DrawContext context, const char *pattern_id, const double x, const double y, const double width, const double height)
     * }
     */
    public static FunctionDescriptor DrawPushPattern$descriptor() {
        return DrawPushPattern.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawPushPattern(DrawContext context, const char *pattern_id, const double x, const double y, const double width, const double height)
     * }
     */
    public static MethodHandle DrawPushPattern$handle() {
        return DrawPushPattern.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawPushPattern(DrawContext context, const char *pattern_id, const double x, const double y, const double width, const double height)
     * }
     */
    public static MemorySegment DrawPushPattern$address() {
        return DrawPushPattern.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawPushPattern(DrawContext context, const char *pattern_id, const double x, const double y, const double width, const double height)
     * }
     */
    public static void DrawPushPattern(MemorySegment context, MemorySegment pattern_id, double x, double y, double width, double height) {
        var mh$ = DrawPushPattern.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawPushPattern", context, pattern_id, x, y, width, height);
            }
            mh$.invokeExact(context, pattern_id, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawRectangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawRectangle(DrawContext context, const double x1, const double y1, const double x2, const double y2)
     * }
     */
    public static FunctionDescriptor DrawRectangle$descriptor() {
        return DrawRectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawRectangle(DrawContext context, const double x1, const double y1, const double x2, const double y2)
     * }
     */
    public static MethodHandle DrawRectangle$handle() {
        return DrawRectangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawRectangle(DrawContext context, const double x1, const double y1, const double x2, const double y2)
     * }
     */
    public static MemorySegment DrawRectangle$address() {
        return DrawRectangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawRectangle(DrawContext context, const double x1, const double y1, const double x2, const double y2)
     * }
     */
    public static void DrawRectangle(MemorySegment context, double x1, double y1, double x2, double y2) {
        var mh$ = DrawRectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRectangle", context, x1, y1, x2, y2);
            }
            mh$.invokeExact(context, x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRoundRectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawRoundRectangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawRoundRectangle(DrawContext context, double x1, double y1, double x2, double y2, double rx, double ry)
     * }
     */
    public static FunctionDescriptor DrawRoundRectangle$descriptor() {
        return DrawRoundRectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawRoundRectangle(DrawContext context, double x1, double y1, double x2, double y2, double rx, double ry)
     * }
     */
    public static MethodHandle DrawRoundRectangle$handle() {
        return DrawRoundRectangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawRoundRectangle(DrawContext context, double x1, double y1, double x2, double y2, double rx, double ry)
     * }
     */
    public static MemorySegment DrawRoundRectangle$address() {
        return DrawRoundRectangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawRoundRectangle(DrawContext context, double x1, double y1, double x2, double y2, double rx, double ry)
     * }
     */
    public static void DrawRoundRectangle(MemorySegment context, double x1, double y1, double x2, double y2, double rx, double ry) {
        var mh$ = DrawRoundRectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRoundRectangle", context, x1, y1, x2, y2, rx, ry);
            }
            mh$.invokeExact(context, x1, y1, x2, y2, rx, ry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawScale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawScale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawScale(DrawContext context, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawScale$descriptor() {
        return DrawScale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawScale(DrawContext context, const double x, const double y)
     * }
     */
    public static MethodHandle DrawScale$handle() {
        return DrawScale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawScale(DrawContext context, const double x, const double y)
     * }
     */
    public static MemorySegment DrawScale$address() {
        return DrawScale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawScale(DrawContext context, const double x, const double y)
     * }
     */
    public static void DrawScale(MemorySegment context, double x, double y) {
        var mh$ = DrawScale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawScale", context, x, y);
            }
            mh$.invokeExact(context, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetClipPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetClipPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetClipPath(DrawContext context, const char *clip_path)
     * }
     */
    public static FunctionDescriptor DrawSetClipPath$descriptor() {
        return DrawSetClipPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetClipPath(DrawContext context, const char *clip_path)
     * }
     */
    public static MethodHandle DrawSetClipPath$handle() {
        return DrawSetClipPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetClipPath(DrawContext context, const char *clip_path)
     * }
     */
    public static MemorySegment DrawSetClipPath$address() {
        return DrawSetClipPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetClipPath(DrawContext context, const char *clip_path)
     * }
     */
    public static void DrawSetClipPath(MemorySegment context, MemorySegment clip_path) {
        var mh$ = DrawSetClipPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetClipPath", context, clip_path);
            }
            mh$.invokeExact(context, clip_path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetClipRule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetClipRule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetClipRule(DrawContext context, const FillRule fill_rule)
     * }
     */
    public static FunctionDescriptor DrawSetClipRule$descriptor() {
        return DrawSetClipRule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetClipRule(DrawContext context, const FillRule fill_rule)
     * }
     */
    public static MethodHandle DrawSetClipRule$handle() {
        return DrawSetClipRule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetClipRule(DrawContext context, const FillRule fill_rule)
     * }
     */
    public static MemorySegment DrawSetClipRule$address() {
        return DrawSetClipRule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetClipRule(DrawContext context, const FillRule fill_rule)
     * }
     */
    public static void DrawSetClipRule(MemorySegment context, int fill_rule) {
        var mh$ = DrawSetClipRule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetClipRule", context, fill_rule);
            }
            mh$.invokeExact(context, fill_rule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetClipUnits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetClipUnits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetClipUnits(DrawContext context, const ClipPathUnits clip_units)
     * }
     */
    public static FunctionDescriptor DrawSetClipUnits$descriptor() {
        return DrawSetClipUnits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetClipUnits(DrawContext context, const ClipPathUnits clip_units)
     * }
     */
    public static MethodHandle DrawSetClipUnits$handle() {
        return DrawSetClipUnits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetClipUnits(DrawContext context, const ClipPathUnits clip_units)
     * }
     */
    public static MemorySegment DrawSetClipUnits$address() {
        return DrawSetClipUnits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetClipUnits(DrawContext context, const ClipPathUnits clip_units)
     * }
     */
    public static void DrawSetClipUnits(MemorySegment context, int clip_units) {
        var mh$ = DrawSetClipUnits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetClipUnits", context, clip_units);
            }
            mh$.invokeExact(context, clip_units);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetFillColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetFillColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetFillColor(DrawContext context, const PixelPacket *fill_color)
     * }
     */
    public static FunctionDescriptor DrawSetFillColor$descriptor() {
        return DrawSetFillColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetFillColor(DrawContext context, const PixelPacket *fill_color)
     * }
     */
    public static MethodHandle DrawSetFillColor$handle() {
        return DrawSetFillColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetFillColor(DrawContext context, const PixelPacket *fill_color)
     * }
     */
    public static MemorySegment DrawSetFillColor$address() {
        return DrawSetFillColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetFillColor(DrawContext context, const PixelPacket *fill_color)
     * }
     */
    public static void DrawSetFillColor(MemorySegment context, MemorySegment fill_color) {
        var mh$ = DrawSetFillColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetFillColor", context, fill_color);
            }
            mh$.invokeExact(context, fill_color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetFillColorString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetFillColorString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetFillColorString(DrawContext context, const char *fill_color)
     * }
     */
    public static FunctionDescriptor DrawSetFillColorString$descriptor() {
        return DrawSetFillColorString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetFillColorString(DrawContext context, const char *fill_color)
     * }
     */
    public static MethodHandle DrawSetFillColorString$handle() {
        return DrawSetFillColorString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetFillColorString(DrawContext context, const char *fill_color)
     * }
     */
    public static MemorySegment DrawSetFillColorString$address() {
        return DrawSetFillColorString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetFillColorString(DrawContext context, const char *fill_color)
     * }
     */
    public static void DrawSetFillColorString(MemorySegment context, MemorySegment fill_color) {
        var mh$ = DrawSetFillColorString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetFillColorString", context, fill_color);
            }
            mh$.invokeExact(context, fill_color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetFillOpacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetFillOpacity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetFillOpacity(DrawContext context, const double fill_opacity)
     * }
     */
    public static FunctionDescriptor DrawSetFillOpacity$descriptor() {
        return DrawSetFillOpacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetFillOpacity(DrawContext context, const double fill_opacity)
     * }
     */
    public static MethodHandle DrawSetFillOpacity$handle() {
        return DrawSetFillOpacity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetFillOpacity(DrawContext context, const double fill_opacity)
     * }
     */
    public static MemorySegment DrawSetFillOpacity$address() {
        return DrawSetFillOpacity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetFillOpacity(DrawContext context, const double fill_opacity)
     * }
     */
    public static void DrawSetFillOpacity(MemorySegment context, double fill_opacity) {
        var mh$ = DrawSetFillOpacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetFillOpacity", context, fill_opacity);
            }
            mh$.invokeExact(context, fill_opacity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetFillRule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetFillRule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetFillRule(DrawContext context, const FillRule fill_rule)
     * }
     */
    public static FunctionDescriptor DrawSetFillRule$descriptor() {
        return DrawSetFillRule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetFillRule(DrawContext context, const FillRule fill_rule)
     * }
     */
    public static MethodHandle DrawSetFillRule$handle() {
        return DrawSetFillRule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetFillRule(DrawContext context, const FillRule fill_rule)
     * }
     */
    public static MemorySegment DrawSetFillRule$address() {
        return DrawSetFillRule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetFillRule(DrawContext context, const FillRule fill_rule)
     * }
     */
    public static void DrawSetFillRule(MemorySegment context, int fill_rule) {
        var mh$ = DrawSetFillRule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetFillRule", context, fill_rule);
            }
            mh$.invokeExact(context, fill_rule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetFillPatternURL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetFillPatternURL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetFillPatternURL(DrawContext context, const char *fill_url)
     * }
     */
    public static FunctionDescriptor DrawSetFillPatternURL$descriptor() {
        return DrawSetFillPatternURL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetFillPatternURL(DrawContext context, const char *fill_url)
     * }
     */
    public static MethodHandle DrawSetFillPatternURL$handle() {
        return DrawSetFillPatternURL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetFillPatternURL(DrawContext context, const char *fill_url)
     * }
     */
    public static MemorySegment DrawSetFillPatternURL$address() {
        return DrawSetFillPatternURL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetFillPatternURL(DrawContext context, const char *fill_url)
     * }
     */
    public static void DrawSetFillPatternURL(MemorySegment context, MemorySegment fill_url) {
        var mh$ = DrawSetFillPatternURL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetFillPatternURL", context, fill_url);
            }
            mh$.invokeExact(context, fill_url);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetFont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetFont(DrawContext context, const char *font_name)
     * }
     */
    public static FunctionDescriptor DrawSetFont$descriptor() {
        return DrawSetFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetFont(DrawContext context, const char *font_name)
     * }
     */
    public static MethodHandle DrawSetFont$handle() {
        return DrawSetFont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetFont(DrawContext context, const char *font_name)
     * }
     */
    public static MemorySegment DrawSetFont$address() {
        return DrawSetFont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetFont(DrawContext context, const char *font_name)
     * }
     */
    public static void DrawSetFont(MemorySegment context, MemorySegment font_name) {
        var mh$ = DrawSetFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetFont", context, font_name);
            }
            mh$.invokeExact(context, font_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetFontFamily {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetFontFamily");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetFontFamily(DrawContext context, const char *font_family)
     * }
     */
    public static FunctionDescriptor DrawSetFontFamily$descriptor() {
        return DrawSetFontFamily.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetFontFamily(DrawContext context, const char *font_family)
     * }
     */
    public static MethodHandle DrawSetFontFamily$handle() {
        return DrawSetFontFamily.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetFontFamily(DrawContext context, const char *font_family)
     * }
     */
    public static MemorySegment DrawSetFontFamily$address() {
        return DrawSetFontFamily.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetFontFamily(DrawContext context, const char *font_family)
     * }
     */
    public static void DrawSetFontFamily(MemorySegment context, MemorySegment font_family) {
        var mh$ = DrawSetFontFamily.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetFontFamily", context, font_family);
            }
            mh$.invokeExact(context, font_family);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetFontSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetFontSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetFontSize(DrawContext context, const double font_pointsize)
     * }
     */
    public static FunctionDescriptor DrawSetFontSize$descriptor() {
        return DrawSetFontSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetFontSize(DrawContext context, const double font_pointsize)
     * }
     */
    public static MethodHandle DrawSetFontSize$handle() {
        return DrawSetFontSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetFontSize(DrawContext context, const double font_pointsize)
     * }
     */
    public static MemorySegment DrawSetFontSize$address() {
        return DrawSetFontSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetFontSize(DrawContext context, const double font_pointsize)
     * }
     */
    public static void DrawSetFontSize(MemorySegment context, double font_pointsize) {
        var mh$ = DrawSetFontSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetFontSize", context, font_pointsize);
            }
            mh$.invokeExact(context, font_pointsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetFontStretch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetFontStretch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetFontStretch(DrawContext context, const StretchType font_stretch)
     * }
     */
    public static FunctionDescriptor DrawSetFontStretch$descriptor() {
        return DrawSetFontStretch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetFontStretch(DrawContext context, const StretchType font_stretch)
     * }
     */
    public static MethodHandle DrawSetFontStretch$handle() {
        return DrawSetFontStretch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetFontStretch(DrawContext context, const StretchType font_stretch)
     * }
     */
    public static MemorySegment DrawSetFontStretch$address() {
        return DrawSetFontStretch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetFontStretch(DrawContext context, const StretchType font_stretch)
     * }
     */
    public static void DrawSetFontStretch(MemorySegment context, int font_stretch) {
        var mh$ = DrawSetFontStretch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetFontStretch", context, font_stretch);
            }
            mh$.invokeExact(context, font_stretch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetFontStyle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetFontStyle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetFontStyle(DrawContext context, const StyleType font_style)
     * }
     */
    public static FunctionDescriptor DrawSetFontStyle$descriptor() {
        return DrawSetFontStyle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetFontStyle(DrawContext context, const StyleType font_style)
     * }
     */
    public static MethodHandle DrawSetFontStyle$handle() {
        return DrawSetFontStyle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetFontStyle(DrawContext context, const StyleType font_style)
     * }
     */
    public static MemorySegment DrawSetFontStyle$address() {
        return DrawSetFontStyle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetFontStyle(DrawContext context, const StyleType font_style)
     * }
     */
    public static void DrawSetFontStyle(MemorySegment context, int font_style) {
        var mh$ = DrawSetFontStyle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetFontStyle", context, font_style);
            }
            mh$.invokeExact(context, font_style);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetFontWeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetFontWeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetFontWeight(DrawContext context, const unsigned long font_weight)
     * }
     */
    public static FunctionDescriptor DrawSetFontWeight$descriptor() {
        return DrawSetFontWeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetFontWeight(DrawContext context, const unsigned long font_weight)
     * }
     */
    public static MethodHandle DrawSetFontWeight$handle() {
        return DrawSetFontWeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetFontWeight(DrawContext context, const unsigned long font_weight)
     * }
     */
    public static MemorySegment DrawSetFontWeight$address() {
        return DrawSetFontWeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetFontWeight(DrawContext context, const unsigned long font_weight)
     * }
     */
    public static void DrawSetFontWeight(MemorySegment context, long font_weight) {
        var mh$ = DrawSetFontWeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetFontWeight", context, font_weight);
            }
            mh$.invokeExact(context, font_weight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetGravity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetGravity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetGravity(DrawContext context, const GravityType gravity)
     * }
     */
    public static FunctionDescriptor DrawSetGravity$descriptor() {
        return DrawSetGravity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetGravity(DrawContext context, const GravityType gravity)
     * }
     */
    public static MethodHandle DrawSetGravity$handle() {
        return DrawSetGravity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetGravity(DrawContext context, const GravityType gravity)
     * }
     */
    public static MemorySegment DrawSetGravity$address() {
        return DrawSetGravity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetGravity(DrawContext context, const GravityType gravity)
     * }
     */
    public static void DrawSetGravity(MemorySegment context, int gravity) {
        var mh$ = DrawSetGravity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetGravity", context, gravity);
            }
            mh$.invokeExact(context, gravity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRotate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawRotate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawRotate(DrawContext context, const double degrees)
     * }
     */
    public static FunctionDescriptor DrawRotate$descriptor() {
        return DrawRotate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawRotate(DrawContext context, const double degrees)
     * }
     */
    public static MethodHandle DrawRotate$handle() {
        return DrawRotate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawRotate(DrawContext context, const double degrees)
     * }
     */
    public static MemorySegment DrawRotate$address() {
        return DrawRotate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawRotate(DrawContext context, const double degrees)
     * }
     */
    public static void DrawRotate(MemorySegment context, double degrees) {
        var mh$ = DrawRotate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRotate", context, degrees);
            }
            mh$.invokeExact(context, degrees);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSkewX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSkewX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSkewX(DrawContext context, const double degrees)
     * }
     */
    public static FunctionDescriptor DrawSkewX$descriptor() {
        return DrawSkewX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSkewX(DrawContext context, const double degrees)
     * }
     */
    public static MethodHandle DrawSkewX$handle() {
        return DrawSkewX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSkewX(DrawContext context, const double degrees)
     * }
     */
    public static MemorySegment DrawSkewX$address() {
        return DrawSkewX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSkewX(DrawContext context, const double degrees)
     * }
     */
    public static void DrawSkewX(MemorySegment context, double degrees) {
        var mh$ = DrawSkewX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSkewX", context, degrees);
            }
            mh$.invokeExact(context, degrees);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSkewY {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSkewY");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSkewY(DrawContext context, const double degrees)
     * }
     */
    public static FunctionDescriptor DrawSkewY$descriptor() {
        return DrawSkewY.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSkewY(DrawContext context, const double degrees)
     * }
     */
    public static MethodHandle DrawSkewY$handle() {
        return DrawSkewY.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSkewY(DrawContext context, const double degrees)
     * }
     */
    public static MemorySegment DrawSkewY$address() {
        return DrawSkewY.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSkewY(DrawContext context, const double degrees)
     * }
     */
    public static void DrawSkewY(MemorySegment context, double degrees) {
        var mh$ = DrawSkewY.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSkewY", context, degrees);
            }
            mh$.invokeExact(context, degrees);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetStrokeAntialias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetStrokeAntialias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeAntialias(DrawContext context, const unsigned int true_false)
     * }
     */
    public static FunctionDescriptor DrawSetStrokeAntialias$descriptor() {
        return DrawSetStrokeAntialias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeAntialias(DrawContext context, const unsigned int true_false)
     * }
     */
    public static MethodHandle DrawSetStrokeAntialias$handle() {
        return DrawSetStrokeAntialias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeAntialias(DrawContext context, const unsigned int true_false)
     * }
     */
    public static MemorySegment DrawSetStrokeAntialias$address() {
        return DrawSetStrokeAntialias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetStrokeAntialias(DrawContext context, const unsigned int true_false)
     * }
     */
    public static void DrawSetStrokeAntialias(MemorySegment context, int true_false) {
        var mh$ = DrawSetStrokeAntialias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetStrokeAntialias", context, true_false);
            }
            mh$.invokeExact(context, true_false);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetStrokeColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetStrokeColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeColor(DrawContext context, const PixelPacket *stroke_color)
     * }
     */
    public static FunctionDescriptor DrawSetStrokeColor$descriptor() {
        return DrawSetStrokeColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeColor(DrawContext context, const PixelPacket *stroke_color)
     * }
     */
    public static MethodHandle DrawSetStrokeColor$handle() {
        return DrawSetStrokeColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeColor(DrawContext context, const PixelPacket *stroke_color)
     * }
     */
    public static MemorySegment DrawSetStrokeColor$address() {
        return DrawSetStrokeColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetStrokeColor(DrawContext context, const PixelPacket *stroke_color)
     * }
     */
    public static void DrawSetStrokeColor(MemorySegment context, MemorySegment stroke_color) {
        var mh$ = DrawSetStrokeColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetStrokeColor", context, stroke_color);
            }
            mh$.invokeExact(context, stroke_color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetStrokeColorString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetStrokeColorString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeColorString(DrawContext context, const char *stroke_color)
     * }
     */
    public static FunctionDescriptor DrawSetStrokeColorString$descriptor() {
        return DrawSetStrokeColorString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeColorString(DrawContext context, const char *stroke_color)
     * }
     */
    public static MethodHandle DrawSetStrokeColorString$handle() {
        return DrawSetStrokeColorString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeColorString(DrawContext context, const char *stroke_color)
     * }
     */
    public static MemorySegment DrawSetStrokeColorString$address() {
        return DrawSetStrokeColorString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetStrokeColorString(DrawContext context, const char *stroke_color)
     * }
     */
    public static void DrawSetStrokeColorString(MemorySegment context, MemorySegment stroke_color) {
        var mh$ = DrawSetStrokeColorString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetStrokeColorString", context, stroke_color);
            }
            mh$.invokeExact(context, stroke_color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetStrokeDashArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetStrokeDashArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeDashArray(DrawContext context, const unsigned long num_elems, const double *dasharray)
     * }
     */
    public static FunctionDescriptor DrawSetStrokeDashArray$descriptor() {
        return DrawSetStrokeDashArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeDashArray(DrawContext context, const unsigned long num_elems, const double *dasharray)
     * }
     */
    public static MethodHandle DrawSetStrokeDashArray$handle() {
        return DrawSetStrokeDashArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeDashArray(DrawContext context, const unsigned long num_elems, const double *dasharray)
     * }
     */
    public static MemorySegment DrawSetStrokeDashArray$address() {
        return DrawSetStrokeDashArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetStrokeDashArray(DrawContext context, const unsigned long num_elems, const double *dasharray)
     * }
     */
    public static void DrawSetStrokeDashArray(MemorySegment context, long num_elems, MemorySegment dasharray) {
        var mh$ = DrawSetStrokeDashArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetStrokeDashArray", context, num_elems, dasharray);
            }
            mh$.invokeExact(context, num_elems, dasharray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetStrokeDashOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetStrokeDashOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeDashOffset(DrawContext context, const double dashoffset)
     * }
     */
    public static FunctionDescriptor DrawSetStrokeDashOffset$descriptor() {
        return DrawSetStrokeDashOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeDashOffset(DrawContext context, const double dashoffset)
     * }
     */
    public static MethodHandle DrawSetStrokeDashOffset$handle() {
        return DrawSetStrokeDashOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeDashOffset(DrawContext context, const double dashoffset)
     * }
     */
    public static MemorySegment DrawSetStrokeDashOffset$address() {
        return DrawSetStrokeDashOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetStrokeDashOffset(DrawContext context, const double dashoffset)
     * }
     */
    public static void DrawSetStrokeDashOffset(MemorySegment context, double dashoffset) {
        var mh$ = DrawSetStrokeDashOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetStrokeDashOffset", context, dashoffset);
            }
            mh$.invokeExact(context, dashoffset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetStrokeLineCap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetStrokeLineCap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeLineCap(DrawContext context, const LineCap linecap)
     * }
     */
    public static FunctionDescriptor DrawSetStrokeLineCap$descriptor() {
        return DrawSetStrokeLineCap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeLineCap(DrawContext context, const LineCap linecap)
     * }
     */
    public static MethodHandle DrawSetStrokeLineCap$handle() {
        return DrawSetStrokeLineCap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeLineCap(DrawContext context, const LineCap linecap)
     * }
     */
    public static MemorySegment DrawSetStrokeLineCap$address() {
        return DrawSetStrokeLineCap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetStrokeLineCap(DrawContext context, const LineCap linecap)
     * }
     */
    public static void DrawSetStrokeLineCap(MemorySegment context, int linecap) {
        var mh$ = DrawSetStrokeLineCap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetStrokeLineCap", context, linecap);
            }
            mh$.invokeExact(context, linecap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetStrokeLineJoin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetStrokeLineJoin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeLineJoin(DrawContext context, const LineJoin linejoin)
     * }
     */
    public static FunctionDescriptor DrawSetStrokeLineJoin$descriptor() {
        return DrawSetStrokeLineJoin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeLineJoin(DrawContext context, const LineJoin linejoin)
     * }
     */
    public static MethodHandle DrawSetStrokeLineJoin$handle() {
        return DrawSetStrokeLineJoin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeLineJoin(DrawContext context, const LineJoin linejoin)
     * }
     */
    public static MemorySegment DrawSetStrokeLineJoin$address() {
        return DrawSetStrokeLineJoin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetStrokeLineJoin(DrawContext context, const LineJoin linejoin)
     * }
     */
    public static void DrawSetStrokeLineJoin(MemorySegment context, int linejoin) {
        var mh$ = DrawSetStrokeLineJoin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetStrokeLineJoin", context, linejoin);
            }
            mh$.invokeExact(context, linejoin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetStrokeMiterLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetStrokeMiterLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeMiterLimit(DrawContext context, const unsigned long miterlimit)
     * }
     */
    public static FunctionDescriptor DrawSetStrokeMiterLimit$descriptor() {
        return DrawSetStrokeMiterLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeMiterLimit(DrawContext context, const unsigned long miterlimit)
     * }
     */
    public static MethodHandle DrawSetStrokeMiterLimit$handle() {
        return DrawSetStrokeMiterLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeMiterLimit(DrawContext context, const unsigned long miterlimit)
     * }
     */
    public static MemorySegment DrawSetStrokeMiterLimit$address() {
        return DrawSetStrokeMiterLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetStrokeMiterLimit(DrawContext context, const unsigned long miterlimit)
     * }
     */
    public static void DrawSetStrokeMiterLimit(MemorySegment context, long miterlimit) {
        var mh$ = DrawSetStrokeMiterLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetStrokeMiterLimit", context, miterlimit);
            }
            mh$.invokeExact(context, miterlimit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetStrokeOpacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetStrokeOpacity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeOpacity(DrawContext context, const double opacity)
     * }
     */
    public static FunctionDescriptor DrawSetStrokeOpacity$descriptor() {
        return DrawSetStrokeOpacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeOpacity(DrawContext context, const double opacity)
     * }
     */
    public static MethodHandle DrawSetStrokeOpacity$handle() {
        return DrawSetStrokeOpacity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeOpacity(DrawContext context, const double opacity)
     * }
     */
    public static MemorySegment DrawSetStrokeOpacity$address() {
        return DrawSetStrokeOpacity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetStrokeOpacity(DrawContext context, const double opacity)
     * }
     */
    public static void DrawSetStrokeOpacity(MemorySegment context, double opacity) {
        var mh$ = DrawSetStrokeOpacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetStrokeOpacity", context, opacity);
            }
            mh$.invokeExact(context, opacity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetStrokePatternURL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetStrokePatternURL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetStrokePatternURL(DrawContext context, const char *stroke_url)
     * }
     */
    public static FunctionDescriptor DrawSetStrokePatternURL$descriptor() {
        return DrawSetStrokePatternURL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetStrokePatternURL(DrawContext context, const char *stroke_url)
     * }
     */
    public static MethodHandle DrawSetStrokePatternURL$handle() {
        return DrawSetStrokePatternURL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetStrokePatternURL(DrawContext context, const char *stroke_url)
     * }
     */
    public static MemorySegment DrawSetStrokePatternURL$address() {
        return DrawSetStrokePatternURL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetStrokePatternURL(DrawContext context, const char *stroke_url)
     * }
     */
    public static void DrawSetStrokePatternURL(MemorySegment context, MemorySegment stroke_url) {
        var mh$ = DrawSetStrokePatternURL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetStrokePatternURL", context, stroke_url);
            }
            mh$.invokeExact(context, stroke_url);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetStrokeWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetStrokeWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeWidth(DrawContext context, const double width)
     * }
     */
    public static FunctionDescriptor DrawSetStrokeWidth$descriptor() {
        return DrawSetStrokeWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeWidth(DrawContext context, const double width)
     * }
     */
    public static MethodHandle DrawSetStrokeWidth$handle() {
        return DrawSetStrokeWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetStrokeWidth(DrawContext context, const double width)
     * }
     */
    public static MemorySegment DrawSetStrokeWidth$address() {
        return DrawSetStrokeWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetStrokeWidth(DrawContext context, const double width)
     * }
     */
    public static void DrawSetStrokeWidth(MemorySegment context, double width) {
        var mh$ = DrawSetStrokeWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetStrokeWidth", context, width);
            }
            mh$.invokeExact(context, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetTextAntialias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetTextAntialias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetTextAntialias(DrawContext context, const unsigned int true_false)
     * }
     */
    public static FunctionDescriptor DrawSetTextAntialias$descriptor() {
        return DrawSetTextAntialias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetTextAntialias(DrawContext context, const unsigned int true_false)
     * }
     */
    public static MethodHandle DrawSetTextAntialias$handle() {
        return DrawSetTextAntialias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetTextAntialias(DrawContext context, const unsigned int true_false)
     * }
     */
    public static MemorySegment DrawSetTextAntialias$address() {
        return DrawSetTextAntialias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetTextAntialias(DrawContext context, const unsigned int true_false)
     * }
     */
    public static void DrawSetTextAntialias(MemorySegment context, int true_false) {
        var mh$ = DrawSetTextAntialias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetTextAntialias", context, true_false);
            }
            mh$.invokeExact(context, true_false);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetTextDecoration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetTextDecoration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetTextDecoration(DrawContext context, const DecorationType decoration)
     * }
     */
    public static FunctionDescriptor DrawSetTextDecoration$descriptor() {
        return DrawSetTextDecoration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetTextDecoration(DrawContext context, const DecorationType decoration)
     * }
     */
    public static MethodHandle DrawSetTextDecoration$handle() {
        return DrawSetTextDecoration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetTextDecoration(DrawContext context, const DecorationType decoration)
     * }
     */
    public static MemorySegment DrawSetTextDecoration$address() {
        return DrawSetTextDecoration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetTextDecoration(DrawContext context, const DecorationType decoration)
     * }
     */
    public static void DrawSetTextDecoration(MemorySegment context, int decoration) {
        var mh$ = DrawSetTextDecoration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetTextDecoration", context, decoration);
            }
            mh$.invokeExact(context, decoration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetTextEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetTextEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetTextEncoding(DrawContext context, const char *encoding)
     * }
     */
    public static FunctionDescriptor DrawSetTextEncoding$descriptor() {
        return DrawSetTextEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetTextEncoding(DrawContext context, const char *encoding)
     * }
     */
    public static MethodHandle DrawSetTextEncoding$handle() {
        return DrawSetTextEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetTextEncoding(DrawContext context, const char *encoding)
     * }
     */
    public static MemorySegment DrawSetTextEncoding$address() {
        return DrawSetTextEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetTextEncoding(DrawContext context, const char *encoding)
     * }
     */
    public static void DrawSetTextEncoding(MemorySegment context, MemorySegment encoding) {
        var mh$ = DrawSetTextEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetTextEncoding", context, encoding);
            }
            mh$.invokeExact(context, encoding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetTextUnderColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetTextUnderColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetTextUnderColor(DrawContext context, const PixelPacket *color)
     * }
     */
    public static FunctionDescriptor DrawSetTextUnderColor$descriptor() {
        return DrawSetTextUnderColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetTextUnderColor(DrawContext context, const PixelPacket *color)
     * }
     */
    public static MethodHandle DrawSetTextUnderColor$handle() {
        return DrawSetTextUnderColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetTextUnderColor(DrawContext context, const PixelPacket *color)
     * }
     */
    public static MemorySegment DrawSetTextUnderColor$address() {
        return DrawSetTextUnderColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetTextUnderColor(DrawContext context, const PixelPacket *color)
     * }
     */
    public static void DrawSetTextUnderColor(MemorySegment context, MemorySegment color) {
        var mh$ = DrawSetTextUnderColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetTextUnderColor", context, color);
            }
            mh$.invokeExact(context, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetTextUnderColorString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetTextUnderColorString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetTextUnderColorString(DrawContext context, const char *under_color)
     * }
     */
    public static FunctionDescriptor DrawSetTextUnderColorString$descriptor() {
        return DrawSetTextUnderColorString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetTextUnderColorString(DrawContext context, const char *under_color)
     * }
     */
    public static MethodHandle DrawSetTextUnderColorString$handle() {
        return DrawSetTextUnderColorString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetTextUnderColorString(DrawContext context, const char *under_color)
     * }
     */
    public static MemorySegment DrawSetTextUnderColorString$address() {
        return DrawSetTextUnderColorString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetTextUnderColorString(DrawContext context, const char *under_color)
     * }
     */
    public static void DrawSetTextUnderColorString(MemorySegment context, MemorySegment under_color) {
        var mh$ = DrawSetTextUnderColorString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetTextUnderColorString", context, under_color);
            }
            mh$.invokeExact(context, under_color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawSetViewbox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawSetViewbox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawSetViewbox(DrawContext context, unsigned long x1, unsigned long y1, unsigned long x2, unsigned long y2)
     * }
     */
    public static FunctionDescriptor DrawSetViewbox$descriptor() {
        return DrawSetViewbox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawSetViewbox(DrawContext context, unsigned long x1, unsigned long y1, unsigned long x2, unsigned long y2)
     * }
     */
    public static MethodHandle DrawSetViewbox$handle() {
        return DrawSetViewbox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawSetViewbox(DrawContext context, unsigned long x1, unsigned long y1, unsigned long x2, unsigned long y2)
     * }
     */
    public static MemorySegment DrawSetViewbox$address() {
        return DrawSetViewbox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawSetViewbox(DrawContext context, unsigned long x1, unsigned long y1, unsigned long x2, unsigned long y2)
     * }
     */
    public static void DrawSetViewbox(MemorySegment context, long x1, long y1, long x2, long y2) {
        var mh$ = DrawSetViewbox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawSetViewbox", context, x1, y1, x2, y2);
            }
            mh$.invokeExact(context, x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTranslate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DrawTranslate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DrawTranslate(DrawContext context, const double x, const double y)
     * }
     */
    public static FunctionDescriptor DrawTranslate$descriptor() {
        return DrawTranslate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DrawTranslate(DrawContext context, const double x, const double y)
     * }
     */
    public static MethodHandle DrawTranslate$handle() {
        return DrawTranslate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DrawTranslate(DrawContext context, const double x, const double y)
     * }
     */
    public static MemorySegment DrawTranslate$address() {
        return DrawTranslate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DrawTranslate(DrawContext context, const double x, const double y)
     * }
     */
    public static void DrawTranslate(MemorySegment context, double x, double y) {
        var mh$ = DrawTranslate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTranslate", context, x, y);
            }
            mh$.invokeExact(context, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdaptiveThresholdImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AdaptiveThresholdImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *AdaptiveThresholdImage(const Image *, const unsigned long, const unsigned long, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor AdaptiveThresholdImage$descriptor() {
        return AdaptiveThresholdImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *AdaptiveThresholdImage(const Image *, const unsigned long, const unsigned long, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle AdaptiveThresholdImage$handle() {
        return AdaptiveThresholdImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *AdaptiveThresholdImage(const Image *, const unsigned long, const unsigned long, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment AdaptiveThresholdImage$address() {
        return AdaptiveThresholdImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *AdaptiveThresholdImage(const Image *, const unsigned long, const unsigned long, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment AdaptiveThresholdImage(MemorySegment x0, long x1, long x2, double x3, MemorySegment x4) {
        var mh$ = AdaptiveThresholdImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdaptiveThresholdImage", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddNoiseImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AddNoiseImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *AddNoiseImage(const Image *, const NoiseType, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor AddNoiseImage$descriptor() {
        return AddNoiseImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *AddNoiseImage(const Image *, const NoiseType, ExceptionInfo *)
     * }
     */
    public static MethodHandle AddNoiseImage$handle() {
        return AddNoiseImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *AddNoiseImage(const Image *, const NoiseType, ExceptionInfo *)
     * }
     */
    public static MemorySegment AddNoiseImage$address() {
        return AddNoiseImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *AddNoiseImage(const Image *, const NoiseType, ExceptionInfo *)
     * }
     */
    public static MemorySegment AddNoiseImage(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = AddNoiseImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddNoiseImage", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddNoiseImageChannel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AddNoiseImageChannel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *AddNoiseImageChannel(const Image *image, const ChannelType channel, const NoiseType noise_type, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor AddNoiseImageChannel$descriptor() {
        return AddNoiseImageChannel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *AddNoiseImageChannel(const Image *image, const ChannelType channel, const NoiseType noise_type, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle AddNoiseImageChannel$handle() {
        return AddNoiseImageChannel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *AddNoiseImageChannel(const Image *image, const ChannelType channel, const NoiseType noise_type, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment AddNoiseImageChannel$address() {
        return AddNoiseImageChannel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *AddNoiseImageChannel(const Image *image, const ChannelType channel, const NoiseType noise_type, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment AddNoiseImageChannel(MemorySegment image, int channel, int noise_type, MemorySegment exception) {
        var mh$ = AddNoiseImageChannel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddNoiseImageChannel", image, channel, noise_type, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, channel, noise_type, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BlurImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("BlurImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *BlurImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor BlurImage$descriptor() {
        return BlurImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *BlurImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle BlurImage$handle() {
        return BlurImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *BlurImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment BlurImage$address() {
        return BlurImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *BlurImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment BlurImage(MemorySegment x0, double x1, double x2, MemorySegment x3) {
        var mh$ = BlurImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BlurImage", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BlurImageChannel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("BlurImageChannel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *BlurImageChannel(const Image *image, const ChannelType channel, const double radius, const double sigma, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor BlurImageChannel$descriptor() {
        return BlurImageChannel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *BlurImageChannel(const Image *image, const ChannelType channel, const double radius, const double sigma, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle BlurImageChannel$handle() {
        return BlurImageChannel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *BlurImageChannel(const Image *image, const ChannelType channel, const double radius, const double sigma, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment BlurImageChannel$address() {
        return BlurImageChannel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *BlurImageChannel(const Image *image, const ChannelType channel, const double radius, const double sigma, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment BlurImageChannel(MemorySegment image, int channel, double radius, double sigma, MemorySegment exception) {
        var mh$ = BlurImageChannel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BlurImageChannel", image, channel, radius, sigma, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, channel, radius, sigma, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvolveImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ConvolveImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ConvolveImage(const Image *, const unsigned int, const double *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor ConvolveImage$descriptor() {
        return ConvolveImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ConvolveImage(const Image *, const unsigned int, const double *, ExceptionInfo *)
     * }
     */
    public static MethodHandle ConvolveImage$handle() {
        return ConvolveImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ConvolveImage(const Image *, const unsigned int, const double *, ExceptionInfo *)
     * }
     */
    public static MemorySegment ConvolveImage$address() {
        return ConvolveImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ConvolveImage(const Image *, const unsigned int, const double *, ExceptionInfo *)
     * }
     */
    public static MemorySegment ConvolveImage(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ConvolveImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvolveImage", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DespeckleImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DespeckleImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *DespeckleImage(const Image *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor DespeckleImage$descriptor() {
        return DespeckleImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *DespeckleImage(const Image *, ExceptionInfo *)
     * }
     */
    public static MethodHandle DespeckleImage$handle() {
        return DespeckleImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *DespeckleImage(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment DespeckleImage$address() {
        return DespeckleImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *DespeckleImage(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment DespeckleImage(MemorySegment x0, MemorySegment x1) {
        var mh$ = DespeckleImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DespeckleImage", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EdgeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("EdgeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *EdgeImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor EdgeImage$descriptor() {
        return EdgeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *EdgeImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle EdgeImage$handle() {
        return EdgeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *EdgeImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment EdgeImage$address() {
        return EdgeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *EdgeImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment EdgeImage(MemorySegment x0, double x1, MemorySegment x2) {
        var mh$ = EdgeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EdgeImage", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EmbossImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("EmbossImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *EmbossImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor EmbossImage$descriptor() {
        return EmbossImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *EmbossImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle EmbossImage$handle() {
        return EmbossImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *EmbossImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment EmbossImage$address() {
        return EmbossImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *EmbossImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment EmbossImage(MemorySegment x0, double x1, double x2, MemorySegment x3) {
        var mh$ = EmbossImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EmbossImage", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnhanceImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("EnhanceImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *EnhanceImage(const Image *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor EnhanceImage$descriptor() {
        return EnhanceImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *EnhanceImage(const Image *, ExceptionInfo *)
     * }
     */
    public static MethodHandle EnhanceImage$handle() {
        return EnhanceImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *EnhanceImage(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment EnhanceImage$address() {
        return EnhanceImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *EnhanceImage(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment EnhanceImage(MemorySegment x0, MemorySegment x1) {
        var mh$ = EnhanceImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnhanceImage", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GaussianBlurImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GaussianBlurImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *GaussianBlurImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor GaussianBlurImage$descriptor() {
        return GaussianBlurImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *GaussianBlurImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle GaussianBlurImage$handle() {
        return GaussianBlurImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *GaussianBlurImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment GaussianBlurImage$address() {
        return GaussianBlurImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *GaussianBlurImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment GaussianBlurImage(MemorySegment x0, double x1, double x2, MemorySegment x3) {
        var mh$ = GaussianBlurImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GaussianBlurImage", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GaussianBlurImageChannel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GaussianBlurImageChannel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *GaussianBlurImageChannel(const Image *image, const ChannelType channel, const double radius, const double sigma, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GaussianBlurImageChannel$descriptor() {
        return GaussianBlurImageChannel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *GaussianBlurImageChannel(const Image *image, const ChannelType channel, const double radius, const double sigma, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GaussianBlurImageChannel$handle() {
        return GaussianBlurImageChannel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *GaussianBlurImageChannel(const Image *image, const ChannelType channel, const double radius, const double sigma, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GaussianBlurImageChannel$address() {
        return GaussianBlurImageChannel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *GaussianBlurImageChannel(const Image *image, const ChannelType channel, const double radius, const double sigma, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GaussianBlurImageChannel(MemorySegment image, int channel, double radius, double sigma, MemorySegment exception) {
        var mh$ = GaussianBlurImageChannel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GaussianBlurImageChannel", image, channel, radius, sigma, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, channel, radius, sigma, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MedianFilterImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MedianFilterImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *MedianFilterImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor MedianFilterImage$descriptor() {
        return MedianFilterImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *MedianFilterImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle MedianFilterImage$handle() {
        return MedianFilterImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *MedianFilterImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment MedianFilterImage$address() {
        return MedianFilterImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *MedianFilterImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment MedianFilterImage(MemorySegment x0, double x1, MemorySegment x2) {
        var mh$ = MedianFilterImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MedianFilterImage", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MotionBlurImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MotionBlurImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *MotionBlurImage(const Image *, const double, const double, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor MotionBlurImage$descriptor() {
        return MotionBlurImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *MotionBlurImage(const Image *, const double, const double, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle MotionBlurImage$handle() {
        return MotionBlurImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *MotionBlurImage(const Image *, const double, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment MotionBlurImage$address() {
        return MotionBlurImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *MotionBlurImage(const Image *, const double, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment MotionBlurImage(MemorySegment x0, double x1, double x2, double x3, MemorySegment x4) {
        var mh$ = MotionBlurImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MotionBlurImage", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReduceNoiseImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReduceNoiseImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ReduceNoiseImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor ReduceNoiseImage$descriptor() {
        return ReduceNoiseImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ReduceNoiseImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle ReduceNoiseImage$handle() {
        return ReduceNoiseImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ReduceNoiseImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment ReduceNoiseImage$address() {
        return ReduceNoiseImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ReduceNoiseImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment ReduceNoiseImage(MemorySegment x0, double x1, MemorySegment x2) {
        var mh$ = ReduceNoiseImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReduceNoiseImage", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShadeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ShadeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ShadeImage(const Image *, const unsigned int, double, double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor ShadeImage$descriptor() {
        return ShadeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ShadeImage(const Image *, const unsigned int, double, double, ExceptionInfo *)
     * }
     */
    public static MethodHandle ShadeImage$handle() {
        return ShadeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ShadeImage(const Image *, const unsigned int, double, double, ExceptionInfo *)
     * }
     */
    public static MemorySegment ShadeImage$address() {
        return ShadeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ShadeImage(const Image *, const unsigned int, double, double, ExceptionInfo *)
     * }
     */
    public static MemorySegment ShadeImage(MemorySegment x0, int x1, double x2, double x3, MemorySegment x4) {
        var mh$ = ShadeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShadeImage", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SharpenImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SharpenImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *SharpenImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor SharpenImage$descriptor() {
        return SharpenImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *SharpenImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle SharpenImage$handle() {
        return SharpenImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *SharpenImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment SharpenImage$address() {
        return SharpenImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *SharpenImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment SharpenImage(MemorySegment x0, double x1, double x2, MemorySegment x3) {
        var mh$ = SharpenImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SharpenImage", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SharpenImageChannel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SharpenImageChannel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *SharpenImageChannel(const Image *image, const ChannelType channel, const double radius, const double sigma, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor SharpenImageChannel$descriptor() {
        return SharpenImageChannel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *SharpenImageChannel(const Image *image, const ChannelType channel, const double radius, const double sigma, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle SharpenImageChannel$handle() {
        return SharpenImageChannel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *SharpenImageChannel(const Image *image, const ChannelType channel, const double radius, const double sigma, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment SharpenImageChannel$address() {
        return SharpenImageChannel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *SharpenImageChannel(const Image *image, const ChannelType channel, const double radius, const double sigma, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment SharpenImageChannel(MemorySegment image, int channel, double radius, double sigma, MemorySegment exception) {
        var mh$ = SharpenImageChannel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SharpenImageChannel", image, channel, radius, sigma, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, channel, radius, sigma, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpreadImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SpreadImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *SpreadImage(const Image *, const unsigned int, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor SpreadImage$descriptor() {
        return SpreadImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *SpreadImage(const Image *, const unsigned int, ExceptionInfo *)
     * }
     */
    public static MethodHandle SpreadImage$handle() {
        return SpreadImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *SpreadImage(const Image *, const unsigned int, ExceptionInfo *)
     * }
     */
    public static MemorySegment SpreadImage$address() {
        return SpreadImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *SpreadImage(const Image *, const unsigned int, ExceptionInfo *)
     * }
     */
    public static MemorySegment SpreadImage(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = SpreadImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpreadImage", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnsharpMaskImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("UnsharpMaskImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *UnsharpMaskImage(const Image *, const double, const double, const double, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor UnsharpMaskImage$descriptor() {
        return UnsharpMaskImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *UnsharpMaskImage(const Image *, const double, const double, const double, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle UnsharpMaskImage$handle() {
        return UnsharpMaskImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *UnsharpMaskImage(const Image *, const double, const double, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment UnsharpMaskImage$address() {
        return UnsharpMaskImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *UnsharpMaskImage(const Image *, const double, const double, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment UnsharpMaskImage(MemorySegment x0, double x1, double x2, double x3, double x4, MemorySegment x5) {
        var mh$ = UnsharpMaskImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnsharpMaskImage", x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnsharpMaskImageChannel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("UnsharpMaskImageChannel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *UnsharpMaskImageChannel(const Image *image, const ChannelType channel, const double radius, const double sigma, const double amount, const double threshold, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor UnsharpMaskImageChannel$descriptor() {
        return UnsharpMaskImageChannel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *UnsharpMaskImageChannel(const Image *image, const ChannelType channel, const double radius, const double sigma, const double amount, const double threshold, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle UnsharpMaskImageChannel$handle() {
        return UnsharpMaskImageChannel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *UnsharpMaskImageChannel(const Image *image, const ChannelType channel, const double radius, const double sigma, const double amount, const double threshold, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment UnsharpMaskImageChannel$address() {
        return UnsharpMaskImageChannel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *UnsharpMaskImageChannel(const Image *image, const ChannelType channel, const double radius, const double sigma, const double amount, const double threshold, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment UnsharpMaskImageChannel(MemorySegment image, int channel, double radius, double sigma, double amount, double threshold, MemorySegment exception) {
        var mh$ = UnsharpMaskImageChannel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnsharpMaskImageChannel", image, channel, radius, sigma, amount, threshold, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, channel, radius, sigma, amount, threshold, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BlackThresholdImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("BlackThresholdImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int BlackThresholdImage(Image *image, const char *thresholds)
     * }
     */
    public static FunctionDescriptor BlackThresholdImage$descriptor() {
        return BlackThresholdImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int BlackThresholdImage(Image *image, const char *thresholds)
     * }
     */
    public static MethodHandle BlackThresholdImage$handle() {
        return BlackThresholdImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int BlackThresholdImage(Image *image, const char *thresholds)
     * }
     */
    public static MemorySegment BlackThresholdImage$address() {
        return BlackThresholdImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int BlackThresholdImage(Image *image, const char *thresholds)
     * }
     */
    public static int BlackThresholdImage(MemorySegment image, MemorySegment thresholds) {
        var mh$ = BlackThresholdImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BlackThresholdImage", image, thresholds);
            }
            return (int)mh$.invokeExact(image, thresholds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChannelThresholdImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ChannelThresholdImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ChannelThresholdImage(Image *, const char *)
     * }
     */
    public static FunctionDescriptor ChannelThresholdImage$descriptor() {
        return ChannelThresholdImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ChannelThresholdImage(Image *, const char *)
     * }
     */
    public static MethodHandle ChannelThresholdImage$handle() {
        return ChannelThresholdImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ChannelThresholdImage(Image *, const char *)
     * }
     */
    public static MemorySegment ChannelThresholdImage$address() {
        return ChannelThresholdImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ChannelThresholdImage(Image *, const char *)
     * }
     */
    public static int ChannelThresholdImage(MemorySegment x0, MemorySegment x1) {
        var mh$ = ChannelThresholdImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChannelThresholdImage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RandomChannelThresholdImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("RandomChannelThresholdImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int RandomChannelThresholdImage(Image *, const char *, const char *, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor RandomChannelThresholdImage$descriptor() {
        return RandomChannelThresholdImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int RandomChannelThresholdImage(Image *, const char *, const char *, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle RandomChannelThresholdImage$handle() {
        return RandomChannelThresholdImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int RandomChannelThresholdImage(Image *, const char *, const char *, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment RandomChannelThresholdImage$address() {
        return RandomChannelThresholdImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int RandomChannelThresholdImage(Image *, const char *, const char *, ExceptionInfo *exception)
     * }
     */
    public static int RandomChannelThresholdImage(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment exception) {
        var mh$ = RandomChannelThresholdImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RandomChannelThresholdImage", x0, x1, x2, exception);
            }
            return (int)mh$.invokeExact(x0, x1, x2, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThresholdImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ThresholdImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ThresholdImage(Image *, const double)
     * }
     */
    public static FunctionDescriptor ThresholdImage$descriptor() {
        return ThresholdImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ThresholdImage(Image *, const double)
     * }
     */
    public static MethodHandle ThresholdImage$handle() {
        return ThresholdImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ThresholdImage(Image *, const double)
     * }
     */
    public static MemorySegment ThresholdImage$address() {
        return ThresholdImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ThresholdImage(Image *, const double)
     * }
     */
    public static int ThresholdImage(MemorySegment x0, double x1) {
        var mh$ = ThresholdImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThresholdImage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WhiteThresholdImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WhiteThresholdImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int WhiteThresholdImage(Image *image, const char *thresholds)
     * }
     */
    public static FunctionDescriptor WhiteThresholdImage$descriptor() {
        return WhiteThresholdImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int WhiteThresholdImage(Image *image, const char *thresholds)
     * }
     */
    public static MethodHandle WhiteThresholdImage$handle() {
        return WhiteThresholdImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int WhiteThresholdImage(Image *image, const char *thresholds)
     * }
     */
    public static MemorySegment WhiteThresholdImage$address() {
        return WhiteThresholdImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int WhiteThresholdImage(Image *image, const char *thresholds)
     * }
     */
    public static int WhiteThresholdImage(MemorySegment image, MemorySegment thresholds) {
        var mh$ = WhiteThresholdImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WhiteThresholdImage", image, thresholds);
            }
            return (int)mh$.invokeExact(image, thresholds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ContrastImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ContrastImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ContrastImage(Image *, const unsigned int)
     * }
     */
    public static FunctionDescriptor ContrastImage$descriptor() {
        return ContrastImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ContrastImage(Image *, const unsigned int)
     * }
     */
    public static MethodHandle ContrastImage$handle() {
        return ContrastImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ContrastImage(Image *, const unsigned int)
     * }
     */
    public static MemorySegment ContrastImage$address() {
        return ContrastImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ContrastImage(Image *, const unsigned int)
     * }
     */
    public static int ContrastImage(MemorySegment x0, int x1) {
        var mh$ = ContrastImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ContrastImage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EqualizeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("EqualizeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int EqualizeImage(Image *)
     * }
     */
    public static FunctionDescriptor EqualizeImage$descriptor() {
        return EqualizeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int EqualizeImage(Image *)
     * }
     */
    public static MethodHandle EqualizeImage$handle() {
        return EqualizeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int EqualizeImage(Image *)
     * }
     */
    public static MemorySegment EqualizeImage$address() {
        return EqualizeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int EqualizeImage(Image *)
     * }
     */
    public static int EqualizeImage(MemorySegment x0) {
        var mh$ = EqualizeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EqualizeImage", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GammaImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GammaImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int GammaImage(Image *, const char *)
     * }
     */
    public static FunctionDescriptor GammaImage$descriptor() {
        return GammaImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int GammaImage(Image *, const char *)
     * }
     */
    public static MethodHandle GammaImage$handle() {
        return GammaImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int GammaImage(Image *, const char *)
     * }
     */
    public static MemorySegment GammaImage$address() {
        return GammaImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int GammaImage(Image *, const char *)
     * }
     */
    public static int GammaImage(MemorySegment x0, MemorySegment x1) {
        var mh$ = GammaImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GammaImage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LevelImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("LevelImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int LevelImage(Image *, const char *)
     * }
     */
    public static FunctionDescriptor LevelImage$descriptor() {
        return LevelImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int LevelImage(Image *, const char *)
     * }
     */
    public static MethodHandle LevelImage$handle() {
        return LevelImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int LevelImage(Image *, const char *)
     * }
     */
    public static MemorySegment LevelImage$address() {
        return LevelImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int LevelImage(Image *, const char *)
     * }
     */
    public static int LevelImage(MemorySegment x0, MemorySegment x1) {
        var mh$ = LevelImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LevelImage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LevelImageChannel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("LevelImageChannel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int LevelImageChannel(Image *, const ChannelType, const double, const double, const double)
     * }
     */
    public static FunctionDescriptor LevelImageChannel$descriptor() {
        return LevelImageChannel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int LevelImageChannel(Image *, const ChannelType, const double, const double, const double)
     * }
     */
    public static MethodHandle LevelImageChannel$handle() {
        return LevelImageChannel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int LevelImageChannel(Image *, const ChannelType, const double, const double, const double)
     * }
     */
    public static MemorySegment LevelImageChannel$address() {
        return LevelImageChannel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int LevelImageChannel(Image *, const ChannelType, const double, const double, const double)
     * }
     */
    public static int LevelImageChannel(MemorySegment x0, int x1, double x2, double x3, double x4) {
        var mh$ = LevelImageChannel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LevelImageChannel", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ModulateImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ModulateImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ModulateImage(Image *, const char *)
     * }
     */
    public static FunctionDescriptor ModulateImage$descriptor() {
        return ModulateImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ModulateImage(Image *, const char *)
     * }
     */
    public static MethodHandle ModulateImage$handle() {
        return ModulateImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ModulateImage(Image *, const char *)
     * }
     */
    public static MemorySegment ModulateImage$address() {
        return ModulateImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ModulateImage(Image *, const char *)
     * }
     */
    public static int ModulateImage(MemorySegment x0, MemorySegment x1) {
        var mh$ = ModulateImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ModulateImage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NegateImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("NegateImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int NegateImage(Image *, const unsigned int)
     * }
     */
    public static FunctionDescriptor NegateImage$descriptor() {
        return NegateImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int NegateImage(Image *, const unsigned int)
     * }
     */
    public static MethodHandle NegateImage$handle() {
        return NegateImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int NegateImage(Image *, const unsigned int)
     * }
     */
    public static MemorySegment NegateImage$address() {
        return NegateImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int NegateImage(Image *, const unsigned int)
     * }
     */
    public static int NegateImage(MemorySegment x0, int x1) {
        var mh$ = NegateImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NegateImage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NormalizeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("NormalizeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int NormalizeImage(Image *)
     * }
     */
    public static FunctionDescriptor NormalizeImage$descriptor() {
        return NormalizeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int NormalizeImage(Image *)
     * }
     */
    public static MethodHandle NormalizeImage$handle() {
        return NormalizeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int NormalizeImage(Image *)
     * }
     */
    public static MemorySegment NormalizeImage$address() {
        return NormalizeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int NormalizeImage(Image *)
     * }
     */
    public static int NormalizeImage(MemorySegment x0) {
        var mh$ = NormalizeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NormalizeImage", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UndefinedQuantumOp = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedQuantumOp = 0
     * }
     */
    public static int UndefinedQuantumOp() {
        return UndefinedQuantumOp;
    }
    private static final int AddQuantumOp = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AddQuantumOp = 1
     * }
     */
    public static int AddQuantumOp() {
        return AddQuantumOp;
    }
    private static final int AndQuantumOp = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AndQuantumOp = 2
     * }
     */
    public static int AndQuantumOp() {
        return AndQuantumOp;
    }
    private static final int AssignQuantumOp = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AssignQuantumOp = 3
     * }
     */
    public static int AssignQuantumOp() {
        return AssignQuantumOp;
    }
    private static final int DivideQuantumOp = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DivideQuantumOp = 4
     * }
     */
    public static int DivideQuantumOp() {
        return DivideQuantumOp;
    }
    private static final int LShiftQuantumOp = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LShiftQuantumOp = 5
     * }
     */
    public static int LShiftQuantumOp() {
        return LShiftQuantumOp;
    }
    private static final int MultiplyQuantumOp = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MultiplyQuantumOp = 6
     * }
     */
    public static int MultiplyQuantumOp() {
        return MultiplyQuantumOp;
    }
    private static final int OrQuantumOp = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OrQuantumOp = 7
     * }
     */
    public static int OrQuantumOp() {
        return OrQuantumOp;
    }
    private static final int RShiftQuantumOp = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RShiftQuantumOp = 8
     * }
     */
    public static int RShiftQuantumOp() {
        return RShiftQuantumOp;
    }
    private static final int SubtractQuantumOp = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SubtractQuantumOp = 9
     * }
     */
    public static int SubtractQuantumOp() {
        return SubtractQuantumOp;
    }
    private static final int ThresholdQuantumOp = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ThresholdQuantumOp = 10
     * }
     */
    public static int ThresholdQuantumOp() {
        return ThresholdQuantumOp;
    }
    private static final int ThresholdBlackQuantumOp = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ThresholdBlackQuantumOp = 11
     * }
     */
    public static int ThresholdBlackQuantumOp() {
        return ThresholdBlackQuantumOp;
    }
    private static final int ThresholdWhiteQuantumOp = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ThresholdWhiteQuantumOp = 12
     * }
     */
    public static int ThresholdWhiteQuantumOp() {
        return ThresholdWhiteQuantumOp;
    }
    private static final int XorQuantumOp = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.XorQuantumOp = 13
     * }
     */
    public static int XorQuantumOp() {
        return XorQuantumOp;
    }
    private static final int NoiseGaussianQuantumOp = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NoiseGaussianQuantumOp = 14
     * }
     */
    public static int NoiseGaussianQuantumOp() {
        return NoiseGaussianQuantumOp;
    }
    private static final int NoiseImpulseQuantumOp = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NoiseImpulseQuantumOp = 15
     * }
     */
    public static int NoiseImpulseQuantumOp() {
        return NoiseImpulseQuantumOp;
    }
    private static final int NoiseLaplacianQuantumOp = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NoiseLaplacianQuantumOp = 16
     * }
     */
    public static int NoiseLaplacianQuantumOp() {
        return NoiseLaplacianQuantumOp;
    }
    private static final int NoiseMultiplicativeQuantumOp = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NoiseMultiplicativeQuantumOp = 17
     * }
     */
    public static int NoiseMultiplicativeQuantumOp() {
        return NoiseMultiplicativeQuantumOp;
    }
    private static final int NoisePoissonQuantumOp = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NoisePoissonQuantumOp = 18
     * }
     */
    public static int NoisePoissonQuantumOp() {
        return NoisePoissonQuantumOp;
    }
    private static final int NoiseUniformQuantumOp = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NoiseUniformQuantumOp = 19
     * }
     */
    public static int NoiseUniformQuantumOp() {
        return NoiseUniformQuantumOp;
    }
    private static final int NegateQuantumOp = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NegateQuantumOp = 20
     * }
     */
    public static int NegateQuantumOp() {
        return NegateQuantumOp;
    }
    private static final int GammaQuantumOp = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GammaQuantumOp = 21
     * }
     */
    public static int GammaQuantumOp() {
        return GammaQuantumOp;
    }
    private static final int DepthQuantumOp = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DepthQuantumOp = 22
     * }
     */
    public static int DepthQuantumOp() {
        return DepthQuantumOp;
    }
    private static final int LogQuantumOp = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LogQuantumOp = 23
     * }
     */
    public static int LogQuantumOp() {
        return LogQuantumOp;
    }
    private static final int MaxQuantumOp = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MaxQuantumOp = 24
     * }
     */
    public static int MaxQuantumOp() {
        return MaxQuantumOp;
    }
    private static final int MinQuantumOp = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MinQuantumOp = 25
     * }
     */
    public static int MinQuantumOp() {
        return MinQuantumOp;
    }
    private static final int PowQuantumOp = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PowQuantumOp = 26
     * }
     */
    public static int PowQuantumOp() {
        return PowQuantumOp;
    }
    private static final int NoiseRandomQuantumOp = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NoiseRandomQuantumOp = 27
     * }
     */
    public static int NoiseRandomQuantumOp() {
        return NoiseRandomQuantumOp;
    }
    private static final int ThresholdBlackNegateQuantumOp = (int)28L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ThresholdBlackNegateQuantumOp = 28
     * }
     */
    public static int ThresholdBlackNegateQuantumOp() {
        return ThresholdBlackNegateQuantumOp;
    }
    private static final int ThresholdWhiteNegateQuantumOp = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ThresholdWhiteNegateQuantumOp = 29
     * }
     */
    public static int ThresholdWhiteNegateQuantumOp() {
        return ThresholdWhiteNegateQuantumOp;
    }

    private static class QuantumOperatorImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("QuantumOperatorImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int QuantumOperatorImage(Image *image, const ChannelType channel, const QuantumOperator quantum_operator, const double rvalue, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor QuantumOperatorImage$descriptor() {
        return QuantumOperatorImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int QuantumOperatorImage(Image *image, const ChannelType channel, const QuantumOperator quantum_operator, const double rvalue, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle QuantumOperatorImage$handle() {
        return QuantumOperatorImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int QuantumOperatorImage(Image *image, const ChannelType channel, const QuantumOperator quantum_operator, const double rvalue, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment QuantumOperatorImage$address() {
        return QuantumOperatorImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int QuantumOperatorImage(Image *image, const ChannelType channel, const QuantumOperator quantum_operator, const double rvalue, ExceptionInfo *exception)
     * }
     */
    public static int QuantumOperatorImage(MemorySegment image, int channel, int quantum_operator, double rvalue, MemorySegment exception) {
        var mh$ = QuantumOperatorImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuantumOperatorImage", image, channel, quantum_operator, rvalue, exception);
            }
            return (int)mh$.invokeExact(image, channel, quantum_operator, rvalue, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuantumOperatorImageMultivalue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("QuantumOperatorImageMultivalue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int QuantumOperatorImageMultivalue(Image *image, const QuantumOperator quantum_operator, const char *values)
     * }
     */
    public static FunctionDescriptor QuantumOperatorImageMultivalue$descriptor() {
        return QuantumOperatorImageMultivalue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int QuantumOperatorImageMultivalue(Image *image, const QuantumOperator quantum_operator, const char *values)
     * }
     */
    public static MethodHandle QuantumOperatorImageMultivalue$handle() {
        return QuantumOperatorImageMultivalue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int QuantumOperatorImageMultivalue(Image *image, const QuantumOperator quantum_operator, const char *values)
     * }
     */
    public static MemorySegment QuantumOperatorImageMultivalue$address() {
        return QuantumOperatorImageMultivalue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int QuantumOperatorImageMultivalue(Image *image, const QuantumOperator quantum_operator, const char *values)
     * }
     */
    public static int QuantumOperatorImageMultivalue(MemorySegment image, int quantum_operator, MemorySegment values) {
        var mh$ = QuantumOperatorImageMultivalue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuantumOperatorImageMultivalue", image, quantum_operator, values);
            }
            return (int)mh$.invokeExact(image, quantum_operator, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuantumOperatorRegionImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("QuantumOperatorRegionImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int QuantumOperatorRegionImage(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows, const ChannelType channel, const QuantumOperator quantum_operator, const double rvalue, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor QuantumOperatorRegionImage$descriptor() {
        return QuantumOperatorRegionImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int QuantumOperatorRegionImage(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows, const ChannelType channel, const QuantumOperator quantum_operator, const double rvalue, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle QuantumOperatorRegionImage$handle() {
        return QuantumOperatorRegionImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int QuantumOperatorRegionImage(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows, const ChannelType channel, const QuantumOperator quantum_operator, const double rvalue, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment QuantumOperatorRegionImage$address() {
        return QuantumOperatorRegionImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int QuantumOperatorRegionImage(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows, const ChannelType channel, const QuantumOperator quantum_operator, const double rvalue, ExceptionInfo *exception)
     * }
     */
    public static int QuantumOperatorRegionImage(MemorySegment image, long x, long y, long columns, long rows, int channel, int quantum_operator, double rvalue, MemorySegment exception) {
        var mh$ = QuantumOperatorRegionImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuantumOperatorRegionImage", image, x, y, columns, rows, channel, quantum_operator, rvalue, exception);
            }
            return (int)mh$.invokeExact(image, x, y, columns, rows, channel, quantum_operator, rvalue, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UndefinedVirtualPixelMethod = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedVirtualPixelMethod = 0
     * }
     */
    public static int UndefinedVirtualPixelMethod() {
        return UndefinedVirtualPixelMethod;
    }
    private static final int ConstantVirtualPixelMethod = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ConstantVirtualPixelMethod = 1
     * }
     */
    public static int ConstantVirtualPixelMethod() {
        return ConstantVirtualPixelMethod;
    }
    private static final int EdgeVirtualPixelMethod = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EdgeVirtualPixelMethod = 2
     * }
     */
    public static int EdgeVirtualPixelMethod() {
        return EdgeVirtualPixelMethod;
    }
    private static final int MirrorVirtualPixelMethod = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MirrorVirtualPixelMethod = 3
     * }
     */
    public static int MirrorVirtualPixelMethod() {
        return MirrorVirtualPixelMethod;
    }
    private static final int TileVirtualPixelMethod = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TileVirtualPixelMethod = 4
     * }
     */
    public static int TileVirtualPixelMethod() {
        return TileVirtualPixelMethod;
    }
    /**
     * {@snippet lang=c :
     * typedef _CacheInfoPtr_ Cache
     * }
     */
    public static final AddressLayout Cache = magick_wand_h.C_POINTER;

    private static class AcquireImagePixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AcquireImagePixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const PixelPacket *AcquireImagePixels(const Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor AcquireImagePixels$descriptor() {
        return AcquireImagePixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const PixelPacket *AcquireImagePixels(const Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle AcquireImagePixels$handle() {
        return AcquireImagePixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const PixelPacket *AcquireImagePixels(const Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment AcquireImagePixels$address() {
        return AcquireImagePixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const PixelPacket *AcquireImagePixels(const Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment AcquireImagePixels(MemorySegment image, long x, long y, long columns, long rows, MemorySegment exception) {
        var mh$ = AcquireImagePixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireImagePixels", image, x, y, columns, rows, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, x, y, columns, rows, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessImmutableIndexes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AccessImmutableIndexes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const IndexPacket *AccessImmutableIndexes(const Image *image)
     * }
     */
    public static FunctionDescriptor AccessImmutableIndexes$descriptor() {
        return AccessImmutableIndexes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const IndexPacket *AccessImmutableIndexes(const Image *image)
     * }
     */
    public static MethodHandle AccessImmutableIndexes$handle() {
        return AccessImmutableIndexes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const IndexPacket *AccessImmutableIndexes(const Image *image)
     * }
     */
    public static MemorySegment AccessImmutableIndexes$address() {
        return AccessImmutableIndexes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const IndexPacket *AccessImmutableIndexes(const Image *image)
     * }
     */
    public static MemorySegment AccessImmutableIndexes(MemorySegment image) {
        var mh$ = AccessImmutableIndexes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessImmutableIndexes", image);
            }
            return (MemorySegment)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AcquireOnePixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _PixelPacket.layout(),
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AcquireOnePixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelPacket AcquireOnePixel(const Image *image, const long x, const long y, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor AcquireOnePixel$descriptor() {
        return AcquireOnePixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelPacket AcquireOnePixel(const Image *image, const long x, const long y, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle AcquireOnePixel$handle() {
        return AcquireOnePixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelPacket AcquireOnePixel(const Image *image, const long x, const long y, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment AcquireOnePixel$address() {
        return AcquireOnePixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelPacket AcquireOnePixel(const Image *image, const long x, const long y, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment AcquireOnePixel(SegmentAllocator allocator, MemorySegment image, long x, long y, MemorySegment exception) {
        var mh$ = AcquireOnePixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireOnePixel", allocator, image, x, y, exception);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, x, y, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImagePixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImagePixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelPacket *GetImagePixels(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows)
     * }
     */
    public static FunctionDescriptor GetImagePixels$descriptor() {
        return GetImagePixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelPacket *GetImagePixels(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows)
     * }
     */
    public static MethodHandle GetImagePixels$handle() {
        return GetImagePixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelPacket *GetImagePixels(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows)
     * }
     */
    public static MemorySegment GetImagePixels$address() {
        return GetImagePixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelPacket *GetImagePixels(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows)
     * }
     */
    public static MemorySegment GetImagePixels(MemorySegment image, long x, long y, long columns, long rows) {
        var mh$ = GetImagePixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImagePixels", image, x, y, columns, rows);
            }
            return (MemorySegment)mh$.invokeExact(image, x, y, columns, rows);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImagePixelsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImagePixelsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelPacket *GetImagePixelsEx(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetImagePixelsEx$descriptor() {
        return GetImagePixelsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelPacket *GetImagePixelsEx(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetImagePixelsEx$handle() {
        return GetImagePixelsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelPacket *GetImagePixelsEx(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetImagePixelsEx$address() {
        return GetImagePixelsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelPacket *GetImagePixelsEx(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetImagePixelsEx(MemorySegment image, long x, long y, long columns, long rows, MemorySegment exception) {
        var mh$ = GetImagePixelsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImagePixelsEx", image, x, y, columns, rows, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, x, y, columns, rows, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageVirtualPixelMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageVirtualPixelMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern VirtualPixelMethod GetImageVirtualPixelMethod(const Image *image)
     * }
     */
    public static FunctionDescriptor GetImageVirtualPixelMethod$descriptor() {
        return GetImageVirtualPixelMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern VirtualPixelMethod GetImageVirtualPixelMethod(const Image *image)
     * }
     */
    public static MethodHandle GetImageVirtualPixelMethod$handle() {
        return GetImageVirtualPixelMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern VirtualPixelMethod GetImageVirtualPixelMethod(const Image *image)
     * }
     */
    public static MemorySegment GetImageVirtualPixelMethod$address() {
        return GetImageVirtualPixelMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern VirtualPixelMethod GetImageVirtualPixelMethod(const Image *image)
     * }
     */
    public static int GetImageVirtualPixelMethod(MemorySegment image) {
        var mh$ = GetImageVirtualPixelMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageVirtualPixelMethod", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelPacket *GetPixels(const Image *image)
     * }
     */
    public static FunctionDescriptor GetPixels$descriptor() {
        return GetPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelPacket *GetPixels(const Image *image)
     * }
     */
    public static MethodHandle GetPixels$handle() {
        return GetPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelPacket *GetPixels(const Image *image)
     * }
     */
    public static MemorySegment GetPixels$address() {
        return GetPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelPacket *GetPixels(const Image *image)
     * }
     */
    public static MemorySegment GetPixels(MemorySegment image) {
        var mh$ = GetPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPixels", image);
            }
            return (MemorySegment)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessMutablePixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AccessMutablePixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelPacket *AccessMutablePixels(Image *image)
     * }
     */
    public static FunctionDescriptor AccessMutablePixels$descriptor() {
        return AccessMutablePixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelPacket *AccessMutablePixels(Image *image)
     * }
     */
    public static MethodHandle AccessMutablePixels$handle() {
        return AccessMutablePixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelPacket *AccessMutablePixels(Image *image)
     * }
     */
    public static MemorySegment AccessMutablePixels$address() {
        return AccessMutablePixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelPacket *AccessMutablePixels(Image *image)
     * }
     */
    public static MemorySegment AccessMutablePixels(MemorySegment image) {
        var mh$ = AccessMutablePixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessMutablePixels", image);
            }
            return (MemorySegment)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetIndexes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetIndexes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IndexPacket *GetIndexes(const Image *image)
     * }
     */
    public static FunctionDescriptor GetIndexes$descriptor() {
        return GetIndexes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IndexPacket *GetIndexes(const Image *image)
     * }
     */
    public static MethodHandle GetIndexes$handle() {
        return GetIndexes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IndexPacket *GetIndexes(const Image *image)
     * }
     */
    public static MemorySegment GetIndexes$address() {
        return GetIndexes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IndexPacket *GetIndexes(const Image *image)
     * }
     */
    public static MemorySegment GetIndexes(MemorySegment image) {
        var mh$ = GetIndexes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetIndexes", image);
            }
            return (MemorySegment)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessMutableIndexes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AccessMutableIndexes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IndexPacket *AccessMutableIndexes(Image *image)
     * }
     */
    public static FunctionDescriptor AccessMutableIndexes$descriptor() {
        return AccessMutableIndexes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IndexPacket *AccessMutableIndexes(Image *image)
     * }
     */
    public static MethodHandle AccessMutableIndexes$handle() {
        return AccessMutableIndexes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IndexPacket *AccessMutableIndexes(Image *image)
     * }
     */
    public static MemorySegment AccessMutableIndexes$address() {
        return AccessMutableIndexes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IndexPacket *AccessMutableIndexes(Image *image)
     * }
     */
    public static MemorySegment AccessMutableIndexes(MemorySegment image) {
        var mh$ = AccessMutableIndexes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessMutableIndexes", image);
            }
            return (MemorySegment)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOnePixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _PixelPacket.layout(),
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetOnePixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelPacket GetOnePixel(Image *image, const long x, const long y)
     * }
     */
    public static FunctionDescriptor GetOnePixel$descriptor() {
        return GetOnePixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelPacket GetOnePixel(Image *image, const long x, const long y)
     * }
     */
    public static MethodHandle GetOnePixel$handle() {
        return GetOnePixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelPacket GetOnePixel(Image *image, const long x, const long y)
     * }
     */
    public static MemorySegment GetOnePixel$address() {
        return GetOnePixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelPacket GetOnePixel(Image *image, const long x, const long y)
     * }
     */
    public static MemorySegment GetOnePixel(SegmentAllocator allocator, MemorySegment image, long x, long y) {
        var mh$ = GetOnePixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOnePixel", allocator, image, x, y);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPixelCacheArea {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetPixelCacheArea");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern magick_off_t GetPixelCacheArea(const Image *image)
     * }
     */
    public static FunctionDescriptor GetPixelCacheArea$descriptor() {
        return GetPixelCacheArea.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern magick_off_t GetPixelCacheArea(const Image *image)
     * }
     */
    public static MethodHandle GetPixelCacheArea$handle() {
        return GetPixelCacheArea.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern magick_off_t GetPixelCacheArea(const Image *image)
     * }
     */
    public static MemorySegment GetPixelCacheArea$address() {
        return GetPixelCacheArea.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern magick_off_t GetPixelCacheArea(const Image *image)
     * }
     */
    public static long GetPixelCacheArea(MemorySegment image) {
        var mh$ = GetPixelCacheArea.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPixelCacheArea", image);
            }
            return (long)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetImagePixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetImagePixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelPacket *SetImagePixels(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows)
     * }
     */
    public static FunctionDescriptor SetImagePixels$descriptor() {
        return SetImagePixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelPacket *SetImagePixels(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows)
     * }
     */
    public static MethodHandle SetImagePixels$handle() {
        return SetImagePixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelPacket *SetImagePixels(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows)
     * }
     */
    public static MemorySegment SetImagePixels$address() {
        return SetImagePixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelPacket *SetImagePixels(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows)
     * }
     */
    public static MemorySegment SetImagePixels(MemorySegment image, long x, long y, long columns, long rows) {
        var mh$ = SetImagePixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetImagePixels", image, x, y, columns, rows);
            }
            return (MemorySegment)mh$.invokeExact(image, x, y, columns, rows);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetImagePixelsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetImagePixelsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelPacket *SetImagePixelsEx(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor SetImagePixelsEx$descriptor() {
        return SetImagePixelsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelPacket *SetImagePixelsEx(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle SetImagePixelsEx$handle() {
        return SetImagePixelsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelPacket *SetImagePixelsEx(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment SetImagePixelsEx$address() {
        return SetImagePixelsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelPacket *SetImagePixelsEx(Image *image, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment SetImagePixelsEx(MemorySegment image, long x, long y, long columns, long rows, MemorySegment exception) {
        var mh$ = SetImagePixelsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetImagePixelsEx", image, x, y, columns, rows, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, x, y, columns, rows, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetImageVirtualPixelMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetImageVirtualPixelMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SetImageVirtualPixelMethod(const Image *image, const VirtualPixelMethod method)
     * }
     */
    public static FunctionDescriptor SetImageVirtualPixelMethod$descriptor() {
        return SetImageVirtualPixelMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SetImageVirtualPixelMethod(const Image *image, const VirtualPixelMethod method)
     * }
     */
    public static MethodHandle SetImageVirtualPixelMethod$handle() {
        return SetImageVirtualPixelMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SetImageVirtualPixelMethod(const Image *image, const VirtualPixelMethod method)
     * }
     */
    public static MemorySegment SetImageVirtualPixelMethod$address() {
        return SetImageVirtualPixelMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SetImageVirtualPixelMethod(const Image *image, const VirtualPixelMethod method)
     * }
     */
    public static int SetImageVirtualPixelMethod(MemorySegment image, int method) {
        var mh$ = SetImageVirtualPixelMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetImageVirtualPixelMethod", image, method);
            }
            return (int)mh$.invokeExact(image, method);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SyncImagePixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SyncImagePixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SyncImagePixels(Image *image)
     * }
     */
    public static FunctionDescriptor SyncImagePixels$descriptor() {
        return SyncImagePixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SyncImagePixels(Image *image)
     * }
     */
    public static MethodHandle SyncImagePixels$handle() {
        return SyncImagePixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SyncImagePixels(Image *image)
     * }
     */
    public static MemorySegment SyncImagePixels$address() {
        return SyncImagePixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SyncImagePixels(Image *image)
     * }
     */
    public static int SyncImagePixels(MemorySegment image) {
        var mh$ = SyncImagePixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SyncImagePixels", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SyncImagePixelsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SyncImagePixelsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SyncImagePixelsEx(Image *image, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor SyncImagePixelsEx$descriptor() {
        return SyncImagePixelsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SyncImagePixelsEx(Image *image, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle SyncImagePixelsEx$handle() {
        return SyncImagePixelsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SyncImagePixelsEx(Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment SyncImagePixelsEx$address() {
        return SyncImagePixelsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SyncImagePixelsEx(Image *image, ExceptionInfo *exception)
     * }
     */
    public static int SyncImagePixelsEx(MemorySegment image, MemorySegment exception) {
        var mh$ = SyncImagePixelsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SyncImagePixelsEx", image, exception);
            }
            return (int)mh$.invokeExact(image, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenCacheView {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("OpenCacheView");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ViewInfo *OpenCacheView(Image *image)
     * }
     */
    public static FunctionDescriptor OpenCacheView$descriptor() {
        return OpenCacheView.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ViewInfo *OpenCacheView(Image *image)
     * }
     */
    public static MethodHandle OpenCacheView$handle() {
        return OpenCacheView.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ViewInfo *OpenCacheView(Image *image)
     * }
     */
    public static MemorySegment OpenCacheView$address() {
        return OpenCacheView.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ViewInfo *OpenCacheView(Image *image)
     * }
     */
    public static MemorySegment OpenCacheView(MemorySegment image) {
        var mh$ = OpenCacheView.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenCacheView", image);
            }
            return (MemorySegment)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseCacheView {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CloseCacheView");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void CloseCacheView(ViewInfo *view)
     * }
     */
    public static FunctionDescriptor CloseCacheView$descriptor() {
        return CloseCacheView.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void CloseCacheView(ViewInfo *view)
     * }
     */
    public static MethodHandle CloseCacheView$handle() {
        return CloseCacheView.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void CloseCacheView(ViewInfo *view)
     * }
     */
    public static MemorySegment CloseCacheView$address() {
        return CloseCacheView.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void CloseCacheView(ViewInfo *view)
     * }
     */
    public static void CloseCacheView(MemorySegment view) {
        var mh$ = CloseCacheView.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseCacheView", view);
            }
            mh$.invokeExact(view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCacheViewPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AccessCacheViewPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelPacket *AccessCacheViewPixels(const ViewInfo *view)
     * }
     */
    public static FunctionDescriptor AccessCacheViewPixels$descriptor() {
        return AccessCacheViewPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelPacket *AccessCacheViewPixels(const ViewInfo *view)
     * }
     */
    public static MethodHandle AccessCacheViewPixels$handle() {
        return AccessCacheViewPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelPacket *AccessCacheViewPixels(const ViewInfo *view)
     * }
     */
    public static MemorySegment AccessCacheViewPixels$address() {
        return AccessCacheViewPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelPacket *AccessCacheViewPixels(const ViewInfo *view)
     * }
     */
    public static MemorySegment AccessCacheViewPixels(MemorySegment view) {
        var mh$ = AccessCacheViewPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCacheViewPixels", view);
            }
            return (MemorySegment)mh$.invokeExact(view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AcquireCacheViewIndexes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AcquireCacheViewIndexes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const IndexPacket *AcquireCacheViewIndexes(const ViewInfo *view)
     * }
     */
    public static FunctionDescriptor AcquireCacheViewIndexes$descriptor() {
        return AcquireCacheViewIndexes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const IndexPacket *AcquireCacheViewIndexes(const ViewInfo *view)
     * }
     */
    public static MethodHandle AcquireCacheViewIndexes$handle() {
        return AcquireCacheViewIndexes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const IndexPacket *AcquireCacheViewIndexes(const ViewInfo *view)
     * }
     */
    public static MemorySegment AcquireCacheViewIndexes$address() {
        return AcquireCacheViewIndexes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const IndexPacket *AcquireCacheViewIndexes(const ViewInfo *view)
     * }
     */
    public static MemorySegment AcquireCacheViewIndexes(MemorySegment view) {
        var mh$ = AcquireCacheViewIndexes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireCacheViewIndexes", view);
            }
            return (MemorySegment)mh$.invokeExact(view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AcquireCacheViewPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AcquireCacheViewPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const PixelPacket *AcquireCacheViewPixels(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor AcquireCacheViewPixels$descriptor() {
        return AcquireCacheViewPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const PixelPacket *AcquireCacheViewPixels(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle AcquireCacheViewPixels$handle() {
        return AcquireCacheViewPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const PixelPacket *AcquireCacheViewPixels(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment AcquireCacheViewPixels$address() {
        return AcquireCacheViewPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const PixelPacket *AcquireCacheViewPixels(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment AcquireCacheViewPixels(MemorySegment view, long x, long y, long columns, long rows, MemorySegment exception) {
        var mh$ = AcquireCacheViewPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireCacheViewPixels", view, x, y, columns, rows, exception);
            }
            return (MemorySegment)mh$.invokeExact(view, x, y, columns, rows, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AcquireOneCacheViewPixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AcquireOneCacheViewPixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int AcquireOneCacheViewPixel(ViewInfo *view, PixelPacket *pixel, const long x, const long y, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor AcquireOneCacheViewPixel$descriptor() {
        return AcquireOneCacheViewPixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int AcquireOneCacheViewPixel(ViewInfo *view, PixelPacket *pixel, const long x, const long y, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle AcquireOneCacheViewPixel$handle() {
        return AcquireOneCacheViewPixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int AcquireOneCacheViewPixel(ViewInfo *view, PixelPacket *pixel, const long x, const long y, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment AcquireOneCacheViewPixel$address() {
        return AcquireOneCacheViewPixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int AcquireOneCacheViewPixel(ViewInfo *view, PixelPacket *pixel, const long x, const long y, ExceptionInfo *exception)
     * }
     */
    public static int AcquireOneCacheViewPixel(MemorySegment view, MemorySegment pixel, long x, long y, MemorySegment exception) {
        var mh$ = AcquireOneCacheViewPixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireOneCacheViewPixel", view, pixel, x, y, exception);
            }
            return (int)mh$.invokeExact(view, pixel, x, y, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCacheViewArea {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetCacheViewArea");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern magick_off_t GetCacheViewArea(const ViewInfo *view)
     * }
     */
    public static FunctionDescriptor GetCacheViewArea$descriptor() {
        return GetCacheViewArea.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern magick_off_t GetCacheViewArea(const ViewInfo *view)
     * }
     */
    public static MethodHandle GetCacheViewArea$handle() {
        return GetCacheViewArea.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern magick_off_t GetCacheViewArea(const ViewInfo *view)
     * }
     */
    public static MemorySegment GetCacheViewArea$address() {
        return GetCacheViewArea.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern magick_off_t GetCacheViewArea(const ViewInfo *view)
     * }
     */
    public static long GetCacheViewArea(MemorySegment view) {
        var mh$ = GetCacheViewArea.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCacheViewArea", view);
            }
            return (long)mh$.invokeExact(view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCacheViewImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetCacheViewImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *GetCacheViewImage(const ViewInfo *view)
     * }
     */
    public static FunctionDescriptor GetCacheViewImage$descriptor() {
        return GetCacheViewImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *GetCacheViewImage(const ViewInfo *view)
     * }
     */
    public static MethodHandle GetCacheViewImage$handle() {
        return GetCacheViewImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *GetCacheViewImage(const ViewInfo *view)
     * }
     */
    public static MemorySegment GetCacheViewImage$address() {
        return GetCacheViewImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *GetCacheViewImage(const ViewInfo *view)
     * }
     */
    public static MemorySegment GetCacheViewImage(MemorySegment view) {
        var mh$ = GetCacheViewImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCacheViewImage", view);
            }
            return (MemorySegment)mh$.invokeExact(view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCacheViewIndexes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetCacheViewIndexes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IndexPacket *GetCacheViewIndexes(const ViewInfo *view)
     * }
     */
    public static FunctionDescriptor GetCacheViewIndexes$descriptor() {
        return GetCacheViewIndexes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IndexPacket *GetCacheViewIndexes(const ViewInfo *view)
     * }
     */
    public static MethodHandle GetCacheViewIndexes$handle() {
        return GetCacheViewIndexes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IndexPacket *GetCacheViewIndexes(const ViewInfo *view)
     * }
     */
    public static MemorySegment GetCacheViewIndexes$address() {
        return GetCacheViewIndexes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IndexPacket *GetCacheViewIndexes(const ViewInfo *view)
     * }
     */
    public static MemorySegment GetCacheViewIndexes(MemorySegment view) {
        var mh$ = GetCacheViewIndexes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCacheViewIndexes", view);
            }
            return (MemorySegment)mh$.invokeExact(view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCacheViewPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetCacheViewPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelPacket *GetCacheViewPixels(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetCacheViewPixels$descriptor() {
        return GetCacheViewPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelPacket *GetCacheViewPixels(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetCacheViewPixels$handle() {
        return GetCacheViewPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelPacket *GetCacheViewPixels(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetCacheViewPixels$address() {
        return GetCacheViewPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelPacket *GetCacheViewPixels(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetCacheViewPixels(MemorySegment view, long x, long y, long columns, long rows, MemorySegment exception) {
        var mh$ = GetCacheViewPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCacheViewPixels", view, x, y, columns, rows, exception);
            }
            return (MemorySegment)mh$.invokeExact(view, x, y, columns, rows, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCacheViewRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _RectangleInfo.layout(),
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetCacheViewRegion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern RectangleInfo GetCacheViewRegion(const ViewInfo *view)
     * }
     */
    public static FunctionDescriptor GetCacheViewRegion$descriptor() {
        return GetCacheViewRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern RectangleInfo GetCacheViewRegion(const ViewInfo *view)
     * }
     */
    public static MethodHandle GetCacheViewRegion$handle() {
        return GetCacheViewRegion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern RectangleInfo GetCacheViewRegion(const ViewInfo *view)
     * }
     */
    public static MemorySegment GetCacheViewRegion$address() {
        return GetCacheViewRegion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern RectangleInfo GetCacheViewRegion(const ViewInfo *view)
     * }
     */
    public static MemorySegment GetCacheViewRegion(SegmentAllocator allocator, MemorySegment view) {
        var mh$ = GetCacheViewRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCacheViewRegion", allocator, view);
            }
            return (MemorySegment)mh$.invokeExact(allocator, view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCacheViewPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetCacheViewPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelPacket *SetCacheViewPixels(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor SetCacheViewPixels$descriptor() {
        return SetCacheViewPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelPacket *SetCacheViewPixels(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle SetCacheViewPixels$handle() {
        return SetCacheViewPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelPacket *SetCacheViewPixels(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment SetCacheViewPixels$address() {
        return SetCacheViewPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelPacket *SetCacheViewPixels(ViewInfo *view, const long x, const long y, const unsigned long columns, const unsigned long rows, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment SetCacheViewPixels(MemorySegment view, long x, long y, long columns, long rows, MemorySegment exception) {
        var mh$ = SetCacheViewPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCacheViewPixels", view, x, y, columns, rows, exception);
            }
            return (MemorySegment)mh$.invokeExact(view, x, y, columns, rows, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SyncCacheViewPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SyncCacheViewPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SyncCacheViewPixels(const ViewInfo *view, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor SyncCacheViewPixels$descriptor() {
        return SyncCacheViewPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SyncCacheViewPixels(const ViewInfo *view, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle SyncCacheViewPixels$handle() {
        return SyncCacheViewPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SyncCacheViewPixels(const ViewInfo *view, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment SyncCacheViewPixels$address() {
        return SyncCacheViewPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SyncCacheViewPixels(const ViewInfo *view, ExceptionInfo *exception)
     * }
     */
    public static int SyncCacheViewPixels(MemorySegment view, MemorySegment exception) {
        var mh$ = SyncCacheViewPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SyncCacheViewPixels", view, exception);
            }
            return (int)mh$.invokeExact(view, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UndefinedResource = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedResource = 0
     * }
     */
    public static int UndefinedResource() {
        return UndefinedResource;
    }
    private static final int DiskResource = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DiskResource = 1
     * }
     */
    public static int DiskResource() {
        return DiskResource;
    }
    private static final int FileResource = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FileResource = 2
     * }
     */
    public static int FileResource() {
        return FileResource;
    }
    private static final int MapResource = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MapResource = 3
     * }
     */
    public static int MapResource() {
        return MapResource;
    }
    private static final int MemoryResource = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MemoryResource = 4
     * }
     */
    public static int MemoryResource() {
        return MemoryResource;
    }
    private static final int PixelsResource = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PixelsResource = 5
     * }
     */
    public static int PixelsResource() {
        return PixelsResource;
    }
    private static final int ThreadsResource = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ThreadsResource = 6
     * }
     */
    public static int ThreadsResource() {
        return ThreadsResource;
    }
    private static final int WidthResource = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WidthResource = 7
     * }
     */
    public static int WidthResource() {
        return WidthResource;
    }
    private static final int HeightResource = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HeightResource = 8
     * }
     */
    public static int HeightResource() {
        return HeightResource;
    }
    private static final int ReadResource = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ReadResource = 9
     * }
     */
    public static int ReadResource() {
        return ReadResource;
    }
    private static final int WriteResource = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WriteResource = 10
     * }
     */
    public static int WriteResource() {
        return WriteResource;
    }

    private static class AcquireMagickResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AcquireMagickResource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int AcquireMagickResource(const ResourceType type, const magick_uint64_t size)
     * }
     */
    public static FunctionDescriptor AcquireMagickResource$descriptor() {
        return AcquireMagickResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int AcquireMagickResource(const ResourceType type, const magick_uint64_t size)
     * }
     */
    public static MethodHandle AcquireMagickResource$handle() {
        return AcquireMagickResource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int AcquireMagickResource(const ResourceType type, const magick_uint64_t size)
     * }
     */
    public static MemorySegment AcquireMagickResource$address() {
        return AcquireMagickResource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int AcquireMagickResource(const ResourceType type, const magick_uint64_t size)
     * }
     */
    public static int AcquireMagickResource(int type, long size) {
        var mh$ = AcquireMagickResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireMagickResource", type, size);
            }
            return (int)mh$.invokeExact(type, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ListMagickResourceInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ListMagickResourceInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ListMagickResourceInfo(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ListMagickResourceInfo$descriptor() {
        return ListMagickResourceInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ListMagickResourceInfo(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ListMagickResourceInfo$handle() {
        return ListMagickResourceInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ListMagickResourceInfo(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ListMagickResourceInfo$address() {
        return ListMagickResourceInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ListMagickResourceInfo(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static int ListMagickResourceInfo(MemorySegment file, MemorySegment exception) {
        var mh$ = ListMagickResourceInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ListMagickResourceInfo", file, exception);
            }
            return (int)mh$.invokeExact(file, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMagickResourceLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetMagickResourceLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SetMagickResourceLimit(const ResourceType type, const magick_int64_t limit)
     * }
     */
    public static FunctionDescriptor SetMagickResourceLimit$descriptor() {
        return SetMagickResourceLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SetMagickResourceLimit(const ResourceType type, const magick_int64_t limit)
     * }
     */
    public static MethodHandle SetMagickResourceLimit$handle() {
        return SetMagickResourceLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SetMagickResourceLimit(const ResourceType type, const magick_int64_t limit)
     * }
     */
    public static MemorySegment SetMagickResourceLimit$address() {
        return SetMagickResourceLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SetMagickResourceLimit(const ResourceType type, const magick_int64_t limit)
     * }
     */
    public static int SetMagickResourceLimit(int type, long limit) {
        var mh$ = SetMagickResourceLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMagickResourceLimit", type, limit);
            }
            return (int)mh$.invokeExact(type, limit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMagickResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetMagickResource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern magick_int64_t GetMagickResource(const ResourceType type)
     * }
     */
    public static FunctionDescriptor GetMagickResource$descriptor() {
        return GetMagickResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern magick_int64_t GetMagickResource(const ResourceType type)
     * }
     */
    public static MethodHandle GetMagickResource$handle() {
        return GetMagickResource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern magick_int64_t GetMagickResource(const ResourceType type)
     * }
     */
    public static MemorySegment GetMagickResource$address() {
        return GetMagickResource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern magick_int64_t GetMagickResource(const ResourceType type)
     * }
     */
    public static long GetMagickResource(int type) {
        var mh$ = GetMagickResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMagickResource", type);
            }
            return (long)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMagickResourceLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetMagickResourceLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern magick_int64_t GetMagickResourceLimit(const ResourceType type)
     * }
     */
    public static FunctionDescriptor GetMagickResourceLimit$descriptor() {
        return GetMagickResourceLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern magick_int64_t GetMagickResourceLimit(const ResourceType type)
     * }
     */
    public static MethodHandle GetMagickResourceLimit$handle() {
        return GetMagickResourceLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern magick_int64_t GetMagickResourceLimit(const ResourceType type)
     * }
     */
    public static MemorySegment GetMagickResourceLimit$address() {
        return GetMagickResourceLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern magick_int64_t GetMagickResourceLimit(const ResourceType type)
     * }
     */
    public static long GetMagickResourceLimit(int type) {
        var mh$ = GetMagickResourceLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMagickResourceLimit", type);
            }
            return (long)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyMagickResources {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DestroyMagickResources");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DestroyMagickResources()
     * }
     */
    public static FunctionDescriptor DestroyMagickResources$descriptor() {
        return DestroyMagickResources.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DestroyMagickResources()
     * }
     */
    public static MethodHandle DestroyMagickResources$handle() {
        return DestroyMagickResources.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DestroyMagickResources()
     * }
     */
    public static MemorySegment DestroyMagickResources$address() {
        return DestroyMagickResources.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DestroyMagickResources()
     * }
     */
    public static void DestroyMagickResources() {
        var mh$ = DestroyMagickResources.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyMagickResources");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeMagickResources {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("InitializeMagickResources");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void InitializeMagickResources()
     * }
     */
    public static FunctionDescriptor InitializeMagickResources$descriptor() {
        return InitializeMagickResources.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void InitializeMagickResources()
     * }
     */
    public static MethodHandle InitializeMagickResources$handle() {
        return InitializeMagickResources.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void InitializeMagickResources()
     * }
     */
    public static MemorySegment InitializeMagickResources$address() {
        return InitializeMagickResources.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void InitializeMagickResources()
     * }
     */
    public static void InitializeMagickResources() {
        var mh$ = InitializeMagickResources.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeMagickResources");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LiberateMagickResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_INT,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("LiberateMagickResource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void LiberateMagickResource(const ResourceType type, const magick_uint64_t size)
     * }
     */
    public static FunctionDescriptor LiberateMagickResource$descriptor() {
        return LiberateMagickResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void LiberateMagickResource(const ResourceType type, const magick_uint64_t size)
     * }
     */
    public static MethodHandle LiberateMagickResource$handle() {
        return LiberateMagickResource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void LiberateMagickResource(const ResourceType type, const magick_uint64_t size)
     * }
     */
    public static MemorySegment LiberateMagickResource$address() {
        return LiberateMagickResource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void LiberateMagickResource(const ResourceType type, const magick_uint64_t size)
     * }
     */
    public static void LiberateMagickResource(int type, long size) {
        var mh$ = LiberateMagickResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LiberateMagickResource", type, size);
            }
            mh$.invokeExact(type, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToChannelType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToChannelType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ChannelType StringToChannelType(const char *option)
     * }
     */
    public static FunctionDescriptor StringToChannelType$descriptor() {
        return StringToChannelType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ChannelType StringToChannelType(const char *option)
     * }
     */
    public static MethodHandle StringToChannelType$handle() {
        return StringToChannelType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ChannelType StringToChannelType(const char *option)
     * }
     */
    public static MemorySegment StringToChannelType$address() {
        return StringToChannelType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ChannelType StringToChannelType(const char *option)
     * }
     */
    public static int StringToChannelType(MemorySegment option) {
        var mh$ = StringToChannelType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToChannelType", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToColorspaceType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToColorspaceType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ColorspaceType StringToColorspaceType(const char *colorspace_string)
     * }
     */
    public static FunctionDescriptor StringToColorspaceType$descriptor() {
        return StringToColorspaceType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ColorspaceType StringToColorspaceType(const char *colorspace_string)
     * }
     */
    public static MethodHandle StringToColorspaceType$handle() {
        return StringToColorspaceType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ColorspaceType StringToColorspaceType(const char *colorspace_string)
     * }
     */
    public static MemorySegment StringToColorspaceType$address() {
        return StringToColorspaceType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ColorspaceType StringToColorspaceType(const char *colorspace_string)
     * }
     */
    public static int StringToColorspaceType(MemorySegment colorspace_string) {
        var mh$ = StringToColorspaceType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToColorspaceType", colorspace_string);
            }
            return (int)mh$.invokeExact(colorspace_string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToCompositeOperator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToCompositeOperator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern CompositeOperator StringToCompositeOperator(const char *option)
     * }
     */
    public static FunctionDescriptor StringToCompositeOperator$descriptor() {
        return StringToCompositeOperator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern CompositeOperator StringToCompositeOperator(const char *option)
     * }
     */
    public static MethodHandle StringToCompositeOperator$handle() {
        return StringToCompositeOperator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern CompositeOperator StringToCompositeOperator(const char *option)
     * }
     */
    public static MemorySegment StringToCompositeOperator$address() {
        return StringToCompositeOperator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern CompositeOperator StringToCompositeOperator(const char *option)
     * }
     */
    public static int StringToCompositeOperator(MemorySegment option) {
        var mh$ = StringToCompositeOperator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToCompositeOperator", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToCompressionType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToCompressionType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern CompressionType StringToCompressionType(const char *option)
     * }
     */
    public static FunctionDescriptor StringToCompressionType$descriptor() {
        return StringToCompressionType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern CompressionType StringToCompressionType(const char *option)
     * }
     */
    public static MethodHandle StringToCompressionType$handle() {
        return StringToCompressionType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern CompressionType StringToCompressionType(const char *option)
     * }
     */
    public static MemorySegment StringToCompressionType$address() {
        return StringToCompressionType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern CompressionType StringToCompressionType(const char *option)
     * }
     */
    public static int StringToCompressionType(MemorySegment option) {
        var mh$ = StringToCompressionType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToCompressionType", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToDisposeType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToDisposeType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern DisposeType StringToDisposeType(const char *option)
     * }
     */
    public static FunctionDescriptor StringToDisposeType$descriptor() {
        return StringToDisposeType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern DisposeType StringToDisposeType(const char *option)
     * }
     */
    public static MethodHandle StringToDisposeType$handle() {
        return StringToDisposeType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern DisposeType StringToDisposeType(const char *option)
     * }
     */
    public static MemorySegment StringToDisposeType$address() {
        return StringToDisposeType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern DisposeType StringToDisposeType(const char *option)
     * }
     */
    public static int StringToDisposeType(MemorySegment option) {
        var mh$ = StringToDisposeType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToDisposeType", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToEndianType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToEndianType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern EndianType StringToEndianType(const char *option)
     * }
     */
    public static FunctionDescriptor StringToEndianType$descriptor() {
        return StringToEndianType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern EndianType StringToEndianType(const char *option)
     * }
     */
    public static MethodHandle StringToEndianType$handle() {
        return StringToEndianType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern EndianType StringToEndianType(const char *option)
     * }
     */
    public static MemorySegment StringToEndianType$address() {
        return StringToEndianType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern EndianType StringToEndianType(const char *option)
     * }
     */
    public static int StringToEndianType(MemorySegment option) {
        var mh$ = StringToEndianType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToEndianType", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToFilterTypes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToFilterTypes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FilterTypes StringToFilterTypes(const char *option)
     * }
     */
    public static FunctionDescriptor StringToFilterTypes$descriptor() {
        return StringToFilterTypes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FilterTypes StringToFilterTypes(const char *option)
     * }
     */
    public static MethodHandle StringToFilterTypes$handle() {
        return StringToFilterTypes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FilterTypes StringToFilterTypes(const char *option)
     * }
     */
    public static MemorySegment StringToFilterTypes$address() {
        return StringToFilterTypes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FilterTypes StringToFilterTypes(const char *option)
     * }
     */
    public static int StringToFilterTypes(MemorySegment option) {
        var mh$ = StringToFilterTypes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToFilterTypes", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToGravityType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToGravityType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GravityType StringToGravityType(const char *option)
     * }
     */
    public static FunctionDescriptor StringToGravityType$descriptor() {
        return StringToGravityType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GravityType StringToGravityType(const char *option)
     * }
     */
    public static MethodHandle StringToGravityType$handle() {
        return StringToGravityType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GravityType StringToGravityType(const char *option)
     * }
     */
    public static MemorySegment StringToGravityType$address() {
        return StringToGravityType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GravityType StringToGravityType(const char *option)
     * }
     */
    public static int StringToGravityType(MemorySegment option) {
        var mh$ = StringToGravityType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToGravityType", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToHighlightStyle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToHighlightStyle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HighlightStyle StringToHighlightStyle(const char *option)
     * }
     */
    public static FunctionDescriptor StringToHighlightStyle$descriptor() {
        return StringToHighlightStyle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HighlightStyle StringToHighlightStyle(const char *option)
     * }
     */
    public static MethodHandle StringToHighlightStyle$handle() {
        return StringToHighlightStyle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern HighlightStyle StringToHighlightStyle(const char *option)
     * }
     */
    public static MemorySegment StringToHighlightStyle$address() {
        return StringToHighlightStyle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern HighlightStyle StringToHighlightStyle(const char *option)
     * }
     */
    public static int StringToHighlightStyle(MemorySegment option) {
        var mh$ = StringToHighlightStyle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToHighlightStyle", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToImageType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToImageType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ImageType StringToImageType(const char *option)
     * }
     */
    public static FunctionDescriptor StringToImageType$descriptor() {
        return StringToImageType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ImageType StringToImageType(const char *option)
     * }
     */
    public static MethodHandle StringToImageType$handle() {
        return StringToImageType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ImageType StringToImageType(const char *option)
     * }
     */
    public static MemorySegment StringToImageType$address() {
        return StringToImageType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ImageType StringToImageType(const char *option)
     * }
     */
    public static int StringToImageType(MemorySegment option) {
        var mh$ = StringToImageType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToImageType", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToInterlaceType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToInterlaceType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern InterlaceType StringToInterlaceType(const char *option)
     * }
     */
    public static FunctionDescriptor StringToInterlaceType$descriptor() {
        return StringToInterlaceType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern InterlaceType StringToInterlaceType(const char *option)
     * }
     */
    public static MethodHandle StringToInterlaceType$handle() {
        return StringToInterlaceType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern InterlaceType StringToInterlaceType(const char *option)
     * }
     */
    public static MemorySegment StringToInterlaceType$address() {
        return StringToInterlaceType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern InterlaceType StringToInterlaceType(const char *option)
     * }
     */
    public static int StringToInterlaceType(MemorySegment option) {
        var mh$ = StringToInterlaceType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToInterlaceType", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToMetricType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToMetricType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern MetricType StringToMetricType(const char *option)
     * }
     */
    public static FunctionDescriptor StringToMetricType$descriptor() {
        return StringToMetricType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern MetricType StringToMetricType(const char *option)
     * }
     */
    public static MethodHandle StringToMetricType$handle() {
        return StringToMetricType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern MetricType StringToMetricType(const char *option)
     * }
     */
    public static MemorySegment StringToMetricType$address() {
        return StringToMetricType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern MetricType StringToMetricType(const char *option)
     * }
     */
    public static int StringToMetricType(MemorySegment option) {
        var mh$ = StringToMetricType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToMetricType", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToNoiseType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToNoiseType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern NoiseType StringToNoiseType(const char *option)
     * }
     */
    public static FunctionDescriptor StringToNoiseType$descriptor() {
        return StringToNoiseType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern NoiseType StringToNoiseType(const char *option)
     * }
     */
    public static MethodHandle StringToNoiseType$handle() {
        return StringToNoiseType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern NoiseType StringToNoiseType(const char *option)
     * }
     */
    public static MemorySegment StringToNoiseType$address() {
        return StringToNoiseType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern NoiseType StringToNoiseType(const char *option)
     * }
     */
    public static int StringToNoiseType(MemorySegment option) {
        var mh$ = StringToNoiseType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToNoiseType", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToOrientationType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToOrientationType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern OrientationType StringToOrientationType(const char *option)
     * }
     */
    public static FunctionDescriptor StringToOrientationType$descriptor() {
        return StringToOrientationType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern OrientationType StringToOrientationType(const char *option)
     * }
     */
    public static MethodHandle StringToOrientationType$handle() {
        return StringToOrientationType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern OrientationType StringToOrientationType(const char *option)
     * }
     */
    public static MemorySegment StringToOrientationType$address() {
        return StringToOrientationType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern OrientationType StringToOrientationType(const char *option)
     * }
     */
    public static int StringToOrientationType(MemorySegment option) {
        var mh$ = StringToOrientationType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToOrientationType", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToPreviewType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToPreviewType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PreviewType StringToPreviewType(const char *option)
     * }
     */
    public static FunctionDescriptor StringToPreviewType$descriptor() {
        return StringToPreviewType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PreviewType StringToPreviewType(const char *option)
     * }
     */
    public static MethodHandle StringToPreviewType$handle() {
        return StringToPreviewType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PreviewType StringToPreviewType(const char *option)
     * }
     */
    public static MemorySegment StringToPreviewType$address() {
        return StringToPreviewType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PreviewType StringToPreviewType(const char *option)
     * }
     */
    public static int StringToPreviewType(MemorySegment option) {
        var mh$ = StringToPreviewType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToPreviewType", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToResolutionType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToResolutionType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ResolutionType StringToResolutionType(const char *option)
     * }
     */
    public static FunctionDescriptor StringToResolutionType$descriptor() {
        return StringToResolutionType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ResolutionType StringToResolutionType(const char *option)
     * }
     */
    public static MethodHandle StringToResolutionType$handle() {
        return StringToResolutionType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ResolutionType StringToResolutionType(const char *option)
     * }
     */
    public static MemorySegment StringToResolutionType$address() {
        return StringToResolutionType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ResolutionType StringToResolutionType(const char *option)
     * }
     */
    public static int StringToResolutionType(MemorySegment option) {
        var mh$ = StringToResolutionType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToResolutionType", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToQuantumOperator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToQuantumOperator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern QuantumOperator StringToQuantumOperator(const char *option)
     * }
     */
    public static FunctionDescriptor StringToQuantumOperator$descriptor() {
        return StringToQuantumOperator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern QuantumOperator StringToQuantumOperator(const char *option)
     * }
     */
    public static MethodHandle StringToQuantumOperator$handle() {
        return StringToQuantumOperator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern QuantumOperator StringToQuantumOperator(const char *option)
     * }
     */
    public static MemorySegment StringToQuantumOperator$address() {
        return StringToQuantumOperator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern QuantumOperator StringToQuantumOperator(const char *option)
     * }
     */
    public static int StringToQuantumOperator(MemorySegment option) {
        var mh$ = StringToQuantumOperator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToQuantumOperator", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToResourceType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToResourceType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ResourceType StringToResourceType(const char *option)
     * }
     */
    public static FunctionDescriptor StringToResourceType$descriptor() {
        return StringToResourceType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ResourceType StringToResourceType(const char *option)
     * }
     */
    public static MethodHandle StringToResourceType$handle() {
        return StringToResourceType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ResourceType StringToResourceType(const char *option)
     * }
     */
    public static MemorySegment StringToResourceType$address() {
        return StringToResourceType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ResourceType StringToResourceType(const char *option)
     * }
     */
    public static int StringToResourceType(MemorySegment option) {
        var mh$ = StringToResourceType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToResourceType", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToVirtualPixelMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToVirtualPixelMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern VirtualPixelMethod StringToVirtualPixelMethod(const char *option)
     * }
     */
    public static FunctionDescriptor StringToVirtualPixelMethod$descriptor() {
        return StringToVirtualPixelMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern VirtualPixelMethod StringToVirtualPixelMethod(const char *option)
     * }
     */
    public static MethodHandle StringToVirtualPixelMethod$handle() {
        return StringToVirtualPixelMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern VirtualPixelMethod StringToVirtualPixelMethod(const char *option)
     * }
     */
    public static MemorySegment StringToVirtualPixelMethod$address() {
        return StringToVirtualPixelMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern VirtualPixelMethod StringToVirtualPixelMethod(const char *option)
     * }
     */
    public static int StringToVirtualPixelMethod(MemorySegment option) {
        var mh$ = StringToVirtualPixelMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToVirtualPixelMethod", option);
            }
            return (int)mh$.invokeExact(option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BlobModeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("BlobModeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *BlobModeToString(BlobMode blob_mode)
     * }
     */
    public static FunctionDescriptor BlobModeToString$descriptor() {
        return BlobModeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *BlobModeToString(BlobMode blob_mode)
     * }
     */
    public static MethodHandle BlobModeToString$handle() {
        return BlobModeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *BlobModeToString(BlobMode blob_mode)
     * }
     */
    public static MemorySegment BlobModeToString$address() {
        return BlobModeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *BlobModeToString(BlobMode blob_mode)
     * }
     */
    public static MemorySegment BlobModeToString(int blob_mode) {
        var mh$ = BlobModeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BlobModeToString", blob_mode);
            }
            return (MemorySegment)mh$.invokeExact(blob_mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChannelTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ChannelTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ChannelTypeToString(const ChannelType channel)
     * }
     */
    public static FunctionDescriptor ChannelTypeToString$descriptor() {
        return ChannelTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ChannelTypeToString(const ChannelType channel)
     * }
     */
    public static MethodHandle ChannelTypeToString$handle() {
        return ChannelTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ChannelTypeToString(const ChannelType channel)
     * }
     */
    public static MemorySegment ChannelTypeToString$address() {
        return ChannelTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ChannelTypeToString(const ChannelType channel)
     * }
     */
    public static MemorySegment ChannelTypeToString(int channel) {
        var mh$ = ChannelTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChannelTypeToString", channel);
            }
            return (MemorySegment)mh$.invokeExact(channel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClassTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ClassTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ClassTypeToString(const ClassType class_type)
     * }
     */
    public static FunctionDescriptor ClassTypeToString$descriptor() {
        return ClassTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ClassTypeToString(const ClassType class_type)
     * }
     */
    public static MethodHandle ClassTypeToString$handle() {
        return ClassTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ClassTypeToString(const ClassType class_type)
     * }
     */
    public static MemorySegment ClassTypeToString$address() {
        return ClassTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ClassTypeToString(const ClassType class_type)
     * }
     */
    public static MemorySegment ClassTypeToString(int class_type) {
        var mh$ = ClassTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClassTypeToString", class_type);
            }
            return (MemorySegment)mh$.invokeExact(class_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorspaceTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ColorspaceTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ColorspaceTypeToString(const ColorspaceType colorspace)
     * }
     */
    public static FunctionDescriptor ColorspaceTypeToString$descriptor() {
        return ColorspaceTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ColorspaceTypeToString(const ColorspaceType colorspace)
     * }
     */
    public static MethodHandle ColorspaceTypeToString$handle() {
        return ColorspaceTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ColorspaceTypeToString(const ColorspaceType colorspace)
     * }
     */
    public static MemorySegment ColorspaceTypeToString$address() {
        return ColorspaceTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ColorspaceTypeToString(const ColorspaceType colorspace)
     * }
     */
    public static MemorySegment ColorspaceTypeToString(int colorspace) {
        var mh$ = ColorspaceTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorspaceTypeToString", colorspace);
            }
            return (MemorySegment)mh$.invokeExact(colorspace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompositeOperatorToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CompositeOperatorToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *CompositeOperatorToString(const CompositeOperator composite_op)
     * }
     */
    public static FunctionDescriptor CompositeOperatorToString$descriptor() {
        return CompositeOperatorToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *CompositeOperatorToString(const CompositeOperator composite_op)
     * }
     */
    public static MethodHandle CompositeOperatorToString$handle() {
        return CompositeOperatorToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *CompositeOperatorToString(const CompositeOperator composite_op)
     * }
     */
    public static MemorySegment CompositeOperatorToString$address() {
        return CompositeOperatorToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *CompositeOperatorToString(const CompositeOperator composite_op)
     * }
     */
    public static MemorySegment CompositeOperatorToString(int composite_op) {
        var mh$ = CompositeOperatorToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompositeOperatorToString", composite_op);
            }
            return (MemorySegment)mh$.invokeExact(composite_op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompressionTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CompressionTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *CompressionTypeToString(const CompressionType compression_type)
     * }
     */
    public static FunctionDescriptor CompressionTypeToString$descriptor() {
        return CompressionTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *CompressionTypeToString(const CompressionType compression_type)
     * }
     */
    public static MethodHandle CompressionTypeToString$handle() {
        return CompressionTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *CompressionTypeToString(const CompressionType compression_type)
     * }
     */
    public static MemorySegment CompressionTypeToString$address() {
        return CompressionTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *CompressionTypeToString(const CompressionType compression_type)
     * }
     */
    public static MemorySegment CompressionTypeToString(int compression_type) {
        var mh$ = CompressionTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompressionTypeToString", compression_type);
            }
            return (MemorySegment)mh$.invokeExact(compression_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConfirmAccessModeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ConfirmAccessModeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ConfirmAccessModeToString(const ConfirmAccessMode access_mode)
     * }
     */
    public static FunctionDescriptor ConfirmAccessModeToString$descriptor() {
        return ConfirmAccessModeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ConfirmAccessModeToString(const ConfirmAccessMode access_mode)
     * }
     */
    public static MethodHandle ConfirmAccessModeToString$handle() {
        return ConfirmAccessModeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ConfirmAccessModeToString(const ConfirmAccessMode access_mode)
     * }
     */
    public static MemorySegment ConfirmAccessModeToString$address() {
        return ConfirmAccessModeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ConfirmAccessModeToString(const ConfirmAccessMode access_mode)
     * }
     */
    public static MemorySegment ConfirmAccessModeToString(int access_mode) {
        var mh$ = ConfirmAccessModeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConfirmAccessModeToString", access_mode);
            }
            return (MemorySegment)mh$.invokeExact(access_mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisposeTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DisposeTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *DisposeTypeToString(const DisposeType dispose_type)
     * }
     */
    public static FunctionDescriptor DisposeTypeToString$descriptor() {
        return DisposeTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *DisposeTypeToString(const DisposeType dispose_type)
     * }
     */
    public static MethodHandle DisposeTypeToString$handle() {
        return DisposeTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *DisposeTypeToString(const DisposeType dispose_type)
     * }
     */
    public static MemorySegment DisposeTypeToString$address() {
        return DisposeTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *DisposeTypeToString(const DisposeType dispose_type)
     * }
     */
    public static MemorySegment DisposeTypeToString(int dispose_type) {
        var mh$ = DisposeTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisposeTypeToString", dispose_type);
            }
            return (MemorySegment)mh$.invokeExact(dispose_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GravityTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GravityTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *GravityTypeToString(const GravityType gravity_type)
     * }
     */
    public static FunctionDescriptor GravityTypeToString$descriptor() {
        return GravityTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *GravityTypeToString(const GravityType gravity_type)
     * }
     */
    public static MethodHandle GravityTypeToString$handle() {
        return GravityTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *GravityTypeToString(const GravityType gravity_type)
     * }
     */
    public static MemorySegment GravityTypeToString$address() {
        return GravityTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *GravityTypeToString(const GravityType gravity_type)
     * }
     */
    public static MemorySegment GravityTypeToString(int gravity_type) {
        var mh$ = GravityTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GravityTypeToString", gravity_type);
            }
            return (MemorySegment)mh$.invokeExact(gravity_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndianTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("EndianTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *EndianTypeToString(const EndianType endian_type)
     * }
     */
    public static FunctionDescriptor EndianTypeToString$descriptor() {
        return EndianTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *EndianTypeToString(const EndianType endian_type)
     * }
     */
    public static MethodHandle EndianTypeToString$handle() {
        return EndianTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *EndianTypeToString(const EndianType endian_type)
     * }
     */
    public static MemorySegment EndianTypeToString$address() {
        return EndianTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *EndianTypeToString(const EndianType endian_type)
     * }
     */
    public static MemorySegment EndianTypeToString(int endian_type) {
        var mh$ = EndianTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndianTypeToString", endian_type);
            }
            return (MemorySegment)mh$.invokeExact(endian_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HighlightStyleToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("HighlightStyleToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *HighlightStyleToString(const HighlightStyle difference_algorithm)
     * }
     */
    public static FunctionDescriptor HighlightStyleToString$descriptor() {
        return HighlightStyleToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *HighlightStyleToString(const HighlightStyle difference_algorithm)
     * }
     */
    public static MethodHandle HighlightStyleToString$handle() {
        return HighlightStyleToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *HighlightStyleToString(const HighlightStyle difference_algorithm)
     * }
     */
    public static MemorySegment HighlightStyleToString$address() {
        return HighlightStyleToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *HighlightStyleToString(const HighlightStyle difference_algorithm)
     * }
     */
    public static MemorySegment HighlightStyleToString(int difference_algorithm) {
        var mh$ = HighlightStyleToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HighlightStyleToString", difference_algorithm);
            }
            return (MemorySegment)mh$.invokeExact(difference_algorithm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ImageTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ImageTypeToString(const ImageType image_type)
     * }
     */
    public static FunctionDescriptor ImageTypeToString$descriptor() {
        return ImageTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ImageTypeToString(const ImageType image_type)
     * }
     */
    public static MethodHandle ImageTypeToString$handle() {
        return ImageTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ImageTypeToString(const ImageType image_type)
     * }
     */
    public static MemorySegment ImageTypeToString$address() {
        return ImageTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ImageTypeToString(const ImageType image_type)
     * }
     */
    public static MemorySegment ImageTypeToString(int image_type) {
        var mh$ = ImageTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageTypeToString", image_type);
            }
            return (MemorySegment)mh$.invokeExact(image_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlaceTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("InterlaceTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *InterlaceTypeToString(const InterlaceType interlace_type)
     * }
     */
    public static FunctionDescriptor InterlaceTypeToString$descriptor() {
        return InterlaceTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *InterlaceTypeToString(const InterlaceType interlace_type)
     * }
     */
    public static MethodHandle InterlaceTypeToString$handle() {
        return InterlaceTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *InterlaceTypeToString(const InterlaceType interlace_type)
     * }
     */
    public static MemorySegment InterlaceTypeToString$address() {
        return InterlaceTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *InterlaceTypeToString(const InterlaceType interlace_type)
     * }
     */
    public static MemorySegment InterlaceTypeToString(int interlace_type) {
        var mh$ = InterlaceTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlaceTypeToString", interlace_type);
            }
            return (MemorySegment)mh$.invokeExact(interlace_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapModeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MapModeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *MapModeToString(MapMode map_mode)
     * }
     */
    public static FunctionDescriptor MapModeToString$descriptor() {
        return MapModeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *MapModeToString(MapMode map_mode)
     * }
     */
    public static MethodHandle MapModeToString$handle() {
        return MapModeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *MapModeToString(MapMode map_mode)
     * }
     */
    public static MemorySegment MapModeToString$address() {
        return MapModeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *MapModeToString(MapMode map_mode)
     * }
     */
    public static MemorySegment MapModeToString(int map_mode) {
        var mh$ = MapModeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapModeToString", map_mode);
            }
            return (MemorySegment)mh$.invokeExact(map_mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MetricTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MetricTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *MetricTypeToString(MetricType metric)
     * }
     */
    public static FunctionDescriptor MetricTypeToString$descriptor() {
        return MetricTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *MetricTypeToString(MetricType metric)
     * }
     */
    public static MethodHandle MetricTypeToString$handle() {
        return MetricTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *MetricTypeToString(MetricType metric)
     * }
     */
    public static MemorySegment MetricTypeToString$address() {
        return MetricTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *MetricTypeToString(MetricType metric)
     * }
     */
    public static MemorySegment MetricTypeToString(int metric) {
        var mh$ = MetricTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MetricTypeToString", metric);
            }
            return (MemorySegment)mh$.invokeExact(metric);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NoiseTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("NoiseTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *NoiseTypeToString(NoiseType noise_type)
     * }
     */
    public static FunctionDescriptor NoiseTypeToString$descriptor() {
        return NoiseTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *NoiseTypeToString(NoiseType noise_type)
     * }
     */
    public static MethodHandle NoiseTypeToString$handle() {
        return NoiseTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *NoiseTypeToString(NoiseType noise_type)
     * }
     */
    public static MemorySegment NoiseTypeToString$address() {
        return NoiseTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *NoiseTypeToString(NoiseType noise_type)
     * }
     */
    public static MemorySegment NoiseTypeToString(int noise_type) {
        var mh$ = NoiseTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NoiseTypeToString", noise_type);
            }
            return (MemorySegment)mh$.invokeExact(noise_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OrientationTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("OrientationTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *OrientationTypeToString(const OrientationType orientation_type)
     * }
     */
    public static FunctionDescriptor OrientationTypeToString$descriptor() {
        return OrientationTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *OrientationTypeToString(const OrientationType orientation_type)
     * }
     */
    public static MethodHandle OrientationTypeToString$handle() {
        return OrientationTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *OrientationTypeToString(const OrientationType orientation_type)
     * }
     */
    public static MemorySegment OrientationTypeToString$address() {
        return OrientationTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *OrientationTypeToString(const OrientationType orientation_type)
     * }
     */
    public static MemorySegment OrientationTypeToString(int orientation_type) {
        var mh$ = OrientationTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OrientationTypeToString", orientation_type);
            }
            return (MemorySegment)mh$.invokeExact(orientation_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuantumOperatorToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("QuantumOperatorToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *QuantumOperatorToString(const QuantumOperator quantum_operator)
     * }
     */
    public static FunctionDescriptor QuantumOperatorToString$descriptor() {
        return QuantumOperatorToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *QuantumOperatorToString(const QuantumOperator quantum_operator)
     * }
     */
    public static MethodHandle QuantumOperatorToString$handle() {
        return QuantumOperatorToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *QuantumOperatorToString(const QuantumOperator quantum_operator)
     * }
     */
    public static MemorySegment QuantumOperatorToString$address() {
        return QuantumOperatorToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *QuantumOperatorToString(const QuantumOperator quantum_operator)
     * }
     */
    public static MemorySegment QuantumOperatorToString(int quantum_operator) {
        var mh$ = QuantumOperatorToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuantumOperatorToString", quantum_operator);
            }
            return (MemorySegment)mh$.invokeExact(quantum_operator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResizeFilterToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ResizeFilterToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ResizeFilterToString(const FilterTypes filter)
     * }
     */
    public static FunctionDescriptor ResizeFilterToString$descriptor() {
        return ResizeFilterToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ResizeFilterToString(const FilterTypes filter)
     * }
     */
    public static MethodHandle ResizeFilterToString$handle() {
        return ResizeFilterToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ResizeFilterToString(const FilterTypes filter)
     * }
     */
    public static MemorySegment ResizeFilterToString$address() {
        return ResizeFilterToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ResizeFilterToString(const FilterTypes filter)
     * }
     */
    public static MemorySegment ResizeFilterToString(int filter) {
        var mh$ = ResizeFilterToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResizeFilterToString", filter);
            }
            return (MemorySegment)mh$.invokeExact(filter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResolutionTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ResolutionTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ResolutionTypeToString(const ResolutionType resolution_type)
     * }
     */
    public static FunctionDescriptor ResolutionTypeToString$descriptor() {
        return ResolutionTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ResolutionTypeToString(const ResolutionType resolution_type)
     * }
     */
    public static MethodHandle ResolutionTypeToString$handle() {
        return ResolutionTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ResolutionTypeToString(const ResolutionType resolution_type)
     * }
     */
    public static MemorySegment ResolutionTypeToString$address() {
        return ResolutionTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ResolutionTypeToString(const ResolutionType resolution_type)
     * }
     */
    public static MemorySegment ResolutionTypeToString(int resolution_type) {
        var mh$ = ResolutionTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResolutionTypeToString", resolution_type);
            }
            return (MemorySegment)mh$.invokeExact(resolution_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StretchTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StretchTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *StretchTypeToString(StretchType stretch)
     * }
     */
    public static FunctionDescriptor StretchTypeToString$descriptor() {
        return StretchTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *StretchTypeToString(StretchType stretch)
     * }
     */
    public static MethodHandle StretchTypeToString$handle() {
        return StretchTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *StretchTypeToString(StretchType stretch)
     * }
     */
    public static MemorySegment StretchTypeToString$address() {
        return StretchTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *StretchTypeToString(StretchType stretch)
     * }
     */
    public static MemorySegment StretchTypeToString(int stretch) {
        var mh$ = StretchTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StretchTypeToString", stretch);
            }
            return (MemorySegment)mh$.invokeExact(stretch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StyleTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StyleTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *StyleTypeToString(StyleType style)
     * }
     */
    public static FunctionDescriptor StyleTypeToString$descriptor() {
        return StyleTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *StyleTypeToString(StyleType style)
     * }
     */
    public static MethodHandle StyleTypeToString$handle() {
        return StyleTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *StyleTypeToString(StyleType style)
     * }
     */
    public static MemorySegment StyleTypeToString$address() {
        return StyleTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *StyleTypeToString(StyleType style)
     * }
     */
    public static MemorySegment StyleTypeToString(int style) {
        var mh$ = StyleTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StyleTypeToString", style);
            }
            return (MemorySegment)mh$.invokeExact(style);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharcoalImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CharcoalImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *CharcoalImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor CharcoalImage$descriptor() {
        return CharcoalImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *CharcoalImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle CharcoalImage$handle() {
        return CharcoalImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *CharcoalImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment CharcoalImage$address() {
        return CharcoalImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *CharcoalImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment CharcoalImage(MemorySegment x0, double x1, double x2, MemorySegment x3) {
        var mh$ = CharcoalImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharcoalImage", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorizeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            _PixelPacket.layout(),
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ColorizeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ColorizeImage(const Image *, const char *, const PixelPacket, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor ColorizeImage$descriptor() {
        return ColorizeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ColorizeImage(const Image *, const char *, const PixelPacket, ExceptionInfo *)
     * }
     */
    public static MethodHandle ColorizeImage$handle() {
        return ColorizeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ColorizeImage(const Image *, const char *, const PixelPacket, ExceptionInfo *)
     * }
     */
    public static MemorySegment ColorizeImage$address() {
        return ColorizeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ColorizeImage(const Image *, const char *, const PixelPacket, ExceptionInfo *)
     * }
     */
    public static MemorySegment ColorizeImage(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ColorizeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorizeImage", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImplodeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ImplodeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ImplodeImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor ImplodeImage$descriptor() {
        return ImplodeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ImplodeImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle ImplodeImage$handle() {
        return ImplodeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ImplodeImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment ImplodeImage$address() {
        return ImplodeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ImplodeImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment ImplodeImage(MemorySegment x0, double x1, MemorySegment x2) {
        var mh$ = ImplodeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImplodeImage", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MorphImages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MorphImages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *MorphImages(const Image *, const unsigned long, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor MorphImages$descriptor() {
        return MorphImages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *MorphImages(const Image *, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MethodHandle MorphImages$handle() {
        return MorphImages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *MorphImages(const Image *, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MemorySegment MorphImages$address() {
        return MorphImages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *MorphImages(const Image *, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MemorySegment MorphImages(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = MorphImages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MorphImages", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OilPaintImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("OilPaintImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *OilPaintImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor OilPaintImage$descriptor() {
        return OilPaintImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *OilPaintImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle OilPaintImage$handle() {
        return OilPaintImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *OilPaintImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment OilPaintImage$address() {
        return OilPaintImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *OilPaintImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment OilPaintImage(MemorySegment x0, double x1, MemorySegment x2) {
        var mh$ = OilPaintImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OilPaintImage", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteganoImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SteganoImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *SteganoImage(const Image *, const Image *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor SteganoImage$descriptor() {
        return SteganoImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *SteganoImage(const Image *, const Image *, ExceptionInfo *)
     * }
     */
    public static MethodHandle SteganoImage$handle() {
        return SteganoImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *SteganoImage(const Image *, const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment SteganoImage$address() {
        return SteganoImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *SteganoImage(const Image *, const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment SteganoImage(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = SteganoImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteganoImage", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StereoImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StereoImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *StereoImage(const Image *, const Image *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor StereoImage$descriptor() {
        return StereoImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *StereoImage(const Image *, const Image *, ExceptionInfo *)
     * }
     */
    public static MethodHandle StereoImage$handle() {
        return StereoImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *StereoImage(const Image *, const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment StereoImage$address() {
        return StereoImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *StereoImage(const Image *, const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment StereoImage(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = StereoImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StereoImage", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwirlImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SwirlImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *SwirlImage(const Image *, double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor SwirlImage$descriptor() {
        return SwirlImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *SwirlImage(const Image *, double, ExceptionInfo *)
     * }
     */
    public static MethodHandle SwirlImage$handle() {
        return SwirlImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *SwirlImage(const Image *, double, ExceptionInfo *)
     * }
     */
    public static MemorySegment SwirlImage$address() {
        return SwirlImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *SwirlImage(const Image *, double, ExceptionInfo *)
     * }
     */
    public static MemorySegment SwirlImage(MemorySegment x0, double x1, MemorySegment x2) {
        var mh$ = SwirlImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwirlImage", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaveImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("WaveImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *WaveImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor WaveImage$descriptor() {
        return WaveImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *WaveImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle WaveImage$handle() {
        return WaveImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *WaveImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment WaveImage$address() {
        return WaveImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *WaveImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment WaveImage(MemorySegment x0, double x1, double x2, MemorySegment x3) {
        var mh$ = WaveImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaveImage", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorMatrixImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ColorMatrixImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ColorMatrixImage(Image *image, const unsigned int order, const double *matrix)
     * }
     */
    public static FunctionDescriptor ColorMatrixImage$descriptor() {
        return ColorMatrixImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ColorMatrixImage(Image *image, const unsigned int order, const double *matrix)
     * }
     */
    public static MethodHandle ColorMatrixImage$handle() {
        return ColorMatrixImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ColorMatrixImage(Image *image, const unsigned int order, const double *matrix)
     * }
     */
    public static MemorySegment ColorMatrixImage$address() {
        return ColorMatrixImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ColorMatrixImage(Image *image, const unsigned int order, const double *matrix)
     * }
     */
    public static int ColorMatrixImage(MemorySegment image, int order, MemorySegment matrix) {
        var mh$ = ColorMatrixImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorMatrixImage", image, order, matrix);
            }
            return (int)mh$.invokeExact(image, order, matrix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SolarizeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SolarizeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SolarizeImage(Image *, const double)
     * }
     */
    public static FunctionDescriptor SolarizeImage$descriptor() {
        return SolarizeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SolarizeImage(Image *, const double)
     * }
     */
    public static MethodHandle SolarizeImage$handle() {
        return SolarizeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SolarizeImage(Image *, const double)
     * }
     */
    public static MemorySegment SolarizeImage$address() {
        return SolarizeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SolarizeImage(Image *, const double)
     * }
     */
    public static int SolarizeImage(MemorySegment x0, double x1) {
        var mh$ = SolarizeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SolarizeImage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickRandomInteger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickRandomInteger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * magick_uint32_t MagickRandomInteger()
     * }
     */
    public static FunctionDescriptor MagickRandomInteger$descriptor() {
        return MagickRandomInteger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * magick_uint32_t MagickRandomInteger()
     * }
     */
    public static MethodHandle MagickRandomInteger$handle() {
        return MagickRandomInteger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * magick_uint32_t MagickRandomInteger()
     * }
     */
    public static MemorySegment MagickRandomInteger$address() {
        return MagickRandomInteger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * magick_uint32_t MagickRandomInteger()
     * }
     */
    public static int MagickRandomInteger() {
        var mh$ = MagickRandomInteger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickRandomInteger");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickRandomReal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickRandomReal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double MagickRandomReal()
     * }
     */
    public static FunctionDescriptor MagickRandomReal$descriptor() {
        return MagickRandomReal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double MagickRandomReal()
     * }
     */
    public static MethodHandle MagickRandomReal$handle() {
        return MagickRandomReal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double MagickRandomReal()
     * }
     */
    public static MemorySegment MagickRandomReal$address() {
        return MagickRandomReal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double MagickRandomReal()
     * }
     */
    public static double MagickRandomReal() {
        var mh$ = MagickRandomReal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickRandomReal");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExpandAffine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ExpandAffine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ExpandAffine(const AffineMatrix *)
     * }
     */
    public static FunctionDescriptor ExpandAffine$descriptor() {
        return ExpandAffine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ExpandAffine(const AffineMatrix *)
     * }
     */
    public static MethodHandle ExpandAffine$handle() {
        return ExpandAffine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ExpandAffine(const AffineMatrix *)
     * }
     */
    public static MemorySegment ExpandAffine$address() {
        return ExpandAffine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ExpandAffine(const AffineMatrix *)
     * }
     */
    public static double ExpandAffine(MemorySegment x0) {
        var mh$ = ExpandAffine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExpandAffine", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenerateDifferentialNoise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_SHORT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GenerateDifferentialNoise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double GenerateDifferentialNoise(const Quantum pixel, const NoiseType noise_type, MagickRandomKernel *kernel)
     * }
     */
    public static FunctionDescriptor GenerateDifferentialNoise$descriptor() {
        return GenerateDifferentialNoise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double GenerateDifferentialNoise(const Quantum pixel, const NoiseType noise_type, MagickRandomKernel *kernel)
     * }
     */
    public static MethodHandle GenerateDifferentialNoise$handle() {
        return GenerateDifferentialNoise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double GenerateDifferentialNoise(const Quantum pixel, const NoiseType noise_type, MagickRandomKernel *kernel)
     * }
     */
    public static MemorySegment GenerateDifferentialNoise$address() {
        return GenerateDifferentialNoise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double GenerateDifferentialNoise(const Quantum pixel, const NoiseType noise_type, MagickRandomKernel *kernel)
     * }
     */
    public static double GenerateDifferentialNoise(short pixel, int noise_type, MemorySegment kernel) {
        var mh$ = GenerateDifferentialNoise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenerateDifferentialNoise", pixel, noise_type, kernel);
            }
            return (double)mh$.invokeExact(pixel, noise_type, kernel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOptimalKernelWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetOptimalKernelWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int GetOptimalKernelWidth(const double, const double)
     * }
     */
    public static FunctionDescriptor GetOptimalKernelWidth$descriptor() {
        return GetOptimalKernelWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int GetOptimalKernelWidth(const double, const double)
     * }
     */
    public static MethodHandle GetOptimalKernelWidth$handle() {
        return GetOptimalKernelWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int GetOptimalKernelWidth(const double, const double)
     * }
     */
    public static MemorySegment GetOptimalKernelWidth$address() {
        return GetOptimalKernelWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int GetOptimalKernelWidth(const double, const double)
     * }
     */
    public static int GetOptimalKernelWidth(double x0, double x1) {
        var mh$ = GetOptimalKernelWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOptimalKernelWidth", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOptimalKernelWidth1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetOptimalKernelWidth1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int GetOptimalKernelWidth1D(const double, const double)
     * }
     */
    public static FunctionDescriptor GetOptimalKernelWidth1D$descriptor() {
        return GetOptimalKernelWidth1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int GetOptimalKernelWidth1D(const double, const double)
     * }
     */
    public static MethodHandle GetOptimalKernelWidth1D$handle() {
        return GetOptimalKernelWidth1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int GetOptimalKernelWidth1D(const double, const double)
     * }
     */
    public static MemorySegment GetOptimalKernelWidth1D$address() {
        return GetOptimalKernelWidth1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int GetOptimalKernelWidth1D(const double, const double)
     * }
     */
    public static int GetOptimalKernelWidth1D(double x0, double x1) {
        var mh$ = GetOptimalKernelWidth1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOptimalKernelWidth1D", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOptimalKernelWidth2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetOptimalKernelWidth2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int GetOptimalKernelWidth2D(const double, const double)
     * }
     */
    public static FunctionDescriptor GetOptimalKernelWidth2D$descriptor() {
        return GetOptimalKernelWidth2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int GetOptimalKernelWidth2D(const double, const double)
     * }
     */
    public static MethodHandle GetOptimalKernelWidth2D$handle() {
        return GetOptimalKernelWidth2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int GetOptimalKernelWidth2D(const double, const double)
     * }
     */
    public static MemorySegment GetOptimalKernelWidth2D$address() {
        return GetOptimalKernelWidth2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int GetOptimalKernelWidth2D(const double, const double)
     * }
     */
    public static int GetOptimalKernelWidth2D(double x0, double x1) {
        var mh$ = GetOptimalKernelWidth2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOptimalKernelWidth2D", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenerateNoise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_SHORT,
            magick_wand_h.C_SHORT,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GenerateNoise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Quantum GenerateNoise(const Quantum, const NoiseType)
     * }
     */
    public static FunctionDescriptor GenerateNoise$descriptor() {
        return GenerateNoise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Quantum GenerateNoise(const Quantum, const NoiseType)
     * }
     */
    public static MethodHandle GenerateNoise$handle() {
        return GenerateNoise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Quantum GenerateNoise(const Quantum, const NoiseType)
     * }
     */
    public static MemorySegment GenerateNoise$address() {
        return GenerateNoise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Quantum GenerateNoise(const Quantum, const NoiseType)
     * }
     */
    public static short GenerateNoise(short x0, int x1) {
        var mh$ = GenerateNoise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenerateNoise", x0, x1);
            }
            return (short)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Contrast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("Contrast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void Contrast(const int, Quantum *, Quantum *, Quantum *)
     * }
     */
    public static FunctionDescriptor Contrast$descriptor() {
        return Contrast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void Contrast(const int, Quantum *, Quantum *, Quantum *)
     * }
     */
    public static MethodHandle Contrast$handle() {
        return Contrast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void Contrast(const int, Quantum *, Quantum *, Quantum *)
     * }
     */
    public static MemorySegment Contrast$address() {
        return Contrast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void Contrast(const int, Quantum *, Quantum *, Quantum *)
     * }
     */
    public static void Contrast(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Contrast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Contrast", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HSLTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("HSLTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void HSLTransform(const double, const double, const double, Quantum *, Quantum *, Quantum *)
     * }
     */
    public static FunctionDescriptor HSLTransform$descriptor() {
        return HSLTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void HSLTransform(const double, const double, const double, Quantum *, Quantum *, Quantum *)
     * }
     */
    public static MethodHandle HSLTransform$handle() {
        return HSLTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void HSLTransform(const double, const double, const double, Quantum *, Quantum *, Quantum *)
     * }
     */
    public static MemorySegment HSLTransform$address() {
        return HSLTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void HSLTransform(const double, const double, const double, Quantum *, Quantum *, Quantum *)
     * }
     */
    public static void HSLTransform(double x0, double x1, double x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = HSLTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HSLTransform", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HWBTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("HWBTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void HWBTransform(const double, const double, const double, Quantum *, Quantum *, Quantum *)
     * }
     */
    public static FunctionDescriptor HWBTransform$descriptor() {
        return HWBTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void HWBTransform(const double, const double, const double, Quantum *, Quantum *, Quantum *)
     * }
     */
    public static MethodHandle HWBTransform$handle() {
        return HWBTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void HWBTransform(const double, const double, const double, Quantum *, Quantum *, Quantum *)
     * }
     */
    public static MemorySegment HWBTransform$address() {
        return HWBTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void HWBTransform(const double, const double, const double, Quantum *, Quantum *, Quantum *)
     * }
     */
    public static void HWBTransform(double x0, double x1, double x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = HWBTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HWBTransform", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Hull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("Hull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void Hull(const long, const long, const unsigned long, const unsigned long, Quantum *, Quantum *, const int)
     * }
     */
    public static FunctionDescriptor Hull$descriptor() {
        return Hull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void Hull(const long, const long, const unsigned long, const unsigned long, Quantum *, Quantum *, const int)
     * }
     */
    public static MethodHandle Hull$handle() {
        return Hull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void Hull(const long, const long, const unsigned long, const unsigned long, Quantum *, Quantum *, const int)
     * }
     */
    public static MemorySegment Hull$address() {
        return Hull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void Hull(const long, const long, const unsigned long, const unsigned long, Quantum *, Quantum *, const int)
     * }
     */
    public static void Hull(long x0, long x1, long x2, long x3, MemorySegment x4, MemorySegment x5, int x6) {
        var mh$ = Hull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Hull", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IdentityAffine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IdentityAffine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void IdentityAffine(AffineMatrix *)
     * }
     */
    public static FunctionDescriptor IdentityAffine$descriptor() {
        return IdentityAffine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void IdentityAffine(AffineMatrix *)
     * }
     */
    public static MethodHandle IdentityAffine$handle() {
        return IdentityAffine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void IdentityAffine(AffineMatrix *)
     * }
     */
    public static MemorySegment IdentityAffine$address() {
        return IdentityAffine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void IdentityAffine(AffineMatrix *)
     * }
     */
    public static void IdentityAffine(MemorySegment x0) {
        var mh$ = IdentityAffine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IdentityAffine", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Modulate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("Modulate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void Modulate(const double, const double, const double, Quantum *, Quantum *, Quantum *)
     * }
     */
    public static FunctionDescriptor Modulate$descriptor() {
        return Modulate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void Modulate(const double, const double, const double, Quantum *, Quantum *, Quantum *)
     * }
     */
    public static MethodHandle Modulate$handle() {
        return Modulate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void Modulate(const double, const double, const double, Quantum *, Quantum *, Quantum *)
     * }
     */
    public static MemorySegment Modulate$address() {
        return Modulate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void Modulate(const double, const double, const double, Quantum *, Quantum *, Quantum *)
     * }
     */
    public static void Modulate(double x0, double x1, double x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Modulate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Modulate", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransformHSL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_SHORT,
            magick_wand_h.C_SHORT,
            magick_wand_h.C_SHORT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("TransformHSL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TransformHSL(const Quantum, const Quantum, const Quantum, double *, double *, double *)
     * }
     */
    public static FunctionDescriptor TransformHSL$descriptor() {
        return TransformHSL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TransformHSL(const Quantum, const Quantum, const Quantum, double *, double *, double *)
     * }
     */
    public static MethodHandle TransformHSL$handle() {
        return TransformHSL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TransformHSL(const Quantum, const Quantum, const Quantum, double *, double *, double *)
     * }
     */
    public static MemorySegment TransformHSL$address() {
        return TransformHSL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TransformHSL(const Quantum, const Quantum, const Quantum, double *, double *, double *)
     * }
     */
    public static void TransformHSL(short x0, short x1, short x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TransformHSL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransformHSL", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransformHWB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_SHORT,
            magick_wand_h.C_SHORT,
            magick_wand_h.C_SHORT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("TransformHWB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TransformHWB(const Quantum, const Quantum, const Quantum, double *, double *, double *)
     * }
     */
    public static FunctionDescriptor TransformHWB$descriptor() {
        return TransformHWB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TransformHWB(const Quantum, const Quantum, const Quantum, double *, double *, double *)
     * }
     */
    public static MethodHandle TransformHWB$handle() {
        return TransformHWB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TransformHWB(const Quantum, const Quantum, const Quantum, double *, double *, double *)
     * }
     */
    public static MemorySegment TransformHWB$address() {
        return TransformHWB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TransformHWB(const Quantum, const Quantum, const Quantum, double *, double *, double *)
     * }
     */
    public static void TransformHWB(short x0, short x1, short x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TransformHWB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransformHWB", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GradientImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GradientImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int GradientImage(Image *, const PixelPacket *, const PixelPacket *)
     * }
     */
    public static FunctionDescriptor GradientImage$descriptor() {
        return GradientImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int GradientImage(Image *, const PixelPacket *, const PixelPacket *)
     * }
     */
    public static MethodHandle GradientImage$handle() {
        return GradientImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int GradientImage(Image *, const PixelPacket *, const PixelPacket *)
     * }
     */
    public static MemorySegment GradientImage$address() {
        return GradientImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int GradientImage(Image *, const PixelPacket *, const PixelPacket *)
     * }
     */
    public static int GradientImage(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = GradientImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GradientImage", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HaldClutImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("HaldClutImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int HaldClutImage(Image *, const Image *clut)
     * }
     */
    public static FunctionDescriptor HaldClutImage$descriptor() {
        return HaldClutImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int HaldClutImage(Image *, const Image *clut)
     * }
     */
    public static MethodHandle HaldClutImage$handle() {
        return HaldClutImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int HaldClutImage(Image *, const Image *clut)
     * }
     */
    public static MemorySegment HaldClutImage$address() {
        return HaldClutImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int HaldClutImage(Image *, const Image *clut)
     * }
     */
    public static int HaldClutImage(MemorySegment x0, MemorySegment clut) {
        var mh$ = HaldClutImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HaldClutImage", x0, clut);
            }
            return (int)mh$.invokeExact(x0, clut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloneImageList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CloneImageList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *CloneImageList(const Image *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor CloneImageList$descriptor() {
        return CloneImageList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *CloneImageList(const Image *, ExceptionInfo *)
     * }
     */
    public static MethodHandle CloneImageList$handle() {
        return CloneImageList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *CloneImageList(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment CloneImageList$address() {
        return CloneImageList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *CloneImageList(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment CloneImageList(MemorySegment x0, MemorySegment x1) {
        var mh$ = CloneImageList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloneImageList", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFirstImageInList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetFirstImageInList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *GetFirstImageInList(const Image *)
     * }
     */
    public static FunctionDescriptor GetFirstImageInList$descriptor() {
        return GetFirstImageInList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *GetFirstImageInList(const Image *)
     * }
     */
    public static MethodHandle GetFirstImageInList$handle() {
        return GetFirstImageInList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *GetFirstImageInList(const Image *)
     * }
     */
    public static MemorySegment GetFirstImageInList$address() {
        return GetFirstImageInList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *GetFirstImageInList(const Image *)
     * }
     */
    public static MemorySegment GetFirstImageInList(MemorySegment x0) {
        var mh$ = GetFirstImageInList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFirstImageInList", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageFromList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageFromList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *GetImageFromList(const Image *, const long)
     * }
     */
    public static FunctionDescriptor GetImageFromList$descriptor() {
        return GetImageFromList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *GetImageFromList(const Image *, const long)
     * }
     */
    public static MethodHandle GetImageFromList$handle() {
        return GetImageFromList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *GetImageFromList(const Image *, const long)
     * }
     */
    public static MemorySegment GetImageFromList$address() {
        return GetImageFromList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *GetImageFromList(const Image *, const long)
     * }
     */
    public static MemorySegment GetImageFromList(MemorySegment x0, long x1) {
        var mh$ = GetImageFromList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageFromList", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLastImageInList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetLastImageInList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *GetLastImageInList(const Image *)
     * }
     */
    public static FunctionDescriptor GetLastImageInList$descriptor() {
        return GetLastImageInList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *GetLastImageInList(const Image *)
     * }
     */
    public static MethodHandle GetLastImageInList$handle() {
        return GetLastImageInList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *GetLastImageInList(const Image *)
     * }
     */
    public static MemorySegment GetLastImageInList$address() {
        return GetLastImageInList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *GetLastImageInList(const Image *)
     * }
     */
    public static MemorySegment GetLastImageInList(MemorySegment x0) {
        var mh$ = GetLastImageInList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLastImageInList", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNextImageInList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetNextImageInList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *GetNextImageInList(const Image *)
     * }
     */
    public static FunctionDescriptor GetNextImageInList$descriptor() {
        return GetNextImageInList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *GetNextImageInList(const Image *)
     * }
     */
    public static MethodHandle GetNextImageInList$handle() {
        return GetNextImageInList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *GetNextImageInList(const Image *)
     * }
     */
    public static MemorySegment GetNextImageInList$address() {
        return GetNextImageInList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *GetNextImageInList(const Image *)
     * }
     */
    public static MemorySegment GetNextImageInList(MemorySegment x0) {
        var mh$ = GetNextImageInList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNextImageInList", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPreviousImageInList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetPreviousImageInList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *GetPreviousImageInList(const Image *)
     * }
     */
    public static FunctionDescriptor GetPreviousImageInList$descriptor() {
        return GetPreviousImageInList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *GetPreviousImageInList(const Image *)
     * }
     */
    public static MethodHandle GetPreviousImageInList$handle() {
        return GetPreviousImageInList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *GetPreviousImageInList(const Image *)
     * }
     */
    public static MemorySegment GetPreviousImageInList$address() {
        return GetPreviousImageInList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *GetPreviousImageInList(const Image *)
     * }
     */
    public static MemorySegment GetPreviousImageInList(MemorySegment x0) {
        var mh$ = GetPreviousImageInList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPreviousImageInList", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImageListToArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ImageListToArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image **ImageListToArray(const Image *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor ImageListToArray$descriptor() {
        return ImageListToArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image **ImageListToArray(const Image *, ExceptionInfo *)
     * }
     */
    public static MethodHandle ImageListToArray$handle() {
        return ImageListToArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image **ImageListToArray(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment ImageListToArray$address() {
        return ImageListToArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image **ImageListToArray(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment ImageListToArray(MemorySegment x0, MemorySegment x1) {
        var mh$ = ImageListToArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImageListToArray", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NewImageList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("NewImageList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *NewImageList()
     * }
     */
    public static FunctionDescriptor NewImageList$descriptor() {
        return NewImageList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *NewImageList()
     * }
     */
    public static MethodHandle NewImageList$handle() {
        return NewImageList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *NewImageList()
     * }
     */
    public static MemorySegment NewImageList$address() {
        return NewImageList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *NewImageList()
     * }
     */
    public static MemorySegment NewImageList() {
        var mh$ = NewImageList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NewImageList");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveLastImageFromList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("RemoveLastImageFromList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *RemoveLastImageFromList(Image **)
     * }
     */
    public static FunctionDescriptor RemoveLastImageFromList$descriptor() {
        return RemoveLastImageFromList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *RemoveLastImageFromList(Image **)
     * }
     */
    public static MethodHandle RemoveLastImageFromList$handle() {
        return RemoveLastImageFromList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *RemoveLastImageFromList(Image **)
     * }
     */
    public static MemorySegment RemoveLastImageFromList$address() {
        return RemoveLastImageFromList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *RemoveLastImageFromList(Image **)
     * }
     */
    public static MemorySegment RemoveLastImageFromList(MemorySegment x0) {
        var mh$ = RemoveLastImageFromList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveLastImageFromList", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFirstImageFromList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("RemoveFirstImageFromList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *RemoveFirstImageFromList(Image **)
     * }
     */
    public static FunctionDescriptor RemoveFirstImageFromList$descriptor() {
        return RemoveFirstImageFromList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *RemoveFirstImageFromList(Image **)
     * }
     */
    public static MethodHandle RemoveFirstImageFromList$handle() {
        return RemoveFirstImageFromList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *RemoveFirstImageFromList(Image **)
     * }
     */
    public static MemorySegment RemoveFirstImageFromList$address() {
        return RemoveFirstImageFromList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *RemoveFirstImageFromList(Image **)
     * }
     */
    public static MemorySegment RemoveFirstImageFromList(MemorySegment x0) {
        var mh$ = RemoveFirstImageFromList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFirstImageFromList", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SplitImageList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SplitImageList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *SplitImageList(Image *)
     * }
     */
    public static FunctionDescriptor SplitImageList$descriptor() {
        return SplitImageList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *SplitImageList(Image *)
     * }
     */
    public static MethodHandle SplitImageList$handle() {
        return SplitImageList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *SplitImageList(Image *)
     * }
     */
    public static MemorySegment SplitImageList$address() {
        return SplitImageList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *SplitImageList(Image *)
     * }
     */
    public static MemorySegment SplitImageList(MemorySegment x0) {
        var mh$ = SplitImageList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SplitImageList", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SyncNextImageInList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SyncNextImageInList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *SyncNextImageInList(const Image *)
     * }
     */
    public static FunctionDescriptor SyncNextImageInList$descriptor() {
        return SyncNextImageInList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *SyncNextImageInList(const Image *)
     * }
     */
    public static MethodHandle SyncNextImageInList$handle() {
        return SyncNextImageInList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *SyncNextImageInList(const Image *)
     * }
     */
    public static MemorySegment SyncNextImageInList$address() {
        return SyncNextImageInList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *SyncNextImageInList(const Image *)
     * }
     */
    public static MemorySegment SyncNextImageInList(MemorySegment x0) {
        var mh$ = SyncNextImageInList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SyncNextImageInList", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageIndexInList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageIndexInList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long GetImageIndexInList(const Image *)
     * }
     */
    public static FunctionDescriptor GetImageIndexInList$descriptor() {
        return GetImageIndexInList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long GetImageIndexInList(const Image *)
     * }
     */
    public static MethodHandle GetImageIndexInList$handle() {
        return GetImageIndexInList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long GetImageIndexInList(const Image *)
     * }
     */
    public static MemorySegment GetImageIndexInList$address() {
        return GetImageIndexInList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long GetImageIndexInList(const Image *)
     * }
     */
    public static long GetImageIndexInList(MemorySegment x0) {
        var mh$ = GetImageIndexInList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageIndexInList", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageListLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageListLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long GetImageListLength(const Image *)
     * }
     */
    public static FunctionDescriptor GetImageListLength$descriptor() {
        return GetImageListLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long GetImageListLength(const Image *)
     * }
     */
    public static MethodHandle GetImageListLength$handle() {
        return GetImageListLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long GetImageListLength(const Image *)
     * }
     */
    public static MemorySegment GetImageListLength$address() {
        return GetImageListLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long GetImageListLength(const Image *)
     * }
     */
    public static long GetImageListLength(MemorySegment x0) {
        var mh$ = GetImageListLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageListLength", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AppendImageToList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AppendImageToList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void AppendImageToList(Image **, Image *)
     * }
     */
    public static FunctionDescriptor AppendImageToList$descriptor() {
        return AppendImageToList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void AppendImageToList(Image **, Image *)
     * }
     */
    public static MethodHandle AppendImageToList$handle() {
        return AppendImageToList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void AppendImageToList(Image **, Image *)
     * }
     */
    public static MemorySegment AppendImageToList$address() {
        return AppendImageToList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void AppendImageToList(Image **, Image *)
     * }
     */
    public static void AppendImageToList(MemorySegment x0, MemorySegment x1) {
        var mh$ = AppendImageToList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AppendImageToList", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteImageFromList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DeleteImageFromList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DeleteImageFromList(Image **)
     * }
     */
    public static FunctionDescriptor DeleteImageFromList$descriptor() {
        return DeleteImageFromList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DeleteImageFromList(Image **)
     * }
     */
    public static MethodHandle DeleteImageFromList$handle() {
        return DeleteImageFromList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DeleteImageFromList(Image **)
     * }
     */
    public static MemorySegment DeleteImageFromList$address() {
        return DeleteImageFromList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DeleteImageFromList(Image **)
     * }
     */
    public static void DeleteImageFromList(MemorySegment x0) {
        var mh$ = DeleteImageFromList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteImageFromList", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyImageList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DestroyImageList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DestroyImageList(Image *)
     * }
     */
    public static FunctionDescriptor DestroyImageList$descriptor() {
        return DestroyImageList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DestroyImageList(Image *)
     * }
     */
    public static MethodHandle DestroyImageList$handle() {
        return DestroyImageList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DestroyImageList(Image *)
     * }
     */
    public static MemorySegment DestroyImageList$address() {
        return DestroyImageList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DestroyImageList(Image *)
     * }
     */
    public static void DestroyImageList(MemorySegment x0) {
        var mh$ = DestroyImageList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyImageList", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InsertImageInList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("InsertImageInList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void InsertImageInList(Image **, Image *)
     * }
     */
    public static FunctionDescriptor InsertImageInList$descriptor() {
        return InsertImageInList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void InsertImageInList(Image **, Image *)
     * }
     */
    public static MethodHandle InsertImageInList$handle() {
        return InsertImageInList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void InsertImageInList(Image **, Image *)
     * }
     */
    public static MemorySegment InsertImageInList$address() {
        return InsertImageInList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void InsertImageInList(Image **, Image *)
     * }
     */
    public static void InsertImageInList(MemorySegment x0, MemorySegment x1) {
        var mh$ = InsertImageInList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InsertImageInList", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrependImageToList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PrependImageToList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PrependImageToList(Image **, Image *)
     * }
     */
    public static FunctionDescriptor PrependImageToList$descriptor() {
        return PrependImageToList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PrependImageToList(Image **, Image *)
     * }
     */
    public static MethodHandle PrependImageToList$handle() {
        return PrependImageToList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PrependImageToList(Image **, Image *)
     * }
     */
    public static MemorySegment PrependImageToList$address() {
        return PrependImageToList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PrependImageToList(Image **, Image *)
     * }
     */
    public static void PrependImageToList(MemorySegment x0, MemorySegment x1) {
        var mh$ = PrependImageToList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrependImageToList", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplaceImageInList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReplaceImageInList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ReplaceImageInList(Image **images, Image *image)
     * }
     */
    public static FunctionDescriptor ReplaceImageInList$descriptor() {
        return ReplaceImageInList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ReplaceImageInList(Image **images, Image *image)
     * }
     */
    public static MethodHandle ReplaceImageInList$handle() {
        return ReplaceImageInList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ReplaceImageInList(Image **images, Image *image)
     * }
     */
    public static MemorySegment ReplaceImageInList$address() {
        return ReplaceImageInList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ReplaceImageInList(Image **images, Image *image)
     * }
     */
    public static void ReplaceImageInList(MemorySegment images, MemorySegment image) {
        var mh$ = ReplaceImageInList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplaceImageInList", images, image);
            }
            mh$.invokeExact(images, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReverseImageList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ReverseImageList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ReverseImageList(Image **)
     * }
     */
    public static FunctionDescriptor ReverseImageList$descriptor() {
        return ReverseImageList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ReverseImageList(Image **)
     * }
     */
    public static MethodHandle ReverseImageList$handle() {
        return ReverseImageList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ReverseImageList(Image **)
     * }
     */
    public static MemorySegment ReverseImageList$address() {
        return ReverseImageList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ReverseImageList(Image **)
     * }
     */
    public static void ReverseImageList(MemorySegment x0) {
        var mh$ = ReverseImageList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReverseImageList", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpliceImageIntoList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SpliceImageIntoList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void SpliceImageIntoList(Image **, const unsigned long, Image *)
     * }
     */
    public static FunctionDescriptor SpliceImageIntoList$descriptor() {
        return SpliceImageIntoList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void SpliceImageIntoList(Image **, const unsigned long, Image *)
     * }
     */
    public static MethodHandle SpliceImageIntoList$handle() {
        return SpliceImageIntoList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void SpliceImageIntoList(Image **, const unsigned long, Image *)
     * }
     */
    public static MemorySegment SpliceImageIntoList$address() {
        return SpliceImageIntoList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void SpliceImageIntoList(Image **, const unsigned long, Image *)
     * }
     */
    public static void SpliceImageIntoList(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = SpliceImageIntoList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpliceImageIntoList", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMagickFileFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetMagickFileFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int GetMagickFileFormat(const unsigned char *header, const size_t header_length, char *format, const size_t format_length, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetMagickFileFormat$descriptor() {
        return GetMagickFileFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int GetMagickFileFormat(const unsigned char *header, const size_t header_length, char *format, const size_t format_length, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetMagickFileFormat$handle() {
        return GetMagickFileFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int GetMagickFileFormat(const unsigned char *header, const size_t header_length, char *format, const size_t format_length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetMagickFileFormat$address() {
        return GetMagickFileFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int GetMagickFileFormat(const unsigned char *header, const size_t header_length, char *format, const size_t format_length, ExceptionInfo *exception)
     * }
     */
    public static int GetMagickFileFormat(MemorySegment header, long header_length, MemorySegment format, long format_length, MemorySegment exception) {
        var mh$ = GetMagickFileFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMagickFileFormat", header, header_length, format, format_length, exception);
            }
            return (int)mh$.invokeExact(header, header_length, format, format_length, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ListMagicInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ListMagicInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ListMagicInfo(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ListMagicInfo$descriptor() {
        return ListMagicInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ListMagicInfo(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ListMagicInfo$handle() {
        return ListMagicInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ListMagicInfo(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ListMagicInfo$address() {
        return ListMagicInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ListMagicInfo(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static int ListMagicInfo(MemorySegment file, MemorySegment exception) {
        var mh$ = ListMagicInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ListMagicInfo", file, exception);
            }
            return (int)mh$.invokeExact(file, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int BrokenCoderClass = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BrokenCoderClass = -1
     * }
     */
    public static int BrokenCoderClass() {
        return BrokenCoderClass;
    }
    private static final int UnstableCoderClass = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UnstableCoderClass = 0
     * }
     */
    public static int UnstableCoderClass() {
        return UnstableCoderClass;
    }
    private static final int StableCoderClass = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.StableCoderClass = 1
     * }
     */
    public static int StableCoderClass() {
        return StableCoderClass;
    }
    private static final int PrimaryCoderClass = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PrimaryCoderClass = 2
     * }
     */
    public static int PrimaryCoderClass() {
        return PrimaryCoderClass;
    }
    private static final int HintExtensionTreatment = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HintExtensionTreatment = 0
     * }
     */
    public static int HintExtensionTreatment() {
        return HintExtensionTreatment;
    }
    private static final int ObeyExtensionTreatment = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ObeyExtensionTreatment = 1
     * }
     */
    public static int ObeyExtensionTreatment() {
        return ObeyExtensionTreatment;
    }
    private static final int IgnoreExtensionTreatment = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IgnoreExtensionTreatment = 2
     * }
     */
    public static int IgnoreExtensionTreatment() {
        return IgnoreExtensionTreatment;
    }

    private static class MagickToMime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickToMime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *MagickToMime(const char *magick)
     * }
     */
    public static FunctionDescriptor MagickToMime$descriptor() {
        return MagickToMime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *MagickToMime(const char *magick)
     * }
     */
    public static MethodHandle MagickToMime$handle() {
        return MagickToMime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *MagickToMime(const char *magick)
     * }
     */
    public static MemorySegment MagickToMime$address() {
        return MagickToMime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *MagickToMime(const char *magick)
     * }
     */
    public static MemorySegment MagickToMime(MemorySegment magick) {
        var mh$ = MagickToMime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickToMime", magick);
            }
            return (MemorySegment)mh$.invokeExact(magick);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageMagick {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageMagick");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *GetImageMagick(const unsigned char *magick, const size_t length)
     * }
     */
    public static FunctionDescriptor GetImageMagick$descriptor() {
        return GetImageMagick.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *GetImageMagick(const unsigned char *magick, const size_t length)
     * }
     */
    public static MethodHandle GetImageMagick$handle() {
        return GetImageMagick.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *GetImageMagick(const unsigned char *magick, const size_t length)
     * }
     */
    public static MemorySegment GetImageMagick$address() {
        return GetImageMagick.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *GetImageMagick(const unsigned char *magick, const size_t length)
     * }
     */
    public static MemorySegment GetImageMagick(MemorySegment magick, long length) {
        var mh$ = GetImageMagick.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageMagick", magick, length);
            }
            return (MemorySegment)mh$.invokeExact(magick, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMagickConflict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IsMagickConflict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IsMagickConflict(const char *magick)
     * }
     */
    public static FunctionDescriptor IsMagickConflict$descriptor() {
        return IsMagickConflict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IsMagickConflict(const char *magick)
     * }
     */
    public static MethodHandle IsMagickConflict$handle() {
        return IsMagickConflict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IsMagickConflict(const char *magick)
     * }
     */
    public static MemorySegment IsMagickConflict$address() {
        return IsMagickConflict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IsMagickConflict(const char *magick)
     * }
     */
    public static int IsMagickConflict(MemorySegment magick) {
        var mh$ = IsMagickConflict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMagickConflict", magick);
            }
            return (int)mh$.invokeExact(magick);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ListModuleMap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ListModuleMap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ListModuleMap(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ListModuleMap$descriptor() {
        return ListModuleMap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ListModuleMap(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ListModuleMap$handle() {
        return ListModuleMap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ListModuleMap(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ListModuleMap$address() {
        return ListModuleMap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ListModuleMap(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static int ListModuleMap(MemorySegment file, MemorySegment exception) {
        var mh$ = ListModuleMap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ListModuleMap", file, exception);
            }
            return (int)mh$.invokeExact(file, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ListMagickInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ListMagickInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ListMagickInfo(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ListMagickInfo$descriptor() {
        return ListMagickInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ListMagickInfo(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ListMagickInfo$handle() {
        return ListMagickInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ListMagickInfo(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ListMagickInfo$address() {
        return ListMagickInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ListMagickInfo(FILE *file, ExceptionInfo *exception)
     * }
     */
    public static int ListMagickInfo(MemorySegment file, MemorySegment exception) {
        var mh$ = ListMagickInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ListMagickInfo", file, exception);
            }
            return (int)mh$.invokeExact(file, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeMagickEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("InitializeMagickEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int InitializeMagickEx(const char *path, unsigned int options, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor InitializeMagickEx$descriptor() {
        return InitializeMagickEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int InitializeMagickEx(const char *path, unsigned int options, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle InitializeMagickEx$handle() {
        return InitializeMagickEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int InitializeMagickEx(const char *path, unsigned int options, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment InitializeMagickEx$address() {
        return InitializeMagickEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int InitializeMagickEx(const char *path, unsigned int options, ExceptionInfo *exception)
     * }
     */
    public static int InitializeMagickEx(MemorySegment path, int options, MemorySegment exception) {
        var mh$ = InitializeMagickEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeMagickEx", path, options, exception);
            }
            return (int)mh$.invokeExact(path, options, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterMagickInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("UnregisterMagickInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int UnregisterMagickInfo(const char *name)
     * }
     */
    public static FunctionDescriptor UnregisterMagickInfo$descriptor() {
        return UnregisterMagickInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int UnregisterMagickInfo(const char *name)
     * }
     */
    public static MethodHandle UnregisterMagickInfo$handle() {
        return UnregisterMagickInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int UnregisterMagickInfo(const char *name)
     * }
     */
    public static MemorySegment UnregisterMagickInfo$address() {
        return UnregisterMagickInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int UnregisterMagickInfo(const char *name)
     * }
     */
    public static int UnregisterMagickInfo(MemorySegment name) {
        var mh$ = UnregisterMagickInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterMagickInfo", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyMagick {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DestroyMagick");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DestroyMagick()
     * }
     */
    public static FunctionDescriptor DestroyMagick$descriptor() {
        return DestroyMagick.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DestroyMagick()
     * }
     */
    public static MethodHandle DestroyMagick$handle() {
        return DestroyMagick.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DestroyMagick()
     * }
     */
    public static MemorySegment DestroyMagick$address() {
        return DestroyMagick.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DestroyMagick()
     * }
     */
    public static void DestroyMagick() {
        var mh$ = DestroyMagick.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyMagick");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeMagick {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("InitializeMagick");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void InitializeMagick(const char *path)
     * }
     */
    public static FunctionDescriptor InitializeMagick$descriptor() {
        return InitializeMagick.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void InitializeMagick(const char *path)
     * }
     */
    public static MethodHandle InitializeMagick$handle() {
        return InitializeMagick.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void InitializeMagick(const char *path)
     * }
     */
    public static MemorySegment InitializeMagick$address() {
        return InitializeMagick.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void InitializeMagick(const char *path)
     * }
     */
    public static void InitializeMagick(MemorySegment path) {
        var mh$ = InitializeMagick.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeMagick", path);
            }
            mh$.invokeExact(path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PanicDestroyMagick {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PanicDestroyMagick");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PanicDestroyMagick()
     * }
     */
    public static FunctionDescriptor PanicDestroyMagick$descriptor() {
        return PanicDestroyMagick.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PanicDestroyMagick()
     * }
     */
    public static MethodHandle PanicDestroyMagick$handle() {
        return PanicDestroyMagick.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PanicDestroyMagick()
     * }
     */
    public static MemorySegment PanicDestroyMagick$address() {
        return PanicDestroyMagick.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PanicDestroyMagick()
     * }
     */
    public static void PanicDestroyMagick() {
        var mh$ = PanicDestroyMagick.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PanicDestroyMagick");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMagickInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetMagickInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const MagickInfo *GetMagickInfo(const char *name, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetMagickInfo$descriptor() {
        return GetMagickInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const MagickInfo *GetMagickInfo(const char *name, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetMagickInfo$handle() {
        return GetMagickInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const MagickInfo *GetMagickInfo(const char *name, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetMagickInfo$address() {
        return GetMagickInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const MagickInfo *GetMagickInfo(const char *name, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetMagickInfo(MemorySegment name, MemorySegment exception) {
        var mh$ = GetMagickInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMagickInfo", name, exception);
            }
            return (MemorySegment)mh$.invokeExact(name, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMagickInfoArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetMagickInfoArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern MagickInfo **GetMagickInfoArray(ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetMagickInfoArray$descriptor() {
        return GetMagickInfoArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern MagickInfo **GetMagickInfoArray(ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetMagickInfoArray$handle() {
        return GetMagickInfoArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern MagickInfo **GetMagickInfoArray(ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetMagickInfoArray$address() {
        return GetMagickInfoArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern MagickInfo **GetMagickInfoArray(ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetMagickInfoArray(MemorySegment exception) {
        var mh$ = GetMagickInfoArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMagickInfoArray", exception);
            }
            return (MemorySegment)mh$.invokeExact(exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterMagickInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("RegisterMagickInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern MagickInfo *RegisterMagickInfo(MagickInfo *magick_info)
     * }
     */
    public static FunctionDescriptor RegisterMagickInfo$descriptor() {
        return RegisterMagickInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern MagickInfo *RegisterMagickInfo(MagickInfo *magick_info)
     * }
     */
    public static MethodHandle RegisterMagickInfo$handle() {
        return RegisterMagickInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern MagickInfo *RegisterMagickInfo(MagickInfo *magick_info)
     * }
     */
    public static MemorySegment RegisterMagickInfo$address() {
        return RegisterMagickInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern MagickInfo *RegisterMagickInfo(MagickInfo *magick_info)
     * }
     */
    public static MemorySegment RegisterMagickInfo(MemorySegment magick_info) {
        var mh$ = RegisterMagickInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterMagickInfo", magick_info);
            }
            return (MemorySegment)mh$.invokeExact(magick_info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMagickInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetMagickInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern MagickInfo *SetMagickInfo(const char *name)
     * }
     */
    public static FunctionDescriptor SetMagickInfo$descriptor() {
        return SetMagickInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern MagickInfo *SetMagickInfo(const char *name)
     * }
     */
    public static MethodHandle SetMagickInfo$handle() {
        return SetMagickInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern MagickInfo *SetMagickInfo(const char *name)
     * }
     */
    public static MemorySegment SetMagickInfo$address() {
        return SetMagickInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern MagickInfo *SetMagickInfo(const char *name)
     * }
     */
    public static MemorySegment SetMagickInfo(MemorySegment name) {
        var mh$ = SetMagickInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMagickInfo", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickAllocFunctions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickAllocFunctions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickAllocFunctions(MagickFreeFunc free_func, MagickMallocFunc malloc_func, MagickReallocFunc realloc_func)
     * }
     */
    public static FunctionDescriptor MagickAllocFunctions$descriptor() {
        return MagickAllocFunctions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickAllocFunctions(MagickFreeFunc free_func, MagickMallocFunc malloc_func, MagickReallocFunc realloc_func)
     * }
     */
    public static MethodHandle MagickAllocFunctions$handle() {
        return MagickAllocFunctions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickAllocFunctions(MagickFreeFunc free_func, MagickMallocFunc malloc_func, MagickReallocFunc realloc_func)
     * }
     */
    public static MemorySegment MagickAllocFunctions$address() {
        return MagickAllocFunctions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickAllocFunctions(MagickFreeFunc free_func, MagickMallocFunc malloc_func, MagickReallocFunc realloc_func)
     * }
     */
    public static void MagickAllocFunctions(MemorySegment free_func, MemorySegment malloc_func, MemorySegment realloc_func) {
        var mh$ = MagickAllocFunctions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickAllocFunctions", free_func, malloc_func, realloc_func);
            }
            mh$.invokeExact(free_func, malloc_func, realloc_func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickCloneMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickCloneMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *MagickCloneMemory(void *destination, const void *source, const size_t size)
     * }
     */
    public static FunctionDescriptor MagickCloneMemory$descriptor() {
        return MagickCloneMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *MagickCloneMemory(void *destination, const void *source, const size_t size)
     * }
     */
    public static MethodHandle MagickCloneMemory$handle() {
        return MagickCloneMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *MagickCloneMemory(void *destination, const void *source, const size_t size)
     * }
     */
    public static MemorySegment MagickCloneMemory$address() {
        return MagickCloneMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *MagickCloneMemory(void *destination, const void *source, const size_t size)
     * }
     */
    public static MemorySegment MagickCloneMemory(MemorySegment destination, MemorySegment source, long size) {
        var mh$ = MagickCloneMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickCloneMemory", destination, source, size);
            }
            return (MemorySegment)mh$.invokeExact(destination, source, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickFree(void *memory)
     * }
     */
    public static FunctionDescriptor MagickFree$descriptor() {
        return MagickFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickFree(void *memory)
     * }
     */
    public static MethodHandle MagickFree$handle() {
        return MagickFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickFree(void *memory)
     * }
     */
    public static MemorySegment MagickFree$address() {
        return MagickFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickFree(void *memory)
     * }
     */
    public static void MagickFree(MemorySegment memory) {
        var mh$ = MagickFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickFree", memory);
            }
            mh$.invokeExact(memory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickFreeAligned {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickFreeAligned");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickFreeAligned(void *memory)
     * }
     */
    public static FunctionDescriptor MagickFreeAligned$descriptor() {
        return MagickFreeAligned.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickFreeAligned(void *memory)
     * }
     */
    public static MethodHandle MagickFreeAligned$handle() {
        return MagickFreeAligned.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickFreeAligned(void *memory)
     * }
     */
    public static MemorySegment MagickFreeAligned$address() {
        return MagickFreeAligned.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickFreeAligned(void *memory)
     * }
     */
    public static void MagickFreeAligned(MemorySegment memory) {
        var mh$ = MagickFreeAligned.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickFreeAligned", memory);
            }
            mh$.invokeExact(memory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickMalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickMalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *MagickMalloc(const size_t size)
     * }
     */
    public static FunctionDescriptor MagickMalloc$descriptor() {
        return MagickMalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *MagickMalloc(const size_t size)
     * }
     */
    public static MethodHandle MagickMalloc$handle() {
        return MagickMalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *MagickMalloc(const size_t size)
     * }
     */
    public static MemorySegment MagickMalloc$address() {
        return MagickMalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *MagickMalloc(const size_t size)
     * }
     */
    public static MemorySegment MagickMalloc(long size) {
        var mh$ = MagickMalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickMalloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickMallocAligned {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickMallocAligned");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *MagickMallocAligned(const size_t alignment, const size_t size)
     * }
     */
    public static FunctionDescriptor MagickMallocAligned$descriptor() {
        return MagickMallocAligned.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *MagickMallocAligned(const size_t alignment, const size_t size)
     * }
     */
    public static MethodHandle MagickMallocAligned$handle() {
        return MagickMallocAligned.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *MagickMallocAligned(const size_t alignment, const size_t size)
     * }
     */
    public static MemorySegment MagickMallocAligned$address() {
        return MagickMallocAligned.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *MagickMallocAligned(const size_t alignment, const size_t size)
     * }
     */
    public static MemorySegment MagickMallocAligned(long alignment, long size) {
        var mh$ = MagickMallocAligned.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickMallocAligned", alignment, size);
            }
            return (MemorySegment)mh$.invokeExact(alignment, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickMallocCleared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickMallocCleared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *MagickMallocCleared(const size_t size)
     * }
     */
    public static FunctionDescriptor MagickMallocCleared$descriptor() {
        return MagickMallocCleared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *MagickMallocCleared(const size_t size)
     * }
     */
    public static MethodHandle MagickMallocCleared$handle() {
        return MagickMallocCleared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *MagickMallocCleared(const size_t size)
     * }
     */
    public static MemorySegment MagickMallocCleared$address() {
        return MagickMallocCleared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *MagickMallocCleared(const size_t size)
     * }
     */
    public static MemorySegment MagickMallocCleared(long size) {
        var mh$ = MagickMallocCleared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickMallocCleared", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickRealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickRealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *MagickRealloc(void *memory, const size_t size)
     * }
     */
    public static FunctionDescriptor MagickRealloc$descriptor() {
        return MagickRealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *MagickRealloc(void *memory, const size_t size)
     * }
     */
    public static MethodHandle MagickRealloc$handle() {
        return MagickRealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *MagickRealloc(void *memory, const size_t size)
     * }
     */
    public static MemorySegment MagickRealloc$address() {
        return MagickRealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *MagickRealloc(void *memory, const size_t size)
     * }
     */
    public static MemorySegment MagickRealloc(MemorySegment memory, long size) {
        var mh$ = MagickRealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickRealloc", memory, size);
            }
            return (MemorySegment)mh$.invokeExact(memory, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickReallocStd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickReallocStd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *MagickReallocStd(void *memory, const size_t size)
     * }
     */
    public static FunctionDescriptor MagickReallocStd$descriptor() {
        return MagickReallocStd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *MagickReallocStd(void *memory, const size_t size)
     * }
     */
    public static MethodHandle MagickReallocStd$handle() {
        return MagickReallocStd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *MagickReallocStd(void *memory, const size_t size)
     * }
     */
    public static MemorySegment MagickReallocStd$address() {
        return MagickReallocStd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *MagickReallocStd(void *memory, const size_t size)
     * }
     */
    public static MemorySegment MagickReallocStd(MemorySegment memory, long size) {
        var mh$ = MagickReallocStd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickReallocStd", memory, size);
            }
            return (MemorySegment)mh$.invokeExact(memory, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExecuteModuleProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ExecuteModuleProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ExecuteModuleProcess(const char *tag, Image **image, const int argc, char **argv)
     * }
     */
    public static FunctionDescriptor ExecuteModuleProcess$descriptor() {
        return ExecuteModuleProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ExecuteModuleProcess(const char *tag, Image **image, const int argc, char **argv)
     * }
     */
    public static MethodHandle ExecuteModuleProcess$handle() {
        return ExecuteModuleProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ExecuteModuleProcess(const char *tag, Image **image, const int argc, char **argv)
     * }
     */
    public static MemorySegment ExecuteModuleProcess$address() {
        return ExecuteModuleProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ExecuteModuleProcess(const char *tag, Image **image, const int argc, char **argv)
     * }
     */
    public static int ExecuteModuleProcess(MemorySegment tag, MemorySegment image, int argc, MemorySegment argv) {
        var mh$ = ExecuteModuleProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExecuteModuleProcess", tag, image, argc, argv);
            }
            return (int)mh$.invokeExact(tag, image, argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMonitorHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetMonitorHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern MonitorHandler SetMonitorHandler(MonitorHandler handler)
     * }
     */
    public static FunctionDescriptor SetMonitorHandler$descriptor() {
        return SetMonitorHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern MonitorHandler SetMonitorHandler(MonitorHandler handler)
     * }
     */
    public static MethodHandle SetMonitorHandler$handle() {
        return SetMonitorHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern MonitorHandler SetMonitorHandler(MonitorHandler handler)
     * }
     */
    public static MemorySegment SetMonitorHandler$address() {
        return SetMonitorHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern MonitorHandler SetMonitorHandler(MonitorHandler handler)
     * }
     */
    public static MemorySegment SetMonitorHandler(MemorySegment handler) {
        var mh$ = SetMonitorHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMonitorHandler", handler);
            }
            return (MemorySegment)mh$.invokeExact(handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickMonitor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickMonitor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MagickMonitor(const char *text, const magick_int64_t quantum, const magick_uint64_t span, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor MagickMonitor$descriptor() {
        return MagickMonitor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MagickMonitor(const char *text, const magick_int64_t quantum, const magick_uint64_t span, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle MagickMonitor$handle() {
        return MagickMonitor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MagickMonitor(const char *text, const magick_int64_t quantum, const magick_uint64_t span, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment MagickMonitor$address() {
        return MagickMonitor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MagickMonitor(const char *text, const magick_int64_t quantum, const magick_uint64_t span, ExceptionInfo *exception)
     * }
     */
    public static int MagickMonitor(MemorySegment text, long quantum, long span, MemorySegment exception) {
        var mh$ = MagickMonitor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickMonitor", text, quantum, span, exception);
            }
            return (int)mh$.invokeExact(text, quantum, span, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern unsigned int MagickMonitorFormatted(const magick_int64_t quantum, const magick_uint64_t span, ExceptionInfo *exception, const char *format, ...)
     * }
     */
    public static class MagickMonitorFormatted {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                magick_wand_h.C_INT,
                magick_wand_h.C_LONG,
                magick_wand_h.C_LONG,
                magick_wand_h.C_POINTER,
                magick_wand_h.C_POINTER
            );
        private static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickMonitorFormatted");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private MagickMonitorFormatted(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern unsigned int MagickMonitorFormatted(const magick_int64_t quantum, const magick_uint64_t span, ExceptionInfo *exception, const char *format, ...)
         * }
         */
        public static MagickMonitorFormatted makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new MagickMonitorFormatted(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(long quantum, long span, MemorySegment exception, MemorySegment format, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("MagickMonitorFormatted", quantum, span, exception, format, x4);
                }
                return (int) spreader.invokeExact(quantum, span, exception, format, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class MontageImages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MontageImages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *MontageImages(const Image *, const MontageInfo *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor MontageImages$descriptor() {
        return MontageImages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *MontageImages(const Image *, const MontageInfo *, ExceptionInfo *)
     * }
     */
    public static MethodHandle MontageImages$handle() {
        return MontageImages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *MontageImages(const Image *, const MontageInfo *, ExceptionInfo *)
     * }
     */
    public static MemorySegment MontageImages$address() {
        return MontageImages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *MontageImages(const Image *, const MontageInfo *, ExceptionInfo *)
     * }
     */
    public static MemorySegment MontageImages(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = MontageImages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MontageImages", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloneMontageInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CloneMontageInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern MontageInfo *CloneMontageInfo(const ImageInfo *, const MontageInfo *)
     * }
     */
    public static FunctionDescriptor CloneMontageInfo$descriptor() {
        return CloneMontageInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern MontageInfo *CloneMontageInfo(const ImageInfo *, const MontageInfo *)
     * }
     */
    public static MethodHandle CloneMontageInfo$handle() {
        return CloneMontageInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern MontageInfo *CloneMontageInfo(const ImageInfo *, const MontageInfo *)
     * }
     */
    public static MemorySegment CloneMontageInfo$address() {
        return CloneMontageInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern MontageInfo *CloneMontageInfo(const ImageInfo *, const MontageInfo *)
     * }
     */
    public static MemorySegment CloneMontageInfo(MemorySegment x0, MemorySegment x1) {
        var mh$ = CloneMontageInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloneMontageInfo", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyMontageInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DestroyMontageInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DestroyMontageInfo(MontageInfo *)
     * }
     */
    public static FunctionDescriptor DestroyMontageInfo$descriptor() {
        return DestroyMontageInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DestroyMontageInfo(MontageInfo *)
     * }
     */
    public static MethodHandle DestroyMontageInfo$handle() {
        return DestroyMontageInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DestroyMontageInfo(MontageInfo *)
     * }
     */
    public static MemorySegment DestroyMontageInfo$address() {
        return DestroyMontageInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DestroyMontageInfo(MontageInfo *)
     * }
     */
    public static void DestroyMontageInfo(MemorySegment x0) {
        var mh$ = DestroyMontageInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyMontageInfo", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMontageInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetMontageInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void GetMontageInfo(const ImageInfo *, MontageInfo *)
     * }
     */
    public static FunctionDescriptor GetMontageInfo$descriptor() {
        return GetMontageInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void GetMontageInfo(const ImageInfo *, MontageInfo *)
     * }
     */
    public static MethodHandle GetMontageInfo$handle() {
        return GetMontageInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void GetMontageInfo(const ImageInfo *, MontageInfo *)
     * }
     */
    public static MemorySegment GetMontageInfo$address() {
        return GetMontageInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void GetMontageInfo(const ImageInfo *, MontageInfo *)
     * }
     */
    public static void GetMontageInfo(MemorySegment x0, MemorySegment x1) {
        var mh$ = GetMontageInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMontageInfo", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorFloodfillImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            _PixelPacket.layout(),
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ColorFloodfillImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ColorFloodfillImage(Image *, const DrawInfo *, const PixelPacket, const long, const long, const PaintMethod)
     * }
     */
    public static FunctionDescriptor ColorFloodfillImage$descriptor() {
        return ColorFloodfillImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ColorFloodfillImage(Image *, const DrawInfo *, const PixelPacket, const long, const long, const PaintMethod)
     * }
     */
    public static MethodHandle ColorFloodfillImage$handle() {
        return ColorFloodfillImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ColorFloodfillImage(Image *, const DrawInfo *, const PixelPacket, const long, const long, const PaintMethod)
     * }
     */
    public static MemorySegment ColorFloodfillImage$address() {
        return ColorFloodfillImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ColorFloodfillImage(Image *, const DrawInfo *, const PixelPacket, const long, const long, const PaintMethod)
     * }
     */
    public static int ColorFloodfillImage(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, long x4, int x5) {
        var mh$ = ColorFloodfillImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorFloodfillImage", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatteFloodfillImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            _PixelPacket.layout(),
            magick_wand_h.C_INT,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MatteFloodfillImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MatteFloodfillImage(Image *, const PixelPacket, const unsigned int, const long, const long, const PaintMethod)
     * }
     */
    public static FunctionDescriptor MatteFloodfillImage$descriptor() {
        return MatteFloodfillImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MatteFloodfillImage(Image *, const PixelPacket, const unsigned int, const long, const long, const PaintMethod)
     * }
     */
    public static MethodHandle MatteFloodfillImage$handle() {
        return MatteFloodfillImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MatteFloodfillImage(Image *, const PixelPacket, const unsigned int, const long, const long, const PaintMethod)
     * }
     */
    public static MemorySegment MatteFloodfillImage$address() {
        return MatteFloodfillImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MatteFloodfillImage(Image *, const PixelPacket, const unsigned int, const long, const long, const PaintMethod)
     * }
     */
    public static int MatteFloodfillImage(MemorySegment x0, MemorySegment x1, int x2, long x3, long x4, int x5) {
        var mh$ = MatteFloodfillImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatteFloodfillImage", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpaqueImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            _PixelPacket.layout(),
            _PixelPacket.layout()
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("OpaqueImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int OpaqueImage(Image *, const PixelPacket, const PixelPacket)
     * }
     */
    public static FunctionDescriptor OpaqueImage$descriptor() {
        return OpaqueImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int OpaqueImage(Image *, const PixelPacket, const PixelPacket)
     * }
     */
    public static MethodHandle OpaqueImage$handle() {
        return OpaqueImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int OpaqueImage(Image *, const PixelPacket, const PixelPacket)
     * }
     */
    public static MemorySegment OpaqueImage$address() {
        return OpaqueImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int OpaqueImage(Image *, const PixelPacket, const PixelPacket)
     * }
     */
    public static int OpaqueImage(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = OpaqueImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpaqueImage", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransparentImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            _PixelPacket.layout(),
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("TransparentImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int TransparentImage(Image *, const PixelPacket, const unsigned int)
     * }
     */
    public static FunctionDescriptor TransparentImage$descriptor() {
        return TransparentImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int TransparentImage(Image *, const PixelPacket, const unsigned int)
     * }
     */
    public static MethodHandle TransparentImage$handle() {
        return TransparentImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int TransparentImage(Image *, const PixelPacket, const unsigned int)
     * }
     */
    public static MemorySegment TransparentImage$address() {
        return TransparentImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int TransparentImage(Image *, const PixelPacket, const unsigned int)
     * }
     */
    public static int TransparentImage(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = TransparentImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransparentImage", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializePixelIteratorOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("InitializePixelIteratorOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void InitializePixelIteratorOptions(PixelIteratorOptions *options, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor InitializePixelIteratorOptions$descriptor() {
        return InitializePixelIteratorOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void InitializePixelIteratorOptions(PixelIteratorOptions *options, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle InitializePixelIteratorOptions$handle() {
        return InitializePixelIteratorOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void InitializePixelIteratorOptions(PixelIteratorOptions *options, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment InitializePixelIteratorOptions$address() {
        return InitializePixelIteratorOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void InitializePixelIteratorOptions(PixelIteratorOptions *options, ExceptionInfo *exception)
     * }
     */
    public static void InitializePixelIteratorOptions(MemorySegment options, MemorySegment exception) {
        var mh$ = InitializePixelIteratorOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializePixelIteratorOptions", options, exception);
            }
            mh$.invokeExact(options, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelIterateMonoRead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelIterateMonoRead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateMonoRead(PixelIteratorMonoReadCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const long x, const long y, const unsigned long columns, const unsigned long rows, const Image *image, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor PixelIterateMonoRead$descriptor() {
        return PixelIterateMonoRead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateMonoRead(PixelIteratorMonoReadCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const long x, const long y, const unsigned long columns, const unsigned long rows, const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle PixelIterateMonoRead$handle() {
        return PixelIterateMonoRead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateMonoRead(PixelIteratorMonoReadCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const long x, const long y, const unsigned long columns, const unsigned long rows, const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment PixelIterateMonoRead$address() {
        return PixelIterateMonoRead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int PixelIterateMonoRead(PixelIteratorMonoReadCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const long x, const long y, const unsigned long columns, const unsigned long rows, const Image *image, ExceptionInfo *exception)
     * }
     */
    public static int PixelIterateMonoRead(MemorySegment call_back, MemorySegment options, MemorySegment description, MemorySegment mutable_data, MemorySegment immutable_data, long x, long y, long columns, long rows, MemorySegment image, MemorySegment exception) {
        var mh$ = PixelIterateMonoRead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelIterateMonoRead", call_back, options, description, mutable_data, immutable_data, x, y, columns, rows, image, exception);
            }
            return (int)mh$.invokeExact(call_back, options, description, mutable_data, immutable_data, x, y, columns, rows, image, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelIterateMonoSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelIterateMonoSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateMonoSet(PixelIteratorMonoModifyCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const long x, const long y, const unsigned long columns, const unsigned long rows, Image *image, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor PixelIterateMonoSet$descriptor() {
        return PixelIterateMonoSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateMonoSet(PixelIteratorMonoModifyCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const long x, const long y, const unsigned long columns, const unsigned long rows, Image *image, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle PixelIterateMonoSet$handle() {
        return PixelIterateMonoSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateMonoSet(PixelIteratorMonoModifyCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const long x, const long y, const unsigned long columns, const unsigned long rows, Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment PixelIterateMonoSet$address() {
        return PixelIterateMonoSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int PixelIterateMonoSet(PixelIteratorMonoModifyCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const long x, const long y, const unsigned long columns, const unsigned long rows, Image *image, ExceptionInfo *exception)
     * }
     */
    public static int PixelIterateMonoSet(MemorySegment call_back, MemorySegment options, MemorySegment description, MemorySegment mutable_data, MemorySegment immutable_data, long x, long y, long columns, long rows, MemorySegment image, MemorySegment exception) {
        var mh$ = PixelIterateMonoSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelIterateMonoSet", call_back, options, description, mutable_data, immutable_data, x, y, columns, rows, image, exception);
            }
            return (int)mh$.invokeExact(call_back, options, description, mutable_data, immutable_data, x, y, columns, rows, image, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelIterateMonoModify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelIterateMonoModify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateMonoModify(PixelIteratorMonoModifyCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const long x, const long y, const unsigned long columns, const unsigned long rows, Image *image, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor PixelIterateMonoModify$descriptor() {
        return PixelIterateMonoModify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateMonoModify(PixelIteratorMonoModifyCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const long x, const long y, const unsigned long columns, const unsigned long rows, Image *image, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle PixelIterateMonoModify$handle() {
        return PixelIterateMonoModify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateMonoModify(PixelIteratorMonoModifyCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const long x, const long y, const unsigned long columns, const unsigned long rows, Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment PixelIterateMonoModify$address() {
        return PixelIterateMonoModify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int PixelIterateMonoModify(PixelIteratorMonoModifyCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const long x, const long y, const unsigned long columns, const unsigned long rows, Image *image, ExceptionInfo *exception)
     * }
     */
    public static int PixelIterateMonoModify(MemorySegment call_back, MemorySegment options, MemorySegment description, MemorySegment mutable_data, MemorySegment immutable_data, long x, long y, long columns, long rows, MemorySegment image, MemorySegment exception) {
        var mh$ = PixelIterateMonoModify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelIterateMonoModify", call_back, options, description, mutable_data, immutable_data, x, y, columns, rows, image, exception);
            }
            return (int)mh$.invokeExact(call_back, options, description, mutable_data, immutable_data, x, y, columns, rows, image, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelIterateDualRead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelIterateDualRead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateDualRead(PixelIteratorDualReadCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *first_image, const long first_x, const long first_y, const Image *second_image, const long second_x, const long second_y, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor PixelIterateDualRead$descriptor() {
        return PixelIterateDualRead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateDualRead(PixelIteratorDualReadCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *first_image, const long first_x, const long first_y, const Image *second_image, const long second_x, const long second_y, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle PixelIterateDualRead$handle() {
        return PixelIterateDualRead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateDualRead(PixelIteratorDualReadCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *first_image, const long first_x, const long first_y, const Image *second_image, const long second_x, const long second_y, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment PixelIterateDualRead$address() {
        return PixelIterateDualRead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int PixelIterateDualRead(PixelIteratorDualReadCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *first_image, const long first_x, const long first_y, const Image *second_image, const long second_x, const long second_y, ExceptionInfo *exception)
     * }
     */
    public static int PixelIterateDualRead(MemorySegment call_back, MemorySegment options, MemorySegment description, MemorySegment mutable_data, MemorySegment immutable_data, long columns, long rows, MemorySegment first_image, long first_x, long first_y, MemorySegment second_image, long second_x, long second_y, MemorySegment exception) {
        var mh$ = PixelIterateDualRead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelIterateDualRead", call_back, options, description, mutable_data, immutable_data, columns, rows, first_image, first_x, first_y, second_image, second_x, second_y, exception);
            }
            return (int)mh$.invokeExact(call_back, options, description, mutable_data, immutable_data, columns, rows, first_image, first_x, first_y, second_image, second_x, second_y, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelIterateDualModify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelIterateDualModify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateDualModify(PixelIteratorDualModifyCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *source_image, const long source_x, const long source_y, Image *update_image, const long update_x, const long update_y, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor PixelIterateDualModify$descriptor() {
        return PixelIterateDualModify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateDualModify(PixelIteratorDualModifyCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *source_image, const long source_x, const long source_y, Image *update_image, const long update_x, const long update_y, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle PixelIterateDualModify$handle() {
        return PixelIterateDualModify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateDualModify(PixelIteratorDualModifyCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *source_image, const long source_x, const long source_y, Image *update_image, const long update_x, const long update_y, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment PixelIterateDualModify$address() {
        return PixelIterateDualModify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int PixelIterateDualModify(PixelIteratorDualModifyCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *source_image, const long source_x, const long source_y, Image *update_image, const long update_x, const long update_y, ExceptionInfo *exception)
     * }
     */
    public static int PixelIterateDualModify(MemorySegment call_back, MemorySegment options, MemorySegment description, MemorySegment mutable_data, MemorySegment immutable_data, long columns, long rows, MemorySegment source_image, long source_x, long source_y, MemorySegment update_image, long update_x, long update_y, MemorySegment exception) {
        var mh$ = PixelIterateDualModify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelIterateDualModify", call_back, options, description, mutable_data, immutable_data, columns, rows, source_image, source_x, source_y, update_image, update_x, update_y, exception);
            }
            return (int)mh$.invokeExact(call_back, options, description, mutable_data, immutable_data, columns, rows, source_image, source_x, source_y, update_image, update_x, update_y, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelIterateDualNew {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelIterateDualNew");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateDualNew(PixelIteratorDualNewCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *source_image, const long source_x, const long source_y, Image *new_image, const long new_x, const long new_y, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor PixelIterateDualNew$descriptor() {
        return PixelIterateDualNew.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateDualNew(PixelIteratorDualNewCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *source_image, const long source_x, const long source_y, Image *new_image, const long new_x, const long new_y, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle PixelIterateDualNew$handle() {
        return PixelIterateDualNew.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateDualNew(PixelIteratorDualNewCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *source_image, const long source_x, const long source_y, Image *new_image, const long new_x, const long new_y, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment PixelIterateDualNew$address() {
        return PixelIterateDualNew.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int PixelIterateDualNew(PixelIteratorDualNewCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *source_image, const long source_x, const long source_y, Image *new_image, const long new_x, const long new_y, ExceptionInfo *exception)
     * }
     */
    public static int PixelIterateDualNew(MemorySegment call_back, MemorySegment options, MemorySegment description, MemorySegment mutable_data, MemorySegment immutable_data, long columns, long rows, MemorySegment source_image, long source_x, long source_y, MemorySegment new_image, long new_x, long new_y, MemorySegment exception) {
        var mh$ = PixelIterateDualNew.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelIterateDualNew", call_back, options, description, mutable_data, immutable_data, columns, rows, source_image, source_x, source_y, new_image, new_x, new_y, exception);
            }
            return (int)mh$.invokeExact(call_back, options, description, mutable_data, immutable_data, columns, rows, source_image, source_x, source_y, new_image, new_x, new_y, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelIterateTripleModify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelIterateTripleModify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateTripleModify(PixelIteratorTripleModifyCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *source1_image, const Image *source2_image, const long source_x, const long source_y, Image *update_image, const long update_x, const long update_y, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor PixelIterateTripleModify$descriptor() {
        return PixelIterateTripleModify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateTripleModify(PixelIteratorTripleModifyCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *source1_image, const Image *source2_image, const long source_x, const long source_y, Image *update_image, const long update_x, const long update_y, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle PixelIterateTripleModify$handle() {
        return PixelIterateTripleModify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateTripleModify(PixelIteratorTripleModifyCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *source1_image, const Image *source2_image, const long source_x, const long source_y, Image *update_image, const long update_x, const long update_y, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment PixelIterateTripleModify$address() {
        return PixelIterateTripleModify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int PixelIterateTripleModify(PixelIteratorTripleModifyCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *source1_image, const Image *source2_image, const long source_x, const long source_y, Image *update_image, const long update_x, const long update_y, ExceptionInfo *exception)
     * }
     */
    public static int PixelIterateTripleModify(MemorySegment call_back, MemorySegment options, MemorySegment description, MemorySegment mutable_data, MemorySegment immutable_data, long columns, long rows, MemorySegment source1_image, MemorySegment source2_image, long source_x, long source_y, MemorySegment update_image, long update_x, long update_y, MemorySegment exception) {
        var mh$ = PixelIterateTripleModify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelIterateTripleModify", call_back, options, description, mutable_data, immutable_data, columns, rows, source1_image, source2_image, source_x, source_y, update_image, update_x, update_y, exception);
            }
            return (int)mh$.invokeExact(call_back, options, description, mutable_data, immutable_data, columns, rows, source1_image, source2_image, source_x, source_y, update_image, update_x, update_y, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelIterateTripleNew {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelIterateTripleNew");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateTripleNew(PixelIteratorTripleNewCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *source1_image, const Image *source2_image, const long source_x, const long source_y, Image *new_image, const long new_x, const long new_y, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor PixelIterateTripleNew$descriptor() {
        return PixelIterateTripleNew.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateTripleNew(PixelIteratorTripleNewCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *source1_image, const Image *source2_image, const long source_x, const long source_y, Image *new_image, const long new_x, const long new_y, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle PixelIterateTripleNew$handle() {
        return PixelIterateTripleNew.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int PixelIterateTripleNew(PixelIteratorTripleNewCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *source1_image, const Image *source2_image, const long source_x, const long source_y, Image *new_image, const long new_x, const long new_y, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment PixelIterateTripleNew$address() {
        return PixelIterateTripleNew.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int PixelIterateTripleNew(PixelIteratorTripleNewCallback call_back, const PixelIteratorOptions *options, const char *description, void *mutable_data, const void *immutable_data, const unsigned long columns, const unsigned long rows, const Image *source1_image, const Image *source2_image, const long source_x, const long source_y, Image *new_image, const long new_x, const long new_y, ExceptionInfo *exception)
     * }
     */
    public static int PixelIterateTripleNew(MemorySegment call_back, MemorySegment options, MemorySegment description, MemorySegment mutable_data, MemorySegment immutable_data, long columns, long rows, MemorySegment source1_image, MemorySegment source2_image, long source_x, long source_y, MemorySegment new_image, long new_x, long new_y, MemorySegment exception) {
        var mh$ = PixelIterateTripleNew.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelIterateTripleNew", call_back, options, description, mutable_data, immutable_data, columns, rows, source1_image, source2_image, source_x, source_y, new_image, new_x, new_y, exception);
            }
            return (int)mh$.invokeExact(call_back, options, description, mutable_data, immutable_data, columns, rows, source1_image, source2_image, source_x, source_y, new_image, new_x, new_y, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlasmaImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PlasmaImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int PlasmaImage(Image *image, const SegmentInfo *segment, unsigned long attenuate, unsigned long depth)
     * }
     */
    public static FunctionDescriptor PlasmaImage$descriptor() {
        return PlasmaImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int PlasmaImage(Image *image, const SegmentInfo *segment, unsigned long attenuate, unsigned long depth)
     * }
     */
    public static MethodHandle PlasmaImage$handle() {
        return PlasmaImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int PlasmaImage(Image *image, const SegmentInfo *segment, unsigned long attenuate, unsigned long depth)
     * }
     */
    public static MemorySegment PlasmaImage$address() {
        return PlasmaImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int PlasmaImage(Image *image, const SegmentInfo *segment, unsigned long attenuate, unsigned long depth)
     * }
     */
    public static int PlasmaImage(MemorySegment image, MemorySegment segment, long attenuate, long depth) {
        var mh$ = PlasmaImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlasmaImage", image, segment, attenuate, depth);
            }
            return (int)mh$.invokeExact(image, segment, attenuate, depth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageProfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageProfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const unsigned char *GetImageProfile(const Image *image, const char *name, size_t *length)
     * }
     */
    public static FunctionDescriptor GetImageProfile$descriptor() {
        return GetImageProfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const unsigned char *GetImageProfile(const Image *image, const char *name, size_t *length)
     * }
     */
    public static MethodHandle GetImageProfile$handle() {
        return GetImageProfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const unsigned char *GetImageProfile(const Image *image, const char *name, size_t *length)
     * }
     */
    public static MemorySegment GetImageProfile$address() {
        return GetImageProfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const unsigned char *GetImageProfile(const Image *image, const char *name, size_t *length)
     * }
     */
    public static MemorySegment GetImageProfile(MemorySegment image, MemorySegment name, MemorySegment length) {
        var mh$ = GetImageProfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageProfile", image, name, length);
            }
            return (MemorySegment)mh$.invokeExact(image, name, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteImageProfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DeleteImageProfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int DeleteImageProfile(Image *image, const char *name)
     * }
     */
    public static FunctionDescriptor DeleteImageProfile$descriptor() {
        return DeleteImageProfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int DeleteImageProfile(Image *image, const char *name)
     * }
     */
    public static MethodHandle DeleteImageProfile$handle() {
        return DeleteImageProfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int DeleteImageProfile(Image *image, const char *name)
     * }
     */
    public static MemorySegment DeleteImageProfile$address() {
        return DeleteImageProfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int DeleteImageProfile(Image *image, const char *name)
     * }
     */
    public static int DeleteImageProfile(MemorySegment image, MemorySegment name) {
        var mh$ = DeleteImageProfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteImageProfile", image, name);
            }
            return (int)mh$.invokeExact(image, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProfileImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ProfileImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ProfileImage(Image *image, const char *name, unsigned char *profile, const size_t length, unsigned int clone)
     * }
     */
    public static FunctionDescriptor ProfileImage$descriptor() {
        return ProfileImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ProfileImage(Image *image, const char *name, unsigned char *profile, const size_t length, unsigned int clone)
     * }
     */
    public static MethodHandle ProfileImage$handle() {
        return ProfileImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ProfileImage(Image *image, const char *name, unsigned char *profile, const size_t length, unsigned int clone)
     * }
     */
    public static MemorySegment ProfileImage$address() {
        return ProfileImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ProfileImage(Image *image, const char *name, unsigned char *profile, const size_t length, unsigned int clone)
     * }
     */
    public static int ProfileImage(MemorySegment image, MemorySegment name, MemorySegment profile, long length, int clone) {
        var mh$ = ProfileImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProfileImage", image, name, profile, length, clone);
            }
            return (int)mh$.invokeExact(image, name, profile, length, clone);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetImageProfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetImageProfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SetImageProfile(Image *image, const char *name, const unsigned char *profile, const size_t length)
     * }
     */
    public static FunctionDescriptor SetImageProfile$descriptor() {
        return SetImageProfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SetImageProfile(Image *image, const char *name, const unsigned char *profile, const size_t length)
     * }
     */
    public static MethodHandle SetImageProfile$handle() {
        return SetImageProfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SetImageProfile(Image *image, const char *name, const unsigned char *profile, const size_t length)
     * }
     */
    public static MemorySegment SetImageProfile$address() {
        return SetImageProfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SetImageProfile(Image *image, const char *name, const unsigned char *profile, const size_t length)
     * }
     */
    public static int SetImageProfile(MemorySegment image, MemorySegment name, MemorySegment profile, long length) {
        var mh$ = SetImageProfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetImageProfile", image, name, profile, length);
            }
            return (int)mh$.invokeExact(image, name, profile, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AppendImageProfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AppendImageProfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int AppendImageProfile(Image *image, const char *name, const unsigned char *profile_chunk, const size_t chunk_length)
     * }
     */
    public static FunctionDescriptor AppendImageProfile$descriptor() {
        return AppendImageProfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int AppendImageProfile(Image *image, const char *name, const unsigned char *profile_chunk, const size_t chunk_length)
     * }
     */
    public static MethodHandle AppendImageProfile$handle() {
        return AppendImageProfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int AppendImageProfile(Image *image, const char *name, const unsigned char *profile_chunk, const size_t chunk_length)
     * }
     */
    public static MemorySegment AppendImageProfile$address() {
        return AppendImageProfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int AppendImageProfile(Image *image, const char *name, const unsigned char *profile_chunk, const size_t chunk_length)
     * }
     */
    public static int AppendImageProfile(MemorySegment image, MemorySegment name, MemorySegment profile_chunk, long chunk_length) {
        var mh$ = AppendImageProfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AppendImageProfile", image, name, profile_chunk, chunk_length);
            }
            return (int)mh$.invokeExact(image, name, profile_chunk, chunk_length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *ImageProfileIterator
     * }
     */
    public static final AddressLayout ImageProfileIterator = magick_wand_h.C_POINTER;

    private static class AllocateImageProfileIterator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AllocateImageProfileIterator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ImageProfileIterator AllocateImageProfileIterator(const Image *image)
     * }
     */
    public static FunctionDescriptor AllocateImageProfileIterator$descriptor() {
        return AllocateImageProfileIterator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ImageProfileIterator AllocateImageProfileIterator(const Image *image)
     * }
     */
    public static MethodHandle AllocateImageProfileIterator$handle() {
        return AllocateImageProfileIterator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ImageProfileIterator AllocateImageProfileIterator(const Image *image)
     * }
     */
    public static MemorySegment AllocateImageProfileIterator$address() {
        return AllocateImageProfileIterator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ImageProfileIterator AllocateImageProfileIterator(const Image *image)
     * }
     */
    public static MemorySegment AllocateImageProfileIterator(MemorySegment image) {
        var mh$ = AllocateImageProfileIterator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateImageProfileIterator", image);
            }
            return (MemorySegment)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NextImageProfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("NextImageProfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int NextImageProfile(ImageProfileIterator profile_iterator, const char **name, const unsigned char **profile, size_t *length)
     * }
     */
    public static FunctionDescriptor NextImageProfile$descriptor() {
        return NextImageProfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int NextImageProfile(ImageProfileIterator profile_iterator, const char **name, const unsigned char **profile, size_t *length)
     * }
     */
    public static MethodHandle NextImageProfile$handle() {
        return NextImageProfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int NextImageProfile(ImageProfileIterator profile_iterator, const char **name, const unsigned char **profile, size_t *length)
     * }
     */
    public static MemorySegment NextImageProfile$address() {
        return NextImageProfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int NextImageProfile(ImageProfileIterator profile_iterator, const char **name, const unsigned char **profile, size_t *length)
     * }
     */
    public static int NextImageProfile(MemorySegment profile_iterator, MemorySegment name, MemorySegment profile, MemorySegment length) {
        var mh$ = NextImageProfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NextImageProfile", profile_iterator, name, profile, length);
            }
            return (int)mh$.invokeExact(profile_iterator, name, profile, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeallocateImageProfileIterator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DeallocateImageProfileIterator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DeallocateImageProfileIterator(ImageProfileIterator profile_iterator)
     * }
     */
    public static FunctionDescriptor DeallocateImageProfileIterator$descriptor() {
        return DeallocateImageProfileIterator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DeallocateImageProfileIterator(ImageProfileIterator profile_iterator)
     * }
     */
    public static MethodHandle DeallocateImageProfileIterator$handle() {
        return DeallocateImageProfileIterator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DeallocateImageProfileIterator(ImageProfileIterator profile_iterator)
     * }
     */
    public static MemorySegment DeallocateImageProfileIterator$address() {
        return DeallocateImageProfileIterator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DeallocateImageProfileIterator(ImageProfileIterator profile_iterator)
     * }
     */
    public static void DeallocateImageProfileIterator(MemorySegment profile_iterator) {
        var mh$ = DeallocateImageProfileIterator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeallocateImageProfileIterator", profile_iterator);
            }
            mh$.invokeExact(profile_iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloneQuantizeInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CloneQuantizeInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern QuantizeInfo *CloneQuantizeInfo(const QuantizeInfo *)
     * }
     */
    public static FunctionDescriptor CloneQuantizeInfo$descriptor() {
        return CloneQuantizeInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern QuantizeInfo *CloneQuantizeInfo(const QuantizeInfo *)
     * }
     */
    public static MethodHandle CloneQuantizeInfo$handle() {
        return CloneQuantizeInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern QuantizeInfo *CloneQuantizeInfo(const QuantizeInfo *)
     * }
     */
    public static MemorySegment CloneQuantizeInfo$address() {
        return CloneQuantizeInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern QuantizeInfo *CloneQuantizeInfo(const QuantizeInfo *)
     * }
     */
    public static MemorySegment CloneQuantizeInfo(MemorySegment x0) {
        var mh$ = CloneQuantizeInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloneQuantizeInfo", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageQuantizeError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageQuantizeError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int GetImageQuantizeError(Image *)
     * }
     */
    public static FunctionDescriptor GetImageQuantizeError$descriptor() {
        return GetImageQuantizeError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int GetImageQuantizeError(Image *)
     * }
     */
    public static MethodHandle GetImageQuantizeError$handle() {
        return GetImageQuantizeError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int GetImageQuantizeError(Image *)
     * }
     */
    public static MemorySegment GetImageQuantizeError$address() {
        return GetImageQuantizeError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int GetImageQuantizeError(Image *)
     * }
     */
    public static int GetImageQuantizeError(MemorySegment x0) {
        var mh$ = GetImageQuantizeError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageQuantizeError", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MapImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MapImage(Image *, const Image *, const unsigned int)
     * }
     */
    public static FunctionDescriptor MapImage$descriptor() {
        return MapImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MapImage(Image *, const Image *, const unsigned int)
     * }
     */
    public static MethodHandle MapImage$handle() {
        return MapImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MapImage(Image *, const Image *, const unsigned int)
     * }
     */
    public static MemorySegment MapImage$address() {
        return MapImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MapImage(Image *, const Image *, const unsigned int)
     * }
     */
    public static int MapImage(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = MapImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapImage", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapImages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MapImages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MapImages(Image *, const Image *, const unsigned int)
     * }
     */
    public static FunctionDescriptor MapImages$descriptor() {
        return MapImages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MapImages(Image *, const Image *, const unsigned int)
     * }
     */
    public static MethodHandle MapImages$handle() {
        return MapImages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MapImages(Image *, const Image *, const unsigned int)
     * }
     */
    public static MemorySegment MapImages$address() {
        return MapImages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MapImages(Image *, const Image *, const unsigned int)
     * }
     */
    public static int MapImages(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = MapImages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapImages", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OrderedDitherImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("OrderedDitherImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int OrderedDitherImage(Image *)
     * }
     */
    public static FunctionDescriptor OrderedDitherImage$descriptor() {
        return OrderedDitherImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int OrderedDitherImage(Image *)
     * }
     */
    public static MethodHandle OrderedDitherImage$handle() {
        return OrderedDitherImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int OrderedDitherImage(Image *)
     * }
     */
    public static MemorySegment OrderedDitherImage$address() {
        return OrderedDitherImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int OrderedDitherImage(Image *)
     * }
     */
    public static int OrderedDitherImage(MemorySegment x0) {
        var mh$ = OrderedDitherImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OrderedDitherImage", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuantizeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("QuantizeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int QuantizeImage(const QuantizeInfo *, Image *)
     * }
     */
    public static FunctionDescriptor QuantizeImage$descriptor() {
        return QuantizeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int QuantizeImage(const QuantizeInfo *, Image *)
     * }
     */
    public static MethodHandle QuantizeImage$handle() {
        return QuantizeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int QuantizeImage(const QuantizeInfo *, Image *)
     * }
     */
    public static MemorySegment QuantizeImage$address() {
        return QuantizeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int QuantizeImage(const QuantizeInfo *, Image *)
     * }
     */
    public static int QuantizeImage(MemorySegment x0, MemorySegment x1) {
        var mh$ = QuantizeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuantizeImage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuantizeImages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("QuantizeImages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int QuantizeImages(const QuantizeInfo *, Image *)
     * }
     */
    public static FunctionDescriptor QuantizeImages$descriptor() {
        return QuantizeImages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int QuantizeImages(const QuantizeInfo *, Image *)
     * }
     */
    public static MethodHandle QuantizeImages$handle() {
        return QuantizeImages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int QuantizeImages(const QuantizeInfo *, Image *)
     * }
     */
    public static MemorySegment QuantizeImages$address() {
        return QuantizeImages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int QuantizeImages(const QuantizeInfo *, Image *)
     * }
     */
    public static int QuantizeImages(MemorySegment x0, MemorySegment x1) {
        var mh$ = QuantizeImages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuantizeImages", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SegmentImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SegmentImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SegmentImage(Image *, const ColorspaceType, const unsigned int, const double, const double)
     * }
     */
    public static FunctionDescriptor SegmentImage$descriptor() {
        return SegmentImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SegmentImage(Image *, const ColorspaceType, const unsigned int, const double, const double)
     * }
     */
    public static MethodHandle SegmentImage$handle() {
        return SegmentImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SegmentImage(Image *, const ColorspaceType, const unsigned int, const double, const double)
     * }
     */
    public static MemorySegment SegmentImage$address() {
        return SegmentImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SegmentImage(Image *, const ColorspaceType, const unsigned int, const double, const double)
     * }
     */
    public static int SegmentImage(MemorySegment x0, int x1, int x2, double x3, double x4) {
        var mh$ = SegmentImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SegmentImage", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompressImageColormap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CompressImageColormap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void CompressImageColormap(Image *)
     * }
     */
    public static FunctionDescriptor CompressImageColormap$descriptor() {
        return CompressImageColormap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void CompressImageColormap(Image *)
     * }
     */
    public static MethodHandle CompressImageColormap$handle() {
        return CompressImageColormap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void CompressImageColormap(Image *)
     * }
     */
    public static MemorySegment CompressImageColormap$address() {
        return CompressImageColormap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void CompressImageColormap(Image *)
     * }
     */
    public static void CompressImageColormap(MemorySegment x0) {
        var mh$ = CompressImageColormap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompressImageColormap", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyQuantizeInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DestroyQuantizeInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DestroyQuantizeInfo(QuantizeInfo *)
     * }
     */
    public static FunctionDescriptor DestroyQuantizeInfo$descriptor() {
        return DestroyQuantizeInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DestroyQuantizeInfo(QuantizeInfo *)
     * }
     */
    public static MethodHandle DestroyQuantizeInfo$handle() {
        return DestroyQuantizeInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DestroyQuantizeInfo(QuantizeInfo *)
     * }
     */
    public static MemorySegment DestroyQuantizeInfo$address() {
        return DestroyQuantizeInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DestroyQuantizeInfo(QuantizeInfo *)
     * }
     */
    public static void DestroyQuantizeInfo(MemorySegment x0) {
        var mh$ = DestroyQuantizeInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyQuantizeInfo", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetQuantizeInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetQuantizeInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void GetQuantizeInfo(QuantizeInfo *)
     * }
     */
    public static FunctionDescriptor GetQuantizeInfo$descriptor() {
        return GetQuantizeInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void GetQuantizeInfo(QuantizeInfo *)
     * }
     */
    public static MethodHandle GetQuantizeInfo$handle() {
        return GetQuantizeInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void GetQuantizeInfo(QuantizeInfo *)
     * }
     */
    public static MemorySegment GetQuantizeInfo$address() {
        return GetQuantizeInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void GetQuantizeInfo(QuantizeInfo *)
     * }
     */
    public static void GetQuantizeInfo(MemorySegment x0) {
        var mh$ = GetQuantizeInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetQuantizeInfo", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrayscalePseudoClassImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GrayscalePseudoClassImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void GrayscalePseudoClassImage(Image *, unsigned int)
     * }
     */
    public static FunctionDescriptor GrayscalePseudoClassImage$descriptor() {
        return GrayscalePseudoClassImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void GrayscalePseudoClassImage(Image *, unsigned int)
     * }
     */
    public static MethodHandle GrayscalePseudoClassImage$handle() {
        return GrayscalePseudoClassImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void GrayscalePseudoClassImage(Image *, unsigned int)
     * }
     */
    public static MemorySegment GrayscalePseudoClassImage$address() {
        return GrayscalePseudoClassImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void GrayscalePseudoClassImage(Image *, unsigned int)
     * }
     */
    public static void GrayscalePseudoClassImage(MemorySegment x0, int x1) {
        var mh$ = GrayscalePseudoClassImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrayscalePseudoClassImage", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UndefinedRegistryType = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UndefinedRegistryType = 0
     * }
     */
    public static int UndefinedRegistryType() {
        return UndefinedRegistryType;
    }
    private static final int ImageRegistryType = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ImageRegistryType = 1
     * }
     */
    public static int ImageRegistryType() {
        return ImageRegistryType;
    }
    private static final int ImageInfoRegistryType = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ImageInfoRegistryType = 2
     * }
     */
    public static int ImageInfoRegistryType() {
        return ImageInfoRegistryType;
    }

    private static class GetImageFromMagickRegistry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageFromMagickRegistry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *GetImageFromMagickRegistry(const char *name, long *id, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetImageFromMagickRegistry$descriptor() {
        return GetImageFromMagickRegistry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *GetImageFromMagickRegistry(const char *name, long *id, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetImageFromMagickRegistry$handle() {
        return GetImageFromMagickRegistry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *GetImageFromMagickRegistry(const char *name, long *id, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetImageFromMagickRegistry$address() {
        return GetImageFromMagickRegistry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *GetImageFromMagickRegistry(const char *name, long *id, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetImageFromMagickRegistry(MemorySegment name, MemorySegment id, MemorySegment exception) {
        var mh$ = GetImageFromMagickRegistry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageFromMagickRegistry", name, id, exception);
            }
            return (MemorySegment)mh$.invokeExact(name, id, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMagickRegistry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetMagickRegistry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long SetMagickRegistry(const RegistryType type, const void *blob, const size_t length, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor SetMagickRegistry$descriptor() {
        return SetMagickRegistry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long SetMagickRegistry(const RegistryType type, const void *blob, const size_t length, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle SetMagickRegistry$handle() {
        return SetMagickRegistry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long SetMagickRegistry(const RegistryType type, const void *blob, const size_t length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment SetMagickRegistry$address() {
        return SetMagickRegistry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long SetMagickRegistry(const RegistryType type, const void *blob, const size_t length, ExceptionInfo *exception)
     * }
     */
    public static long SetMagickRegistry(int type, MemorySegment blob, long length, MemorySegment exception) {
        var mh$ = SetMagickRegistry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMagickRegistry", type, blob, length, exception);
            }
            return (long)mh$.invokeExact(type, blob, length, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteMagickRegistry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DeleteMagickRegistry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int DeleteMagickRegistry(const long id)
     * }
     */
    public static FunctionDescriptor DeleteMagickRegistry$descriptor() {
        return DeleteMagickRegistry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int DeleteMagickRegistry(const long id)
     * }
     */
    public static MethodHandle DeleteMagickRegistry$handle() {
        return DeleteMagickRegistry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int DeleteMagickRegistry(const long id)
     * }
     */
    public static MemorySegment DeleteMagickRegistry$address() {
        return DeleteMagickRegistry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int DeleteMagickRegistry(const long id)
     * }
     */
    public static int DeleteMagickRegistry(long id) {
        var mh$ = DeleteMagickRegistry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteMagickRegistry", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMagickRegistry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetMagickRegistry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *GetMagickRegistry(const long id, RegistryType *type, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetMagickRegistry$descriptor() {
        return GetMagickRegistry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *GetMagickRegistry(const long id, RegistryType *type, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetMagickRegistry$handle() {
        return GetMagickRegistry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *GetMagickRegistry(const long id, RegistryType *type, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetMagickRegistry$address() {
        return GetMagickRegistry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *GetMagickRegistry(const long id, RegistryType *type, size_t *length, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetMagickRegistry(long id, MemorySegment type, MemorySegment length, MemorySegment exception) {
        var mh$ = GetMagickRegistry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMagickRegistry", id, type, length, exception);
            }
            return (MemorySegment)mh$.invokeExact(id, type, length, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagnifyImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagnifyImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *MagnifyImage(const Image *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor MagnifyImage$descriptor() {
        return MagnifyImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *MagnifyImage(const Image *, ExceptionInfo *)
     * }
     */
    public static MethodHandle MagnifyImage$handle() {
        return MagnifyImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *MagnifyImage(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment MagnifyImage$address() {
        return MagnifyImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *MagnifyImage(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment MagnifyImage(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagnifyImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagnifyImage", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MinifyImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MinifyImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *MinifyImage(const Image *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor MinifyImage$descriptor() {
        return MinifyImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *MinifyImage(const Image *, ExceptionInfo *)
     * }
     */
    public static MethodHandle MinifyImage$handle() {
        return MinifyImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *MinifyImage(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment MinifyImage$address() {
        return MinifyImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *MinifyImage(const Image *, ExceptionInfo *)
     * }
     */
    public static MemorySegment MinifyImage(MemorySegment x0, MemorySegment x1) {
        var mh$ = MinifyImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MinifyImage", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResizeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ResizeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ResizeImage(const Image *, const unsigned long, const unsigned long, const FilterTypes, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor ResizeImage$descriptor() {
        return ResizeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ResizeImage(const Image *, const unsigned long, const unsigned long, const FilterTypes, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle ResizeImage$handle() {
        return ResizeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ResizeImage(const Image *, const unsigned long, const unsigned long, const FilterTypes, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment ResizeImage$address() {
        return ResizeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ResizeImage(const Image *, const unsigned long, const unsigned long, const FilterTypes, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment ResizeImage(MemorySegment x0, long x1, long x2, int x3, double x4, MemorySegment x5) {
        var mh$ = ResizeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResizeImage", x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SampleImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SampleImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *SampleImage(const Image *, const unsigned long, const unsigned long, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor SampleImage$descriptor() {
        return SampleImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *SampleImage(const Image *, const unsigned long, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MethodHandle SampleImage$handle() {
        return SampleImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *SampleImage(const Image *, const unsigned long, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MemorySegment SampleImage$address() {
        return SampleImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *SampleImage(const Image *, const unsigned long, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MemorySegment SampleImage(MemorySegment x0, long x1, long x2, MemorySegment x3) {
        var mh$ = SampleImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SampleImage", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScaleImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ScaleImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ScaleImage(const Image *, const unsigned long, const unsigned long, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor ScaleImage$descriptor() {
        return ScaleImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ScaleImage(const Image *, const unsigned long, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MethodHandle ScaleImage$handle() {
        return ScaleImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ScaleImage(const Image *, const unsigned long, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MemorySegment ScaleImage$address() {
        return ScaleImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ScaleImage(const Image *, const unsigned long, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MemorySegment ScaleImage(MemorySegment x0, long x1, long x2, MemorySegment x3) {
        var mh$ = ScaleImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScaleImage", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThumbnailImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ThumbnailImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ThumbnailImage(const Image *, const unsigned long, const unsigned long, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor ThumbnailImage$descriptor() {
        return ThumbnailImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ThumbnailImage(const Image *, const unsigned long, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MethodHandle ThumbnailImage$handle() {
        return ThumbnailImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ThumbnailImage(const Image *, const unsigned long, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MemorySegment ThumbnailImage$address() {
        return ThumbnailImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ThumbnailImage(const Image *, const unsigned long, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MemorySegment ThumbnailImage(MemorySegment x0, long x1, long x2, MemorySegment x3) {
        var mh$ = ThumbnailImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThumbnailImage", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZoomImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ZoomImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ZoomImage(const Image *, const unsigned long, const unsigned long, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor ZoomImage$descriptor() {
        return ZoomImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ZoomImage(const Image *, const unsigned long, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MethodHandle ZoomImage$handle() {
        return ZoomImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ZoomImage(const Image *, const unsigned long, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MemorySegment ZoomImage$address() {
        return ZoomImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ZoomImage(const Image *, const unsigned long, const unsigned long, ExceptionInfo *)
     * }
     */
    public static MemorySegment ZoomImage(MemorySegment x0, long x1, long x2, MemorySegment x3) {
        var mh$ = ZoomImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZoomImage", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AffineTransformImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AffineTransformImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *AffineTransformImage(const Image *, const AffineMatrix *, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor AffineTransformImage$descriptor() {
        return AffineTransformImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *AffineTransformImage(const Image *, const AffineMatrix *, ExceptionInfo *)
     * }
     */
    public static MethodHandle AffineTransformImage$handle() {
        return AffineTransformImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *AffineTransformImage(const Image *, const AffineMatrix *, ExceptionInfo *)
     * }
     */
    public static MemorySegment AffineTransformImage$address() {
        return AffineTransformImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *AffineTransformImage(const Image *, const AffineMatrix *, ExceptionInfo *)
     * }
     */
    public static MemorySegment AffineTransformImage(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = AffineTransformImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AffineTransformImage", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AutoOrientImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AutoOrientImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *AutoOrientImage(const Image *image, const OrientationType current_orientation, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor AutoOrientImage$descriptor() {
        return AutoOrientImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *AutoOrientImage(const Image *image, const OrientationType current_orientation, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle AutoOrientImage$handle() {
        return AutoOrientImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *AutoOrientImage(const Image *image, const OrientationType current_orientation, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment AutoOrientImage$address() {
        return AutoOrientImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *AutoOrientImage(const Image *image, const OrientationType current_orientation, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment AutoOrientImage(MemorySegment image, int current_orientation, MemorySegment exception) {
        var mh$ = AutoOrientImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AutoOrientImage", image, current_orientation, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, current_orientation, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RotateImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("RotateImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *RotateImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor RotateImage$descriptor() {
        return RotateImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *RotateImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle RotateImage$handle() {
        return RotateImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *RotateImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment RotateImage$address() {
        return RotateImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *RotateImage(const Image *, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment RotateImage(MemorySegment x0, double x1, MemorySegment x2) {
        var mh$ = RotateImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RotateImage", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShearImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ShearImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ShearImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static FunctionDescriptor ShearImage$descriptor() {
        return ShearImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ShearImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MethodHandle ShearImage$handle() {
        return ShearImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ShearImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment ShearImage$address() {
        return ShearImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ShearImage(const Image *, const double, const double, ExceptionInfo *)
     * }
     */
    public static MemorySegment ShearImage(MemorySegment x0, double x1, double x2, MemorySegment x3) {
        var mh$ = ShearImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShearImage", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SignatureImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SignatureImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SignatureImage(Image *)
     * }
     */
    public static FunctionDescriptor SignatureImage$descriptor() {
        return SignatureImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SignatureImage(Image *)
     * }
     */
    public static MethodHandle SignatureImage$handle() {
        return SignatureImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SignatureImage(Image *)
     * }
     */
    public static MemorySegment SignatureImage$address() {
        return SignatureImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SignatureImage(Image *)
     * }
     */
    public static int SignatureImage(MemorySegment x0) {
        var mh$ = SignatureImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SignatureImage", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetImageStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetImageStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int GetImageStatistics(const Image *image, ImageStatistics *statistics, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor GetImageStatistics$descriptor() {
        return GetImageStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int GetImageStatistics(const Image *image, ImageStatistics *statistics, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle GetImageStatistics$handle() {
        return GetImageStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int GetImageStatistics(const Image *image, ImageStatistics *statistics, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment GetImageStatistics$address() {
        return GetImageStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int GetImageStatistics(const Image *image, ImageStatistics *statistics, ExceptionInfo *exception)
     * }
     */
    public static int GetImageStatistics(MemorySegment image, MemorySegment statistics, MemorySegment exception) {
        var mh$ = GetImageStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetImageStatistics", image, statistics, exception);
            }
            return (int)mh$.invokeExact(image, statistics, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextureImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("TextureImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int TextureImage(Image *, const Image *)
     * }
     */
    public static FunctionDescriptor TextureImage$descriptor() {
        return TextureImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int TextureImage(Image *, const Image *)
     * }
     */
    public static MethodHandle TextureImage$handle() {
        return TextureImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int TextureImage(Image *, const Image *)
     * }
     */
    public static MemorySegment TextureImage$address() {
        return TextureImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int TextureImage(Image *, const Image *)
     * }
     */
    public static int TextureImage(MemorySegment x0, MemorySegment x1) {
        var mh$ = TextureImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextureImage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChopImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ChopImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ChopImage(const Image *image, const RectangleInfo *chop_info, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ChopImage$descriptor() {
        return ChopImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ChopImage(const Image *image, const RectangleInfo *chop_info, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ChopImage$handle() {
        return ChopImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ChopImage(const Image *image, const RectangleInfo *chop_info, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ChopImage$address() {
        return ChopImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ChopImage(const Image *image, const RectangleInfo *chop_info, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ChopImage(MemorySegment image, MemorySegment chop_info, MemorySegment exception) {
        var mh$ = ChopImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChopImage", image, chop_info, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, chop_info, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CoalesceImages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CoalesceImages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *CoalesceImages(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor CoalesceImages$descriptor() {
        return CoalesceImages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *CoalesceImages(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle CoalesceImages$handle() {
        return CoalesceImages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *CoalesceImages(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment CoalesceImages$address() {
        return CoalesceImages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *CoalesceImages(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment CoalesceImages(MemorySegment image, MemorySegment exception) {
        var mh$ = CoalesceImages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CoalesceImages", image, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CropImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CropImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *CropImage(const Image *image, const RectangleInfo *geometry, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor CropImage$descriptor() {
        return CropImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *CropImage(const Image *image, const RectangleInfo *geometry, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle CropImage$handle() {
        return CropImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *CropImage(const Image *image, const RectangleInfo *geometry, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment CropImage$address() {
        return CropImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *CropImage(const Image *image, const RectangleInfo *geometry, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment CropImage(MemorySegment image, MemorySegment geometry, MemorySegment exception) {
        var mh$ = CropImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CropImage", image, geometry, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, geometry, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeconstructImages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DeconstructImages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *DeconstructImages(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor DeconstructImages$descriptor() {
        return DeconstructImages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *DeconstructImages(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle DeconstructImages$handle() {
        return DeconstructImages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *DeconstructImages(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment DeconstructImages$address() {
        return DeconstructImages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *DeconstructImages(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment DeconstructImages(MemorySegment image, MemorySegment exception) {
        var mh$ = DeconstructImages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeconstructImages", image, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtentImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ExtentImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ExtentImage(const Image *image, const RectangleInfo *geometry, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ExtentImage$descriptor() {
        return ExtentImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ExtentImage(const Image *image, const RectangleInfo *geometry, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ExtentImage$handle() {
        return ExtentImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ExtentImage(const Image *image, const RectangleInfo *geometry, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ExtentImage$address() {
        return ExtentImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ExtentImage(const Image *image, const RectangleInfo *geometry, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ExtentImage(MemorySegment image, MemorySegment geometry, MemorySegment exception) {
        var mh$ = ExtentImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtentImage", image, geometry, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, geometry, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlattenImages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("FlattenImages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *FlattenImages(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor FlattenImages$descriptor() {
        return FlattenImages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *FlattenImages(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle FlattenImages$handle() {
        return FlattenImages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *FlattenImages(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment FlattenImages$address() {
        return FlattenImages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *FlattenImages(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment FlattenImages(MemorySegment image, MemorySegment exception) {
        var mh$ = FlattenImages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlattenImages", image, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlipImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("FlipImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *FlipImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor FlipImage$descriptor() {
        return FlipImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *FlipImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle FlipImage$handle() {
        return FlipImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *FlipImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment FlipImage$address() {
        return FlipImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *FlipImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment FlipImage(MemorySegment image, MemorySegment exception) {
        var mh$ = FlipImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlipImage", image, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlopImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("FlopImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *FlopImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor FlopImage$descriptor() {
        return FlopImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *FlopImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle FlopImage$handle() {
        return FlopImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *FlopImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment FlopImage$address() {
        return FlopImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *FlopImage(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment FlopImage(MemorySegment image, MemorySegment exception) {
        var mh$ = FlopImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlopImage", image, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MosaicImages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MosaicImages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *MosaicImages(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor MosaicImages$descriptor() {
        return MosaicImages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *MosaicImages(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle MosaicImages$handle() {
        return MosaicImages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *MosaicImages(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment MosaicImages$address() {
        return MosaicImages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *MosaicImages(const Image *image, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment MosaicImages(MemorySegment image, MemorySegment exception) {
        var mh$ = MosaicImages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MosaicImages", image, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RollImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("RollImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *RollImage(const Image *image, const long x_offset, const long y_offset, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor RollImage$descriptor() {
        return RollImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *RollImage(const Image *image, const long x_offset, const long y_offset, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle RollImage$handle() {
        return RollImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *RollImage(const Image *image, const long x_offset, const long y_offset, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment RollImage$address() {
        return RollImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *RollImage(const Image *image, const long x_offset, const long y_offset, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment RollImage(MemorySegment image, long x_offset, long y_offset, MemorySegment exception) {
        var mh$ = RollImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RollImage", image, x_offset, y_offset, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, x_offset, y_offset, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShaveImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ShaveImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Image *ShaveImage(const Image *image, const RectangleInfo *shave_info, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor ShaveImage$descriptor() {
        return ShaveImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Image *ShaveImage(const Image *image, const RectangleInfo *shave_info, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle ShaveImage$handle() {
        return ShaveImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Image *ShaveImage(const Image *image, const RectangleInfo *shave_info, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ShaveImage$address() {
        return ShaveImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Image *ShaveImage(const Image *image, const RectangleInfo *shave_info, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment ShaveImage(MemorySegment image, MemorySegment shave_info, MemorySegment exception) {
        var mh$ = ShaveImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShaveImage", image, shave_info, exception);
            }
            return (MemorySegment)mh$.invokeExact(image, shave_info, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransformImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("TransformImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int TransformImage(Image **, const char *, const char *)
     * }
     */
    public static FunctionDescriptor TransformImage$descriptor() {
        return TransformImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int TransformImage(Image **, const char *, const char *)
     * }
     */
    public static MethodHandle TransformImage$handle() {
        return TransformImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int TransformImage(Image **, const char *, const char *)
     * }
     */
    public static MemorySegment TransformImage$address() {
        return TransformImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int TransformImage(Image **, const char *, const char *)
     * }
     */
    public static int TransformImage(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = TransformImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransformImage", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int RootPath = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.RootPath = 0
     * }
     */
    public static int RootPath() {
        return RootPath;
    }
    private static final int HeadPath = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HeadPath = 1
     * }
     */
    public static int HeadPath() {
        return HeadPath;
    }
    private static final int TailPath = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TailPath = 2
     * }
     */
    public static int TailPath() {
        return TailPath;
    }
    private static final int BasePath = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BasePath = 3
     * }
     */
    public static int BasePath() {
        return BasePath;
    }
    private static final int ExtensionPath = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ExtensionPath = 4
     * }
     */
    public static int ExtensionPath() {
        return ExtensionPath;
    }
    private static final int MagickPath = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MagickPath = 5
     * }
     */
    public static int MagickPath() {
        return MagickPath;
    }
    private static final int SubImagePath = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SubImagePath = 6
     * }
     */
    public static int SubImagePath() {
        return SubImagePath;
    }
    private static final int FullPath = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FullPath = 7
     * }
     */
    public static int FullPath() {
        return FullPath;
    }

    private static class AcquireString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AcquireString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *AcquireString(const char *)
     * }
     */
    public static FunctionDescriptor AcquireString$descriptor() {
        return AcquireString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *AcquireString(const char *)
     * }
     */
    public static MethodHandle AcquireString$handle() {
        return AcquireString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *AcquireString(const char *)
     * }
     */
    public static MemorySegment AcquireString$address() {
        return AcquireString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *AcquireString(const char *)
     * }
     */
    public static MemorySegment AcquireString(MemorySegment x0) {
        var mh$ = AcquireString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AllocateString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *AllocateString(const char *)
     * }
     */
    public static FunctionDescriptor AllocateString$descriptor() {
        return AllocateString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *AllocateString(const char *)
     * }
     */
    public static MethodHandle AllocateString$handle() {
        return AllocateString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *AllocateString(const char *)
     * }
     */
    public static MemorySegment AllocateString$address() {
        return AllocateString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *AllocateString(const char *)
     * }
     */
    public static MemorySegment AllocateString(MemorySegment x0) {
        var mh$ = AllocateString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Base64Encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("Base64Encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *Base64Encode(const unsigned char *, const size_t, size_t *)
     * }
     */
    public static FunctionDescriptor Base64Encode$descriptor() {
        return Base64Encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *Base64Encode(const unsigned char *, const size_t, size_t *)
     * }
     */
    public static MethodHandle Base64Encode$handle() {
        return Base64Encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *Base64Encode(const unsigned char *, const size_t, size_t *)
     * }
     */
    public static MemorySegment Base64Encode$address() {
        return Base64Encode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *Base64Encode(const unsigned char *, const size_t, size_t *)
     * }
     */
    public static MemorySegment Base64Encode(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = Base64Encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Base64Encode", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EscapeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_CHAR
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("EscapeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *EscapeString(const char *, const char)
     * }
     */
    public static FunctionDescriptor EscapeString$descriptor() {
        return EscapeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *EscapeString(const char *, const char)
     * }
     */
    public static MethodHandle EscapeString$handle() {
        return EscapeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *EscapeString(const char *, const char)
     * }
     */
    public static MemorySegment EscapeString$address() {
        return EscapeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *EscapeString(const char *, const char)
     * }
     */
    public static MemorySegment EscapeString(MemorySegment x0, byte x1) {
        var mh$ = EscapeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EscapeString", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPageGeometry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetPageGeometry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *GetPageGeometry(const char *)
     * }
     */
    public static FunctionDescriptor GetPageGeometry$descriptor() {
        return GetPageGeometry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *GetPageGeometry(const char *)
     * }
     */
    public static MethodHandle GetPageGeometry$handle() {
        return GetPageGeometry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *GetPageGeometry(const char *)
     * }
     */
    public static MemorySegment GetPageGeometry$address() {
        return GetPageGeometry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *GetPageGeometry(const char *)
     * }
     */
    public static MemorySegment GetPageGeometry(MemorySegment x0) {
        var mh$ = GetPageGeometry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPageGeometry", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ListFiles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ListFiles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char **ListFiles(const char *, const char *, long *)
     * }
     */
    public static FunctionDescriptor ListFiles$descriptor() {
        return ListFiles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char **ListFiles(const char *, const char *, long *)
     * }
     */
    public static MethodHandle ListFiles$handle() {
        return ListFiles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char **ListFiles(const char *, const char *, long *)
     * }
     */
    public static MemorySegment ListFiles$address() {
        return ListFiles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char **ListFiles(const char *, const char *, long *)
     * }
     */
    public static MemorySegment ListFiles(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = ListFiles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ListFiles", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToArgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToArgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char **StringToArgv(const char *, int *)
     * }
     */
    public static FunctionDescriptor StringToArgv$descriptor() {
        return StringToArgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char **StringToArgv(const char *, int *)
     * }
     */
    public static MethodHandle StringToArgv$handle() {
        return StringToArgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char **StringToArgv(const char *, int *)
     * }
     */
    public static MemorySegment StringToArgv$address() {
        return StringToArgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char **StringToArgv(const char *, int *)
     * }
     */
    public static MemorySegment StringToArgv(MemorySegment x0, MemorySegment x1) {
        var mh$ = StringToArgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToArgv", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char **StringToList(const char *)
     * }
     */
    public static FunctionDescriptor StringToList$descriptor() {
        return StringToList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char **StringToList(const char *)
     * }
     */
    public static MethodHandle StringToList$handle() {
        return StringToList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char **StringToList(const char *)
     * }
     */
    public static MemorySegment StringToList$address() {
        return StringToList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char **StringToList(const char *)
     * }
     */
    public static MemorySegment StringToList(MemorySegment x0) {
        var mh$ = StringToList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToList", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("TranslateText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *TranslateText(const ImageInfo *, Image *, const char *)
     * }
     */
    public static FunctionDescriptor TranslateText$descriptor() {
        return TranslateText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *TranslateText(const ImageInfo *, Image *, const char *)
     * }
     */
    public static MethodHandle TranslateText$handle() {
        return TranslateText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *TranslateText(const ImageInfo *, Image *, const char *)
     * }
     */
    public static MemorySegment TranslateText$address() {
        return TranslateText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *TranslateText(const ImageInfo *, Image *, const char *)
     * }
     */
    public static MemorySegment TranslateText(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = TranslateText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateText", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateTextEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("TranslateTextEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *TranslateTextEx(const ImageInfo *, Image *, const char *, MagickTextTranslate)
     * }
     */
    public static FunctionDescriptor TranslateTextEx$descriptor() {
        return TranslateTextEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *TranslateTextEx(const ImageInfo *, Image *, const char *, MagickTextTranslate)
     * }
     */
    public static MethodHandle TranslateTextEx$handle() {
        return TranslateTextEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *TranslateTextEx(const ImageInfo *, Image *, const char *, MagickTextTranslate)
     * }
     */
    public static MemorySegment TranslateTextEx$address() {
        return TranslateTextEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *TranslateTextEx(const ImageInfo *, Image *, const char *, MagickTextTranslate)
     * }
     */
    public static MemorySegment TranslateTextEx(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TranslateTextEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateTextEx", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClientFilename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetClientFilename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *GetClientFilename()
     * }
     */
    public static FunctionDescriptor GetClientFilename$descriptor() {
        return GetClientFilename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *GetClientFilename()
     * }
     */
    public static MethodHandle GetClientFilename$handle() {
        return GetClientFilename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *GetClientFilename()
     * }
     */
    public static MemorySegment GetClientFilename$address() {
        return GetClientFilename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *GetClientFilename()
     * }
     */
    public static MemorySegment GetClientFilename() {
        var mh$ = GetClientFilename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClientFilename");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClientName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetClientName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *GetClientName()
     * }
     */
    public static FunctionDescriptor GetClientName$descriptor() {
        return GetClientName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *GetClientName()
     * }
     */
    public static MethodHandle GetClientName$handle() {
        return GetClientName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *GetClientName()
     * }
     */
    public static MemorySegment GetClientName$address() {
        return GetClientName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *GetClientName()
     * }
     */
    public static MemorySegment GetClientName() {
        var mh$ = GetClientName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClientName");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClientPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetClientPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *GetClientPath()
     * }
     */
    public static FunctionDescriptor GetClientPath$descriptor() {
        return GetClientPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *GetClientPath()
     * }
     */
    public static MethodHandle GetClientPath$handle() {
        return GetClientPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *GetClientPath()
     * }
     */
    public static MemorySegment GetClientPath$address() {
        return GetClientPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *GetClientPath()
     * }
     */
    public static MemorySegment GetClientPath() {
        var mh$ = GetClientPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClientPath");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClientFilename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetClientFilename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *SetClientFilename(const char *)
     * }
     */
    public static FunctionDescriptor SetClientFilename$descriptor() {
        return SetClientFilename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *SetClientFilename(const char *)
     * }
     */
    public static MethodHandle SetClientFilename$handle() {
        return SetClientFilename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *SetClientFilename(const char *)
     * }
     */
    public static MemorySegment SetClientFilename$address() {
        return SetClientFilename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *SetClientFilename(const char *)
     * }
     */
    public static MemorySegment SetClientFilename(MemorySegment x0) {
        var mh$ = SetClientFilename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClientFilename", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClientName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetClientName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *SetClientName(const char *)
     * }
     */
    public static FunctionDescriptor SetClientName$descriptor() {
        return SetClientName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *SetClientName(const char *)
     * }
     */
    public static MethodHandle SetClientName$handle() {
        return SetClientName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *SetClientName(const char *)
     * }
     */
    public static MemorySegment SetClientName$address() {
        return SetClientName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *SetClientName(const char *)
     * }
     */
    public static MemorySegment SetClientName(MemorySegment x0) {
        var mh$ = SetClientName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClientName", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClientPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetClientPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *SetClientPath(const char *)
     * }
     */
    public static FunctionDescriptor SetClientPath$descriptor() {
        return SetClientPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *SetClientPath(const char *)
     * }
     */
    public static MethodHandle SetClientPath$handle() {
        return SetClientPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *SetClientPath(const char *)
     * }
     */
    public static MemorySegment SetClientPath$address() {
        return SetClientPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *SetClientPath(const char *)
     * }
     */
    public static MemorySegment SetClientPath(MemorySegment x0) {
        var mh$ = SetClientPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClientPath", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StringToDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("StringToDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double StringToDouble(const char *, const double)
     * }
     */
    public static FunctionDescriptor StringToDouble$descriptor() {
        return StringToDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double StringToDouble(const char *, const double)
     * }
     */
    public static MethodHandle StringToDouble$handle() {
        return StringToDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double StringToDouble(const char *, const double)
     * }
     */
    public static MemorySegment StringToDouble$address() {
        return StringToDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double StringToDouble(const char *, const double)
     * }
     */
    public static double StringToDouble(MemorySegment x0, double x1) {
        var mh$ = StringToDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StringToDouble", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGeometry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetGeometry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int GetGeometry(const char *, long *, long *, unsigned long *, unsigned long *)
     * }
     */
    public static FunctionDescriptor GetGeometry$descriptor() {
        return GetGeometry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int GetGeometry(const char *, long *, long *, unsigned long *, unsigned long *)
     * }
     */
    public static MethodHandle GetGeometry$handle() {
        return GetGeometry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int GetGeometry(const char *, long *, long *, unsigned long *, unsigned long *)
     * }
     */
    public static MemorySegment GetGeometry$address() {
        return GetGeometry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int GetGeometry(const char *, long *, long *, unsigned long *, unsigned long *)
     * }
     */
    public static int GetGeometry(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = GetGeometry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGeometry", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobExpression {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GlobExpression");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int GlobExpression(const char *, const char *)
     * }
     */
    public static FunctionDescriptor GlobExpression$descriptor() {
        return GlobExpression.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int GlobExpression(const char *, const char *)
     * }
     */
    public static MethodHandle GlobExpression$handle() {
        return GlobExpression.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int GlobExpression(const char *, const char *)
     * }
     */
    public static MemorySegment GlobExpression$address() {
        return GlobExpression.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int GlobExpression(const char *, const char *)
     * }
     */
    public static int GlobExpression(MemorySegment x0, MemorySegment x1) {
        var mh$ = GlobExpression.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobExpression", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocaleNCompare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("LocaleNCompare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int LocaleNCompare(const char *, const char *, const size_t)
     * }
     */
    public static FunctionDescriptor LocaleNCompare$descriptor() {
        return LocaleNCompare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int LocaleNCompare(const char *, const char *, const size_t)
     * }
     */
    public static MethodHandle LocaleNCompare$handle() {
        return LocaleNCompare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int LocaleNCompare(const char *, const char *, const size_t)
     * }
     */
    public static MemorySegment LocaleNCompare$address() {
        return LocaleNCompare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int LocaleNCompare(const char *, const char *, const size_t)
     * }
     */
    public static int LocaleNCompare(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = LocaleNCompare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocaleNCompare", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocaleCompare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("LocaleCompare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int LocaleCompare(const char *, const char *)
     * }
     */
    public static FunctionDescriptor LocaleCompare$descriptor() {
        return LocaleCompare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int LocaleCompare(const char *, const char *)
     * }
     */
    public static MethodHandle LocaleCompare$handle() {
        return LocaleCompare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int LocaleCompare(const char *, const char *)
     * }
     */
    public static MemorySegment LocaleCompare$address() {
        return LocaleCompare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int LocaleCompare(const char *, const char *)
     * }
     */
    public static int LocaleCompare(MemorySegment x0, MemorySegment x1) {
        var mh$ = LocaleCompare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocaleCompare", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMagickDimension {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetMagickDimension");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int GetMagickDimension(const char *str, double *width, double *height, double *xoff, double *yoff)
     * }
     */
    public static FunctionDescriptor GetMagickDimension$descriptor() {
        return GetMagickDimension.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int GetMagickDimension(const char *str, double *width, double *height, double *xoff, double *yoff)
     * }
     */
    public static MethodHandle GetMagickDimension$handle() {
        return GetMagickDimension.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int GetMagickDimension(const char *str, double *width, double *height, double *xoff, double *yoff)
     * }
     */
    public static MemorySegment GetMagickDimension$address() {
        return GetMagickDimension.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int GetMagickDimension(const char *str, double *width, double *height, double *xoff, double *yoff)
     * }
     */
    public static int GetMagickDimension(MemorySegment str, MemorySegment width, MemorySegment height, MemorySegment xoff, MemorySegment yoff) {
        var mh$ = GetMagickDimension.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMagickDimension", str, width, height, xoff, yoff);
            }
            return (int)mh$.invokeExact(str, width, height, xoff, yoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMagickGeometry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetMagickGeometry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int GetMagickGeometry(const char *geometry, long *x, long *y, unsigned long *width, unsigned long *height)
     * }
     */
    public static FunctionDescriptor GetMagickGeometry$descriptor() {
        return GetMagickGeometry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int GetMagickGeometry(const char *geometry, long *x, long *y, unsigned long *width, unsigned long *height)
     * }
     */
    public static MethodHandle GetMagickGeometry$handle() {
        return GetMagickGeometry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int GetMagickGeometry(const char *geometry, long *x, long *y, unsigned long *width, unsigned long *height)
     * }
     */
    public static MemorySegment GetMagickGeometry$address() {
        return GetMagickGeometry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int GetMagickGeometry(const char *geometry, long *x, long *y, unsigned long *width, unsigned long *height)
     * }
     */
    public static int GetMagickGeometry(MemorySegment geometry, MemorySegment x, MemorySegment y, MemorySegment width, MemorySegment height) {
        var mh$ = GetMagickGeometry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMagickGeometry", geometry, x, y, width, height);
            }
            return (int)mh$.invokeExact(geometry, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickRandReentrant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickRandReentrant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int MagickRandReentrant(unsigned int *seed)
     * }
     */
    public static FunctionDescriptor MagickRandReentrant$descriptor() {
        return MagickRandReentrant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int MagickRandReentrant(unsigned int *seed)
     * }
     */
    public static MethodHandle MagickRandReentrant$handle() {
        return MagickRandReentrant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int MagickRandReentrant(unsigned int *seed)
     * }
     */
    public static MemorySegment MagickRandReentrant$address() {
        return MagickRandReentrant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int MagickRandReentrant(unsigned int *seed)
     * }
     */
    public static int MagickRandReentrant(MemorySegment seed) {
        var mh$ = MagickRandReentrant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickRandReentrant", seed);
            }
            return (int)mh$.invokeExact(seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickSpawnVP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickSpawnVP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int MagickSpawnVP(const unsigned int verbose, const char *file, char *const argv[])
     * }
     */
    public static FunctionDescriptor MagickSpawnVP$descriptor() {
        return MagickSpawnVP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int MagickSpawnVP(const unsigned int verbose, const char *file, char *const argv[])
     * }
     */
    public static MethodHandle MagickSpawnVP$handle() {
        return MagickSpawnVP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int MagickSpawnVP(const unsigned int verbose, const char *file, char *const argv[])
     * }
     */
    public static MemorySegment MagickSpawnVP$address() {
        return MagickSpawnVP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int MagickSpawnVP(const unsigned int verbose, const char *file, char *const argv[])
     * }
     */
    public static int MagickSpawnVP(int verbose, MemorySegment file, MemorySegment argv) {
        var mh$ = MagickSpawnVP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickSpawnVP", verbose, file, argv);
            }
            return (int)mh$.invokeExact(verbose, file, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SystemCommand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SystemCommand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int SystemCommand(const unsigned int, const char *)
     * }
     */
    public static FunctionDescriptor SystemCommand$descriptor() {
        return SystemCommand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int SystemCommand(const unsigned int, const char *)
     * }
     */
    public static MethodHandle SystemCommand$handle() {
        return SystemCommand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int SystemCommand(const unsigned int, const char *)
     * }
     */
    public static MemorySegment SystemCommand$address() {
        return SystemCommand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int SystemCommand(const unsigned int, const char *)
     * }
     */
    public static int SystemCommand(int x0, MemorySegment x1) {
        var mh$ = SystemCommand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SystemCommand", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Tokenizer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_CHAR,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("Tokenizer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int Tokenizer(TokenInfo *, unsigned int, char *, size_t, char *, char *, char *, char *, char, char *, int *, char *)
     * }
     */
    public static FunctionDescriptor Tokenizer$descriptor() {
        return Tokenizer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int Tokenizer(TokenInfo *, unsigned int, char *, size_t, char *, char *, char *, char *, char, char *, int *, char *)
     * }
     */
    public static MethodHandle Tokenizer$handle() {
        return Tokenizer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int Tokenizer(TokenInfo *, unsigned int, char *, size_t, char *, char *, char *, char *, char, char *, int *, char *)
     * }
     */
    public static MemorySegment Tokenizer$address() {
        return Tokenizer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int Tokenizer(TokenInfo *, unsigned int, char *, size_t, char *, char *, char *, char *, char, char *, int *, char *)
     * }
     */
    public static int Tokenizer(MemorySegment x0, int x1, MemorySegment x2, long x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, byte x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = Tokenizer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Tokenizer", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickRandNewSeed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickRandNewSeed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MagickRandNewSeed()
     * }
     */
    public static FunctionDescriptor MagickRandNewSeed$descriptor() {
        return MagickRandNewSeed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MagickRandNewSeed()
     * }
     */
    public static MethodHandle MagickRandNewSeed$handle() {
        return MagickRandNewSeed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MagickRandNewSeed()
     * }
     */
    public static MemorySegment MagickRandNewSeed$address() {
        return MagickRandNewSeed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MagickRandNewSeed()
     * }
     */
    public static int MagickRandNewSeed() {
        var mh$ = MagickRandNewSeed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickRandNewSeed");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Base64Decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("Base64Decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned char *Base64Decode(const char *, size_t *)
     * }
     */
    public static FunctionDescriptor Base64Decode$descriptor() {
        return Base64Decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned char *Base64Decode(const char *, size_t *)
     * }
     */
    public static MethodHandle Base64Decode$handle() {
        return Base64Decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned char *Base64Decode(const char *, size_t *)
     * }
     */
    public static MemorySegment Base64Decode$address() {
        return Base64Decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned char *Base64Decode(const char *, size_t *)
     * }
     */
    public static MemorySegment Base64Decode(MemorySegment x0, MemorySegment x1) {
        var mh$ = Base64Decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Base64Decode", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloneString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CloneString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int CloneString(char **, const char *)
     * }
     */
    public static FunctionDescriptor CloneString$descriptor() {
        return CloneString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int CloneString(char **, const char *)
     * }
     */
    public static MethodHandle CloneString$handle() {
        return CloneString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int CloneString(char **, const char *)
     * }
     */
    public static MemorySegment CloneString$address() {
        return CloneString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int CloneString(char **, const char *)
     * }
     */
    public static int CloneString(MemorySegment x0, MemorySegment x1) {
        var mh$ = CloneString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloneString", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConcatenateString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ConcatenateString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ConcatenateString(char **, const char *)
     * }
     */
    public static FunctionDescriptor ConcatenateString$descriptor() {
        return ConcatenateString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ConcatenateString(char **, const char *)
     * }
     */
    public static MethodHandle ConcatenateString$handle() {
        return ConcatenateString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ConcatenateString(char **, const char *)
     * }
     */
    public static MemorySegment ConcatenateString$address() {
        return ConcatenateString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ConcatenateString(char **, const char *)
     * }
     */
    public static int ConcatenateString(MemorySegment x0, MemorySegment x1) {
        var mh$ = ConcatenateString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConcatenateString", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExpandFilenames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ExpandFilenames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int ExpandFilenames(int *, char ***)
     * }
     */
    public static FunctionDescriptor ExpandFilenames$descriptor() {
        return ExpandFilenames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int ExpandFilenames(int *, char ***)
     * }
     */
    public static MethodHandle ExpandFilenames$handle() {
        return ExpandFilenames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int ExpandFilenames(int *, char ***)
     * }
     */
    public static MemorySegment ExpandFilenames$address() {
        return ExpandFilenames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int ExpandFilenames(int *, char ***)
     * }
     */
    public static int ExpandFilenames(MemorySegment x0, MemorySegment x1) {
        var mh$ = ExpandFilenames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExpandFilenames", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetExecutionPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetExecutionPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int GetExecutionPath(char *)
     * }
     */
    public static FunctionDescriptor GetExecutionPath$descriptor() {
        return GetExecutionPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int GetExecutionPath(char *)
     * }
     */
    public static MethodHandle GetExecutionPath$handle() {
        return GetExecutionPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int GetExecutionPath(char *)
     * }
     */
    public static MemorySegment GetExecutionPath$address() {
        return GetExecutionPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int GetExecutionPath(char *)
     * }
     */
    public static int GetExecutionPath(MemorySegment x0) {
        var mh$ = GetExecutionPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetExecutionPath", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetExecutionPathUsingName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetExecutionPathUsingName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int GetExecutionPathUsingName(char *)
     * }
     */
    public static FunctionDescriptor GetExecutionPathUsingName$descriptor() {
        return GetExecutionPathUsingName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int GetExecutionPathUsingName(char *)
     * }
     */
    public static MethodHandle GetExecutionPathUsingName$handle() {
        return GetExecutionPathUsingName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int GetExecutionPathUsingName(char *)
     * }
     */
    public static MemorySegment GetExecutionPathUsingName$address() {
        return GetExecutionPathUsingName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int GetExecutionPathUsingName(char *)
     * }
     */
    public static int GetExecutionPathUsingName(MemorySegment x0) {
        var mh$ = GetExecutionPathUsingName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetExecutionPathUsingName", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickCreateDirectoryPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickCreateDirectoryPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MagickCreateDirectoryPath(const char *dir, ExceptionInfo *exception)
     * }
     */
    public static FunctionDescriptor MagickCreateDirectoryPath$descriptor() {
        return MagickCreateDirectoryPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MagickCreateDirectoryPath(const char *dir, ExceptionInfo *exception)
     * }
     */
    public static MethodHandle MagickCreateDirectoryPath$handle() {
        return MagickCreateDirectoryPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MagickCreateDirectoryPath(const char *dir, ExceptionInfo *exception)
     * }
     */
    public static MemorySegment MagickCreateDirectoryPath$address() {
        return MagickCreateDirectoryPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MagickCreateDirectoryPath(const char *dir, ExceptionInfo *exception)
     * }
     */
    public static int MagickCreateDirectoryPath(MemorySegment dir, MemorySegment exception) {
        var mh$ = MagickCreateDirectoryPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickCreateDirectoryPath", dir, exception);
            }
            return (int)mh$.invokeExact(dir, exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsAccessible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IsAccessible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IsAccessible(const char *)
     * }
     */
    public static FunctionDescriptor IsAccessible$descriptor() {
        return IsAccessible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IsAccessible(const char *)
     * }
     */
    public static MethodHandle IsAccessible$handle() {
        return IsAccessible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IsAccessible(const char *)
     * }
     */
    public static MemorySegment IsAccessible$address() {
        return IsAccessible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IsAccessible(const char *)
     * }
     */
    public static int IsAccessible(MemorySegment x0) {
        var mh$ = IsAccessible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsAccessible", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsAccessibleNoLogging {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IsAccessibleNoLogging");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IsAccessibleNoLogging(const char *)
     * }
     */
    public static FunctionDescriptor IsAccessibleNoLogging$descriptor() {
        return IsAccessibleNoLogging.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IsAccessibleNoLogging(const char *)
     * }
     */
    public static MethodHandle IsAccessibleNoLogging$handle() {
        return IsAccessibleNoLogging.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IsAccessibleNoLogging(const char *)
     * }
     */
    public static MemorySegment IsAccessibleNoLogging$address() {
        return IsAccessibleNoLogging.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IsAccessibleNoLogging(const char *)
     * }
     */
    public static int IsAccessibleNoLogging(MemorySegment x0) {
        var mh$ = IsAccessibleNoLogging.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsAccessibleNoLogging", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsAccessibleAndNotEmpty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IsAccessibleAndNotEmpty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IsAccessibleAndNotEmpty(const char *)
     * }
     */
    public static FunctionDescriptor IsAccessibleAndNotEmpty$descriptor() {
        return IsAccessibleAndNotEmpty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IsAccessibleAndNotEmpty(const char *)
     * }
     */
    public static MethodHandle IsAccessibleAndNotEmpty$handle() {
        return IsAccessibleAndNotEmpty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IsAccessibleAndNotEmpty(const char *)
     * }
     */
    public static MemorySegment IsAccessibleAndNotEmpty$address() {
        return IsAccessibleAndNotEmpty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IsAccessibleAndNotEmpty(const char *)
     * }
     */
    public static int IsAccessibleAndNotEmpty(MemorySegment x0) {
        var mh$ = IsAccessibleAndNotEmpty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsAccessibleAndNotEmpty", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsGeometry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IsGeometry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IsGeometry(const char *)
     * }
     */
    public static FunctionDescriptor IsGeometry$descriptor() {
        return IsGeometry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IsGeometry(const char *)
     * }
     */
    public static MethodHandle IsGeometry$handle() {
        return IsGeometry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IsGeometry(const char *)
     * }
     */
    public static MemorySegment IsGeometry$address() {
        return IsGeometry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IsGeometry(const char *)
     * }
     */
    public static int IsGeometry(MemorySegment x0) {
        var mh$ = IsGeometry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsGeometry", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsGlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IsGlob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IsGlob(const char *)
     * }
     */
    public static FunctionDescriptor IsGlob$descriptor() {
        return IsGlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IsGlob(const char *)
     * }
     */
    public static MethodHandle IsGlob$handle() {
        return IsGlob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IsGlob(const char *)
     * }
     */
    public static MemorySegment IsGlob$address() {
        return IsGlob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IsGlob(const char *)
     * }
     */
    public static int IsGlob(MemorySegment x0) {
        var mh$ = IsGlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsGlob", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWriteable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("IsWriteable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int IsWriteable(const char *)
     * }
     */
    public static FunctionDescriptor IsWriteable$descriptor() {
        return IsWriteable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int IsWriteable(const char *)
     * }
     */
    public static MethodHandle IsWriteable$handle() {
        return IsWriteable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int IsWriteable(const char *)
     * }
     */
    public static MemorySegment IsWriteable$address() {
        return IsWriteable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int IsWriteable(const char *)
     * }
     */
    public static int IsWriteable(MemorySegment x0) {
        var mh$ = IsWriteable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWriteable", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickSceneFileName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickSceneFileName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MagickSceneFileName(char *filename, const char *filename_template, const char *scene_template, const unsigned int force, unsigned long scene)
     * }
     */
    public static FunctionDescriptor MagickSceneFileName$descriptor() {
        return MagickSceneFileName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MagickSceneFileName(char *filename, const char *filename_template, const char *scene_template, const unsigned int force, unsigned long scene)
     * }
     */
    public static MethodHandle MagickSceneFileName$handle() {
        return MagickSceneFileName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MagickSceneFileName(char *filename, const char *filename_template, const char *scene_template, const unsigned int force, unsigned long scene)
     * }
     */
    public static MemorySegment MagickSceneFileName$address() {
        return MagickSceneFileName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MagickSceneFileName(char *filename, const char *filename_template, const char *scene_template, const unsigned int force, unsigned long scene)
     * }
     */
    public static int MagickSceneFileName(MemorySegment filename, MemorySegment filename_template, MemorySegment scene_template, int force, long scene) {
        var mh$ = MagickSceneFileName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickSceneFileName", filename, filename_template, scene_template, force, scene);
            }
            return (int)mh$.invokeExact(filename, filename_template, scene_template, force, scene);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SubstituteString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SubstituteString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int SubstituteString(char **buffer, const char *search, const char *replace)
     * }
     */
    public static FunctionDescriptor SubstituteString$descriptor() {
        return SubstituteString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int SubstituteString(char **buffer, const char *search, const char *replace)
     * }
     */
    public static MethodHandle SubstituteString$handle() {
        return SubstituteString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int SubstituteString(char **buffer, const char *search, const char *replace)
     * }
     */
    public static MemorySegment SubstituteString$address() {
        return SubstituteString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int SubstituteString(char **buffer, const char *search, const char *replace)
     * }
     */
    public static int SubstituteString(MemorySegment buffer, MemorySegment search, MemorySegment replace) {
        var mh$ = SubstituteString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SubstituteString", buffer, search, replace);
            }
            return (int)mh$.invokeExact(buffer, search, replace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MultilineCensus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MultilineCensus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long MultilineCensus(const char *)
     * }
     */
    public static FunctionDescriptor MultilineCensus$descriptor() {
        return MultilineCensus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long MultilineCensus(const char *)
     * }
     */
    public static MethodHandle MultilineCensus$handle() {
        return MultilineCensus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long MultilineCensus(const char *)
     * }
     */
    public static MemorySegment MultilineCensus$address() {
        return MultilineCensus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long MultilineCensus(const char *)
     * }
     */
    public static long MultilineCensus(MemorySegment x0) {
        var mh$ = MultilineCensus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MultilineCensus", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AppendImageFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("AppendImageFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void AppendImageFormat(const char *, char *)
     * }
     */
    public static FunctionDescriptor AppendImageFormat$descriptor() {
        return AppendImageFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void AppendImageFormat(const char *, char *)
     * }
     */
    public static MethodHandle AppendImageFormat$handle() {
        return AppendImageFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void AppendImageFormat(const char *, char *)
     * }
     */
    public static MemorySegment AppendImageFormat$address() {
        return AppendImageFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void AppendImageFormat(const char *, char *)
     * }
     */
    public static void AppendImageFormat(MemorySegment x0, MemorySegment x1) {
        var mh$ = AppendImageFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AppendImageFormat", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefineClientName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DefineClientName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DefineClientName(const char *)
     * }
     */
    public static FunctionDescriptor DefineClientName$descriptor() {
        return DefineClientName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DefineClientName(const char *)
     * }
     */
    public static MethodHandle DefineClientName$handle() {
        return DefineClientName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DefineClientName(const char *)
     * }
     */
    public static MemorySegment DefineClientName$address() {
        return DefineClientName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DefineClientName(const char *)
     * }
     */
    public static void DefineClientName(MemorySegment x0) {
        var mh$ = DefineClientName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefineClientName", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefineClientPathAndName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DefineClientPathAndName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DefineClientPathAndName(const char *)
     * }
     */
    public static FunctionDescriptor DefineClientPathAndName$descriptor() {
        return DefineClientPathAndName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DefineClientPathAndName(const char *)
     * }
     */
    public static MethodHandle DefineClientPathAndName$handle() {
        return DefineClientPathAndName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DefineClientPathAndName(const char *)
     * }
     */
    public static MemorySegment DefineClientPathAndName$address() {
        return DefineClientPathAndName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DefineClientPathAndName(const char *)
     * }
     */
    public static void DefineClientPathAndName(MemorySegment x0) {
        var mh$ = DefineClientPathAndName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefineClientPathAndName", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExpandFilename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ExpandFilename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ExpandFilename(char *)
     * }
     */
    public static FunctionDescriptor ExpandFilename$descriptor() {
        return ExpandFilename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ExpandFilename(char *)
     * }
     */
    public static MethodHandle ExpandFilename$handle() {
        return ExpandFilename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ExpandFilename(char *)
     * }
     */
    public static MemorySegment ExpandFilename$address() {
        return ExpandFilename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ExpandFilename(char *)
     * }
     */
    public static void ExpandFilename(MemorySegment x0) {
        var mh$ = ExpandFilename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExpandFilename", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FormatSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("FormatSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void FormatSize(const magick_int64_t size, char *format)
     * }
     */
    public static FunctionDescriptor FormatSize$descriptor() {
        return FormatSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void FormatSize(const magick_int64_t size, char *format)
     * }
     */
    public static MethodHandle FormatSize$handle() {
        return FormatSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void FormatSize(const magick_int64_t size, char *format)
     * }
     */
    public static MemorySegment FormatSize$address() {
        return FormatSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void FormatSize(const magick_int64_t size, char *format)
     * }
     */
    public static void FormatSize(long size, MemorySegment format) {
        var mh$ = FormatSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FormatSize", size, format);
            }
            mh$.invokeExact(size, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPathComponent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetPathComponent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void GetPathComponent(const char *, PathType, char *)
     * }
     */
    public static FunctionDescriptor GetPathComponent$descriptor() {
        return GetPathComponent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void GetPathComponent(const char *, PathType, char *)
     * }
     */
    public static MethodHandle GetPathComponent$handle() {
        return GetPathComponent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void GetPathComponent(const char *, PathType, char *)
     * }
     */
    public static MemorySegment GetPathComponent$address() {
        return GetPathComponent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void GetPathComponent(const char *, PathType, char *)
     * }
     */
    public static void GetPathComponent(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = GetPathComponent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPathComponent", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetToken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void GetToken(const char *, char **, char *)
     * }
     */
    public static FunctionDescriptor GetToken$descriptor() {
        return GetToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void GetToken(const char *, char **, char *)
     * }
     */
    public static MethodHandle GetToken$handle() {
        return GetToken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void GetToken(const char *, char **, char *)
     * }
     */
    public static MemorySegment GetToken$address() {
        return GetToken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void GetToken(const char *, char **, char *)
     * }
     */
    public static void GetToken(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = GetToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetToken", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocaleLower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("LocaleLower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void LocaleLower(char *)
     * }
     */
    public static FunctionDescriptor LocaleLower$descriptor() {
        return LocaleLower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void LocaleLower(char *)
     * }
     */
    public static MethodHandle LocaleLower$handle() {
        return LocaleLower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void LocaleLower(char *)
     * }
     */
    public static MemorySegment LocaleLower$address() {
        return LocaleLower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void LocaleLower(char *)
     * }
     */
    public static void LocaleLower(MemorySegment x0) {
        var mh$ = LocaleLower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocaleLower", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocaleUpper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("LocaleUpper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void LocaleUpper(char *)
     * }
     */
    public static FunctionDescriptor LocaleUpper$descriptor() {
        return LocaleUpper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void LocaleUpper(char *)
     * }
     */
    public static MethodHandle LocaleUpper$handle() {
        return LocaleUpper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void LocaleUpper(char *)
     * }
     */
    public static MemorySegment LocaleUpper$address() {
        return LocaleUpper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void LocaleUpper(char *)
     * }
     */
    public static void LocaleUpper(MemorySegment x0) {
        var mh$ = LocaleUpper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocaleUpper", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Strip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("Strip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void Strip(char *)
     * }
     */
    public static FunctionDescriptor Strip$descriptor() {
        return Strip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void Strip(char *)
     * }
     */
    public static MethodHandle Strip$handle() {
        return Strip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void Strip(char *)
     * }
     */
    public static MemorySegment Strip$address() {
        return Strip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void Strip(char *)
     * }
     */
    public static void Strip(MemorySegment x0) {
        var mh$ = Strip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Strip", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetGeometry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("SetGeometry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void SetGeometry(const Image *, RectangleInfo *)
     * }
     */
    public static FunctionDescriptor SetGeometry$descriptor() {
        return SetGeometry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void SetGeometry(const Image *, RectangleInfo *)
     * }
     */
    public static MethodHandle SetGeometry$handle() {
        return SetGeometry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void SetGeometry(const Image *, RectangleInfo *)
     * }
     */
    public static MemorySegment SetGeometry$address() {
        return SetGeometry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void SetGeometry(const Image *, RectangleInfo *)
     * }
     */
    public static void SetGeometry(MemorySegment x0, MemorySegment x1) {
        var mh$ = SetGeometry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetGeometry", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern size_t FormatString(char *string, const char *format, ...)
     * }
     */
    public static class FormatString {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                magick_wand_h.C_LONG,
                magick_wand_h.C_POINTER,
                magick_wand_h.C_POINTER
            );
        private static final MemorySegment ADDR = magick_wand_h.findOrThrow("FormatString");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private FormatString(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern size_t FormatString(char *string, const char *format, ...)
         * }
         */
        public static FormatString makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new FormatString(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(MemorySegment string, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("FormatString", string, format, x2);
                }
                return (long) spreader.invokeExact(string, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class FormatStringList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("FormatStringList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t FormatStringList(char *string, const char *format, va_list operands)
     * }
     */
    public static FunctionDescriptor FormatStringList$descriptor() {
        return FormatStringList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t FormatStringList(char *string, const char *format, va_list operands)
     * }
     */
    public static MethodHandle FormatStringList$handle() {
        return FormatStringList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t FormatStringList(char *string, const char *format, va_list operands)
     * }
     */
    public static MemorySegment FormatStringList$address() {
        return FormatStringList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t FormatStringList(char *string, const char *format, va_list operands)
     * }
     */
    public static long FormatStringList(MemorySegment string, MemorySegment format, MemorySegment operands) {
        var mh$ = FormatStringList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FormatStringList", string, format, operands);
            }
            return (long)mh$.invokeExact(string, format, operands);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern size_t MagickFormatString(char *string, const size_t length, const char *format, ...)
     * }
     */
    public static class MagickFormatString {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                magick_wand_h.C_LONG,
                magick_wand_h.C_POINTER,
                magick_wand_h.C_LONG,
                magick_wand_h.C_POINTER
            );
        private static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickFormatString");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private MagickFormatString(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern size_t MagickFormatString(char *string, const size_t length, const char *format, ...)
         * }
         */
        public static MagickFormatString makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new MagickFormatString(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(MemorySegment string, long length, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("MagickFormatString", string, length, format, x3);
                }
                return (long) spreader.invokeExact(string, length, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class MagickFormatStringList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickFormatStringList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t MagickFormatStringList(char *string, const size_t length, const char *format, va_list operands)
     * }
     */
    public static FunctionDescriptor MagickFormatStringList$descriptor() {
        return MagickFormatStringList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t MagickFormatStringList(char *string, const size_t length, const char *format, va_list operands)
     * }
     */
    public static MethodHandle MagickFormatStringList$handle() {
        return MagickFormatStringList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t MagickFormatStringList(char *string, const size_t length, const char *format, va_list operands)
     * }
     */
    public static MemorySegment MagickFormatStringList$address() {
        return MagickFormatStringList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t MagickFormatStringList(char *string, const size_t length, const char *format, va_list operands)
     * }
     */
    public static long MagickFormatStringList(MemorySegment string, long length, MemorySegment format, MemorySegment operands) {
        var mh$ = MagickFormatStringList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickFormatStringList", string, length, format, operands);
            }
            return (long)mh$.invokeExact(string, length, format, operands);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickSizeStrToInt64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickSizeStrToInt64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern magick_int64_t MagickSizeStrToInt64(const char *str, const unsigned int kilo)
     * }
     */
    public static FunctionDescriptor MagickSizeStrToInt64$descriptor() {
        return MagickSizeStrToInt64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern magick_int64_t MagickSizeStrToInt64(const char *str, const unsigned int kilo)
     * }
     */
    public static MethodHandle MagickSizeStrToInt64$handle() {
        return MagickSizeStrToInt64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern magick_int64_t MagickSizeStrToInt64(const char *str, const unsigned int kilo)
     * }
     */
    public static MemorySegment MagickSizeStrToInt64$address() {
        return MagickSizeStrToInt64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern magick_int64_t MagickSizeStrToInt64(const char *str, const unsigned int kilo)
     * }
     */
    public static long MagickSizeStrToInt64(MemorySegment str, int kilo) {
        var mh$ = MagickSizeStrToInt64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickSizeStrToInt64", str, kilo);
            }
            return (long)mh$.invokeExact(str, kilo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetToken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t MagickGetToken(const char *start, char **end, char *token, const size_t buffer_length)
     * }
     */
    public static FunctionDescriptor MagickGetToken$descriptor() {
        return MagickGetToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t MagickGetToken(const char *start, char **end, char *token, const size_t buffer_length)
     * }
     */
    public static MethodHandle MagickGetToken$handle() {
        return MagickGetToken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t MagickGetToken(const char *start, char **end, char *token, const size_t buffer_length)
     * }
     */
    public static MemorySegment MagickGetToken$address() {
        return MagickGetToken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t MagickGetToken(const char *start, char **end, char *token, const size_t buffer_length)
     * }
     */
    public static long MagickGetToken(MemorySegment start, MemorySegment end, MemorySegment token, long buffer_length) {
        var mh$ = MagickGetToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetToken", start, end, token, buffer_length);
            }
            return (long)mh$.invokeExact(start, end, token, buffer_length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickStrlCat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickStrlCat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t MagickStrlCat(char *dst, const char *src, const size_t size)
     * }
     */
    public static FunctionDescriptor MagickStrlCat$descriptor() {
        return MagickStrlCat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t MagickStrlCat(char *dst, const char *src, const size_t size)
     * }
     */
    public static MethodHandle MagickStrlCat$handle() {
        return MagickStrlCat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t MagickStrlCat(char *dst, const char *src, const size_t size)
     * }
     */
    public static MemorySegment MagickStrlCat$address() {
        return MagickStrlCat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t MagickStrlCat(char *dst, const char *src, const size_t size)
     * }
     */
    public static long MagickStrlCat(MemorySegment dst, MemorySegment src, long size) {
        var mh$ = MagickStrlCat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickStrlCat", dst, src, size);
            }
            return (long)mh$.invokeExact(dst, src, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickStrlCpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickStrlCpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t MagickStrlCpy(char *dst, const char *src, const size_t size)
     * }
     */
    public static FunctionDescriptor MagickStrlCpy$descriptor() {
        return MagickStrlCpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t MagickStrlCpy(char *dst, const char *src, const size_t size)
     * }
     */
    public static MethodHandle MagickStrlCpy$handle() {
        return MagickStrlCpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t MagickStrlCpy(char *dst, const char *src, const size_t size)
     * }
     */
    public static MemorySegment MagickStrlCpy$address() {
        return MagickStrlCpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t MagickStrlCpy(char *dst, const char *src, const size_t size)
     * }
     */
    public static long MagickStrlCpy(MemorySegment dst, MemorySegment src, long size) {
        var mh$ = MagickStrlCpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickStrlCpy", dst, src, size);
            }
            return (long)mh$.invokeExact(dst, src, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickStrlCpyTrunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickStrlCpyTrunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t MagickStrlCpyTrunc(char *dst, const char *src, const size_t size)
     * }
     */
    public static FunctionDescriptor MagickStrlCpyTrunc$descriptor() {
        return MagickStrlCpyTrunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t MagickStrlCpyTrunc(char *dst, const char *src, const size_t size)
     * }
     */
    public static MethodHandle MagickStrlCpyTrunc$handle() {
        return MagickStrlCpyTrunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t MagickStrlCpyTrunc(char *dst, const char *src, const size_t size)
     * }
     */
    public static MemorySegment MagickStrlCpyTrunc$address() {
        return MagickStrlCpyTrunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t MagickStrlCpyTrunc(char *dst, const char *src, const size_t size)
     * }
     */
    public static long MagickStrlCpyTrunc(MemorySegment dst, MemorySegment src, long size) {
        var mh$ = MagickStrlCpyTrunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickStrlCpyTrunc", dst, src, size);
            }
            return (long)mh$.invokeExact(dst, src, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMagickCopyright {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetMagickCopyright");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *GetMagickCopyright()
     * }
     */
    public static FunctionDescriptor GetMagickCopyright$descriptor() {
        return GetMagickCopyright.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *GetMagickCopyright()
     * }
     */
    public static MethodHandle GetMagickCopyright$handle() {
        return GetMagickCopyright.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *GetMagickCopyright()
     * }
     */
    public static MemorySegment GetMagickCopyright$address() {
        return GetMagickCopyright.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *GetMagickCopyright()
     * }
     */
    public static MemorySegment GetMagickCopyright() {
        var mh$ = GetMagickCopyright.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMagickCopyright");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMagickVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetMagickVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *GetMagickVersion(unsigned long *)
     * }
     */
    public static FunctionDescriptor GetMagickVersion$descriptor() {
        return GetMagickVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *GetMagickVersion(unsigned long *)
     * }
     */
    public static MethodHandle GetMagickVersion$handle() {
        return GetMagickVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *GetMagickVersion(unsigned long *)
     * }
     */
    public static MemorySegment GetMagickVersion$address() {
        return GetMagickVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *GetMagickVersion(unsigned long *)
     * }
     */
    public static MemorySegment GetMagickVersion(MemorySegment x0) {
        var mh$ = GetMagickVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMagickVersion", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMagickWebSite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("GetMagickWebSite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *GetMagickWebSite()
     * }
     */
    public static FunctionDescriptor GetMagickWebSite$descriptor() {
        return GetMagickWebSite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *GetMagickWebSite()
     * }
     */
    public static MethodHandle GetMagickWebSite$handle() {
        return GetMagickWebSite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *GetMagickWebSite()
     * }
     */
    public static MemorySegment GetMagickWebSite$address() {
        return GetMagickWebSite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *GetMagickWebSite()
     * }
     */
    public static MemorySegment GetMagickWebSite() {
        var mh$ = GetMagickWebSite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMagickWebSite");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetColorAsString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetColorAsString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *PixelGetColorAsString(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetColorAsString$descriptor() {
        return PixelGetColorAsString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *PixelGetColorAsString(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetColorAsString$handle() {
        return PixelGetColorAsString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *PixelGetColorAsString(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetColorAsString$address() {
        return PixelGetColorAsString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *PixelGetColorAsString(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetColorAsString(MemorySegment x0) {
        var mh$ = PixelGetColorAsString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetColorAsString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetBlack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetBlack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double PixelGetBlack(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetBlack$descriptor() {
        return PixelGetBlack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double PixelGetBlack(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetBlack$handle() {
        return PixelGetBlack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double PixelGetBlack(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetBlack$address() {
        return PixelGetBlack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double PixelGetBlack(const PixelWand *)
     * }
     */
    public static double PixelGetBlack(MemorySegment x0) {
        var mh$ = PixelGetBlack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetBlack", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetBlue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetBlue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double PixelGetBlue(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetBlue$descriptor() {
        return PixelGetBlue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double PixelGetBlue(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetBlue$handle() {
        return PixelGetBlue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double PixelGetBlue(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetBlue$address() {
        return PixelGetBlue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double PixelGetBlue(const PixelWand *)
     * }
     */
    public static double PixelGetBlue(MemorySegment x0) {
        var mh$ = PixelGetBlue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetBlue", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetCyan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetCyan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double PixelGetCyan(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetCyan$descriptor() {
        return PixelGetCyan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double PixelGetCyan(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetCyan$handle() {
        return PixelGetCyan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double PixelGetCyan(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetCyan$address() {
        return PixelGetCyan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double PixelGetCyan(const PixelWand *)
     * }
     */
    public static double PixelGetCyan(MemorySegment x0) {
        var mh$ = PixelGetCyan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetCyan", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetGreen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetGreen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double PixelGetGreen(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetGreen$descriptor() {
        return PixelGetGreen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double PixelGetGreen(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetGreen$handle() {
        return PixelGetGreen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double PixelGetGreen(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetGreen$address() {
        return PixelGetGreen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double PixelGetGreen(const PixelWand *)
     * }
     */
    public static double PixelGetGreen(MemorySegment x0) {
        var mh$ = PixelGetGreen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetGreen", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetMagenta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetMagenta");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double PixelGetMagenta(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetMagenta$descriptor() {
        return PixelGetMagenta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double PixelGetMagenta(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetMagenta$handle() {
        return PixelGetMagenta.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double PixelGetMagenta(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetMagenta$address() {
        return PixelGetMagenta.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double PixelGetMagenta(const PixelWand *)
     * }
     */
    public static double PixelGetMagenta(MemorySegment x0) {
        var mh$ = PixelGetMagenta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetMagenta", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetOpacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetOpacity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double PixelGetOpacity(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetOpacity$descriptor() {
        return PixelGetOpacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double PixelGetOpacity(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetOpacity$handle() {
        return PixelGetOpacity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double PixelGetOpacity(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetOpacity$address() {
        return PixelGetOpacity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double PixelGetOpacity(const PixelWand *)
     * }
     */
    public static double PixelGetOpacity(MemorySegment x0) {
        var mh$ = PixelGetOpacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetOpacity", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetRed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetRed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double PixelGetRed(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetRed$descriptor() {
        return PixelGetRed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double PixelGetRed(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetRed$handle() {
        return PixelGetRed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double PixelGetRed(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetRed$address() {
        return PixelGetRed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double PixelGetRed(const PixelWand *)
     * }
     */
    public static double PixelGetRed(MemorySegment x0) {
        var mh$ = PixelGetRed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetRed", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetYellow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetYellow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double PixelGetYellow(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetYellow$descriptor() {
        return PixelGetYellow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double PixelGetYellow(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetYellow$handle() {
        return PixelGetYellow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double PixelGetYellow(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetYellow$address() {
        return PixelGetYellow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double PixelGetYellow(const PixelWand *)
     * }
     */
    public static double PixelGetYellow(MemorySegment x0) {
        var mh$ = PixelGetYellow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetYellow", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClonePixelWand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ClonePixelWand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelWand *ClonePixelWand(const PixelWand *)
     * }
     */
    public static FunctionDescriptor ClonePixelWand$descriptor() {
        return ClonePixelWand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelWand *ClonePixelWand(const PixelWand *)
     * }
     */
    public static MethodHandle ClonePixelWand$handle() {
        return ClonePixelWand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelWand *ClonePixelWand(const PixelWand *)
     * }
     */
    public static MemorySegment ClonePixelWand$address() {
        return ClonePixelWand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelWand *ClonePixelWand(const PixelWand *)
     * }
     */
    public static MemorySegment ClonePixelWand(MemorySegment x0) {
        var mh$ = ClonePixelWand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClonePixelWand", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClonePixelWands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("ClonePixelWands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelWand **ClonePixelWands(const PixelWand **, const unsigned long)
     * }
     */
    public static FunctionDescriptor ClonePixelWands$descriptor() {
        return ClonePixelWands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelWand **ClonePixelWands(const PixelWand **, const unsigned long)
     * }
     */
    public static MethodHandle ClonePixelWands$handle() {
        return ClonePixelWands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelWand **ClonePixelWands(const PixelWand **, const unsigned long)
     * }
     */
    public static MemorySegment ClonePixelWands$address() {
        return ClonePixelWands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelWand **ClonePixelWands(const PixelWand **, const unsigned long)
     * }
     */
    public static MemorySegment ClonePixelWands(MemorySegment x0, long x1) {
        var mh$ = ClonePixelWands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClonePixelWands", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NewPixelWand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("NewPixelWand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelWand *NewPixelWand()
     * }
     */
    public static FunctionDescriptor NewPixelWand$descriptor() {
        return NewPixelWand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelWand *NewPixelWand()
     * }
     */
    public static MethodHandle NewPixelWand$handle() {
        return NewPixelWand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelWand *NewPixelWand()
     * }
     */
    public static MemorySegment NewPixelWand$address() {
        return NewPixelWand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelWand *NewPixelWand()
     * }
     */
    public static MemorySegment NewPixelWand() {
        var mh$ = NewPixelWand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NewPixelWand");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NewPixelWands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("NewPixelWands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PixelWand **NewPixelWands(const unsigned long)
     * }
     */
    public static FunctionDescriptor NewPixelWands$descriptor() {
        return NewPixelWands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PixelWand **NewPixelWands(const unsigned long)
     * }
     */
    public static MethodHandle NewPixelWands$handle() {
        return NewPixelWands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PixelWand **NewPixelWands(const unsigned long)
     * }
     */
    public static MemorySegment NewPixelWands$address() {
        return NewPixelWands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PixelWand **NewPixelWands(const unsigned long)
     * }
     */
    public static MemorySegment NewPixelWands(long x0) {
        var mh$ = NewPixelWands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NewPixelWands", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetBlackQuantum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_SHORT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetBlackQuantum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Quantum PixelGetBlackQuantum(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetBlackQuantum$descriptor() {
        return PixelGetBlackQuantum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Quantum PixelGetBlackQuantum(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetBlackQuantum$handle() {
        return PixelGetBlackQuantum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Quantum PixelGetBlackQuantum(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetBlackQuantum$address() {
        return PixelGetBlackQuantum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Quantum PixelGetBlackQuantum(const PixelWand *)
     * }
     */
    public static short PixelGetBlackQuantum(MemorySegment x0) {
        var mh$ = PixelGetBlackQuantum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetBlackQuantum", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetBlueQuantum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_SHORT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetBlueQuantum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Quantum PixelGetBlueQuantum(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetBlueQuantum$descriptor() {
        return PixelGetBlueQuantum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Quantum PixelGetBlueQuantum(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetBlueQuantum$handle() {
        return PixelGetBlueQuantum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Quantum PixelGetBlueQuantum(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetBlueQuantum$address() {
        return PixelGetBlueQuantum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Quantum PixelGetBlueQuantum(const PixelWand *)
     * }
     */
    public static short PixelGetBlueQuantum(MemorySegment x0) {
        var mh$ = PixelGetBlueQuantum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetBlueQuantum", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetCyanQuantum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_SHORT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetCyanQuantum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Quantum PixelGetCyanQuantum(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetCyanQuantum$descriptor() {
        return PixelGetCyanQuantum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Quantum PixelGetCyanQuantum(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetCyanQuantum$handle() {
        return PixelGetCyanQuantum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Quantum PixelGetCyanQuantum(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetCyanQuantum$address() {
        return PixelGetCyanQuantum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Quantum PixelGetCyanQuantum(const PixelWand *)
     * }
     */
    public static short PixelGetCyanQuantum(MemorySegment x0) {
        var mh$ = PixelGetCyanQuantum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetCyanQuantum", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetGreenQuantum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_SHORT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetGreenQuantum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Quantum PixelGetGreenQuantum(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetGreenQuantum$descriptor() {
        return PixelGetGreenQuantum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Quantum PixelGetGreenQuantum(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetGreenQuantum$handle() {
        return PixelGetGreenQuantum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Quantum PixelGetGreenQuantum(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetGreenQuantum$address() {
        return PixelGetGreenQuantum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Quantum PixelGetGreenQuantum(const PixelWand *)
     * }
     */
    public static short PixelGetGreenQuantum(MemorySegment x0) {
        var mh$ = PixelGetGreenQuantum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetGreenQuantum", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetMagentaQuantum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_SHORT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetMagentaQuantum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Quantum PixelGetMagentaQuantum(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetMagentaQuantum$descriptor() {
        return PixelGetMagentaQuantum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Quantum PixelGetMagentaQuantum(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetMagentaQuantum$handle() {
        return PixelGetMagentaQuantum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Quantum PixelGetMagentaQuantum(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetMagentaQuantum$address() {
        return PixelGetMagentaQuantum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Quantum PixelGetMagentaQuantum(const PixelWand *)
     * }
     */
    public static short PixelGetMagentaQuantum(MemorySegment x0) {
        var mh$ = PixelGetMagentaQuantum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetMagentaQuantum", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetOpacityQuantum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_SHORT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetOpacityQuantum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Quantum PixelGetOpacityQuantum(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetOpacityQuantum$descriptor() {
        return PixelGetOpacityQuantum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Quantum PixelGetOpacityQuantum(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetOpacityQuantum$handle() {
        return PixelGetOpacityQuantum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Quantum PixelGetOpacityQuantum(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetOpacityQuantum$address() {
        return PixelGetOpacityQuantum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Quantum PixelGetOpacityQuantum(const PixelWand *)
     * }
     */
    public static short PixelGetOpacityQuantum(MemorySegment x0) {
        var mh$ = PixelGetOpacityQuantum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetOpacityQuantum", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetRedQuantum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_SHORT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetRedQuantum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Quantum PixelGetRedQuantum(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetRedQuantum$descriptor() {
        return PixelGetRedQuantum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Quantum PixelGetRedQuantum(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetRedQuantum$handle() {
        return PixelGetRedQuantum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Quantum PixelGetRedQuantum(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetRedQuantum$address() {
        return PixelGetRedQuantum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Quantum PixelGetRedQuantum(const PixelWand *)
     * }
     */
    public static short PixelGetRedQuantum(MemorySegment x0) {
        var mh$ = PixelGetRedQuantum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetRedQuantum", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetYellowQuantum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_SHORT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetYellowQuantum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Quantum PixelGetYellowQuantum(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetYellowQuantum$descriptor() {
        return PixelGetYellowQuantum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Quantum PixelGetYellowQuantum(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetYellowQuantum$handle() {
        return PixelGetYellowQuantum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Quantum PixelGetYellowQuantum(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetYellowQuantum$address() {
        return PixelGetYellowQuantum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Quantum PixelGetYellowQuantum(const PixelWand *)
     * }
     */
    public static short PixelGetYellowQuantum(MemorySegment x0) {
        var mh$ = PixelGetYellowQuantum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetYellowQuantum", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int PixelSetColor(PixelWand *, const char *)
     * }
     */
    public static FunctionDescriptor PixelSetColor$descriptor() {
        return PixelSetColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int PixelSetColor(PixelWand *, const char *)
     * }
     */
    public static MethodHandle PixelSetColor$handle() {
        return PixelSetColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int PixelSetColor(PixelWand *, const char *)
     * }
     */
    public static MemorySegment PixelSetColor$address() {
        return PixelSetColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int PixelSetColor(PixelWand *, const char *)
     * }
     */
    public static int PixelSetColor(MemorySegment x0, MemorySegment x1) {
        var mh$ = PixelSetColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetColor", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetColorCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetColorCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long PixelGetColorCount(const PixelWand *)
     * }
     */
    public static FunctionDescriptor PixelGetColorCount$descriptor() {
        return PixelGetColorCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long PixelGetColorCount(const PixelWand *)
     * }
     */
    public static MethodHandle PixelGetColorCount$handle() {
        return PixelGetColorCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long PixelGetColorCount(const PixelWand *)
     * }
     */
    public static MemorySegment PixelGetColorCount$address() {
        return PixelGetColorCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long PixelGetColorCount(const PixelWand *)
     * }
     */
    public static long PixelGetColorCount(MemorySegment x0) {
        var mh$ = PixelGetColorCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetColorCount", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyPixelWand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("DestroyPixelWand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DestroyPixelWand(PixelWand *)
     * }
     */
    public static FunctionDescriptor DestroyPixelWand$descriptor() {
        return DestroyPixelWand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DestroyPixelWand(PixelWand *)
     * }
     */
    public static MethodHandle DestroyPixelWand$handle() {
        return DestroyPixelWand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void DestroyPixelWand(PixelWand *)
     * }
     */
    public static MemorySegment DestroyPixelWand$address() {
        return DestroyPixelWand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void DestroyPixelWand(PixelWand *)
     * }
     */
    public static void DestroyPixelWand(MemorySegment x0) {
        var mh$ = DestroyPixelWand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyPixelWand", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelGetQuantumColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelGetQuantumColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelGetQuantumColor(const PixelWand *, PixelPacket *)
     * }
     */
    public static FunctionDescriptor PixelGetQuantumColor$descriptor() {
        return PixelGetQuantumColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelGetQuantumColor(const PixelWand *, PixelPacket *)
     * }
     */
    public static MethodHandle PixelGetQuantumColor$handle() {
        return PixelGetQuantumColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelGetQuantumColor(const PixelWand *, PixelPacket *)
     * }
     */
    public static MemorySegment PixelGetQuantumColor$address() {
        return PixelGetQuantumColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelGetQuantumColor(const PixelWand *, PixelPacket *)
     * }
     */
    public static void PixelGetQuantumColor(MemorySegment x0, MemorySegment x1) {
        var mh$ = PixelGetQuantumColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelGetQuantumColor", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetBlack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetBlack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetBlack(PixelWand *, const double)
     * }
     */
    public static FunctionDescriptor PixelSetBlack$descriptor() {
        return PixelSetBlack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetBlack(PixelWand *, const double)
     * }
     */
    public static MethodHandle PixelSetBlack$handle() {
        return PixelSetBlack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetBlack(PixelWand *, const double)
     * }
     */
    public static MemorySegment PixelSetBlack$address() {
        return PixelSetBlack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetBlack(PixelWand *, const double)
     * }
     */
    public static void PixelSetBlack(MemorySegment x0, double x1) {
        var mh$ = PixelSetBlack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetBlack", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetBlackQuantum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_SHORT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetBlackQuantum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetBlackQuantum(PixelWand *, const Quantum)
     * }
     */
    public static FunctionDescriptor PixelSetBlackQuantum$descriptor() {
        return PixelSetBlackQuantum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetBlackQuantum(PixelWand *, const Quantum)
     * }
     */
    public static MethodHandle PixelSetBlackQuantum$handle() {
        return PixelSetBlackQuantum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetBlackQuantum(PixelWand *, const Quantum)
     * }
     */
    public static MemorySegment PixelSetBlackQuantum$address() {
        return PixelSetBlackQuantum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetBlackQuantum(PixelWand *, const Quantum)
     * }
     */
    public static void PixelSetBlackQuantum(MemorySegment x0, short x1) {
        var mh$ = PixelSetBlackQuantum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetBlackQuantum", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetBlue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetBlue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetBlue(PixelWand *, const double)
     * }
     */
    public static FunctionDescriptor PixelSetBlue$descriptor() {
        return PixelSetBlue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetBlue(PixelWand *, const double)
     * }
     */
    public static MethodHandle PixelSetBlue$handle() {
        return PixelSetBlue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetBlue(PixelWand *, const double)
     * }
     */
    public static MemorySegment PixelSetBlue$address() {
        return PixelSetBlue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetBlue(PixelWand *, const double)
     * }
     */
    public static void PixelSetBlue(MemorySegment x0, double x1) {
        var mh$ = PixelSetBlue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetBlue", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetBlueQuantum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_SHORT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetBlueQuantum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetBlueQuantum(PixelWand *, const Quantum)
     * }
     */
    public static FunctionDescriptor PixelSetBlueQuantum$descriptor() {
        return PixelSetBlueQuantum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetBlueQuantum(PixelWand *, const Quantum)
     * }
     */
    public static MethodHandle PixelSetBlueQuantum$handle() {
        return PixelSetBlueQuantum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetBlueQuantum(PixelWand *, const Quantum)
     * }
     */
    public static MemorySegment PixelSetBlueQuantum$address() {
        return PixelSetBlueQuantum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetBlueQuantum(PixelWand *, const Quantum)
     * }
     */
    public static void PixelSetBlueQuantum(MemorySegment x0, short x1) {
        var mh$ = PixelSetBlueQuantum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetBlueQuantum", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetColorCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetColorCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetColorCount(PixelWand *, const unsigned long)
     * }
     */
    public static FunctionDescriptor PixelSetColorCount$descriptor() {
        return PixelSetColorCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetColorCount(PixelWand *, const unsigned long)
     * }
     */
    public static MethodHandle PixelSetColorCount$handle() {
        return PixelSetColorCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetColorCount(PixelWand *, const unsigned long)
     * }
     */
    public static MemorySegment PixelSetColorCount$address() {
        return PixelSetColorCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetColorCount(PixelWand *, const unsigned long)
     * }
     */
    public static void PixelSetColorCount(MemorySegment x0, long x1) {
        var mh$ = PixelSetColorCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetColorCount", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetCyan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetCyan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetCyan(PixelWand *, const double)
     * }
     */
    public static FunctionDescriptor PixelSetCyan$descriptor() {
        return PixelSetCyan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetCyan(PixelWand *, const double)
     * }
     */
    public static MethodHandle PixelSetCyan$handle() {
        return PixelSetCyan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetCyan(PixelWand *, const double)
     * }
     */
    public static MemorySegment PixelSetCyan$address() {
        return PixelSetCyan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetCyan(PixelWand *, const double)
     * }
     */
    public static void PixelSetCyan(MemorySegment x0, double x1) {
        var mh$ = PixelSetCyan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetCyan", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetCyanQuantum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_SHORT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetCyanQuantum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetCyanQuantum(PixelWand *, const Quantum)
     * }
     */
    public static FunctionDescriptor PixelSetCyanQuantum$descriptor() {
        return PixelSetCyanQuantum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetCyanQuantum(PixelWand *, const Quantum)
     * }
     */
    public static MethodHandle PixelSetCyanQuantum$handle() {
        return PixelSetCyanQuantum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetCyanQuantum(PixelWand *, const Quantum)
     * }
     */
    public static MemorySegment PixelSetCyanQuantum$address() {
        return PixelSetCyanQuantum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetCyanQuantum(PixelWand *, const Quantum)
     * }
     */
    public static void PixelSetCyanQuantum(MemorySegment x0, short x1) {
        var mh$ = PixelSetCyanQuantum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetCyanQuantum", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetGreen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetGreen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetGreen(PixelWand *, const double)
     * }
     */
    public static FunctionDescriptor PixelSetGreen$descriptor() {
        return PixelSetGreen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetGreen(PixelWand *, const double)
     * }
     */
    public static MethodHandle PixelSetGreen$handle() {
        return PixelSetGreen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetGreen(PixelWand *, const double)
     * }
     */
    public static MemorySegment PixelSetGreen$address() {
        return PixelSetGreen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetGreen(PixelWand *, const double)
     * }
     */
    public static void PixelSetGreen(MemorySegment x0, double x1) {
        var mh$ = PixelSetGreen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetGreen", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetGreenQuantum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_SHORT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetGreenQuantum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetGreenQuantum(PixelWand *, const Quantum)
     * }
     */
    public static FunctionDescriptor PixelSetGreenQuantum$descriptor() {
        return PixelSetGreenQuantum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetGreenQuantum(PixelWand *, const Quantum)
     * }
     */
    public static MethodHandle PixelSetGreenQuantum$handle() {
        return PixelSetGreenQuantum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetGreenQuantum(PixelWand *, const Quantum)
     * }
     */
    public static MemorySegment PixelSetGreenQuantum$address() {
        return PixelSetGreenQuantum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetGreenQuantum(PixelWand *, const Quantum)
     * }
     */
    public static void PixelSetGreenQuantum(MemorySegment x0, short x1) {
        var mh$ = PixelSetGreenQuantum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetGreenQuantum", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetMagenta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetMagenta");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetMagenta(PixelWand *, const double)
     * }
     */
    public static FunctionDescriptor PixelSetMagenta$descriptor() {
        return PixelSetMagenta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetMagenta(PixelWand *, const double)
     * }
     */
    public static MethodHandle PixelSetMagenta$handle() {
        return PixelSetMagenta.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetMagenta(PixelWand *, const double)
     * }
     */
    public static MemorySegment PixelSetMagenta$address() {
        return PixelSetMagenta.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetMagenta(PixelWand *, const double)
     * }
     */
    public static void PixelSetMagenta(MemorySegment x0, double x1) {
        var mh$ = PixelSetMagenta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetMagenta", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetMagentaQuantum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_SHORT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetMagentaQuantum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetMagentaQuantum(PixelWand *, const Quantum)
     * }
     */
    public static FunctionDescriptor PixelSetMagentaQuantum$descriptor() {
        return PixelSetMagentaQuantum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetMagentaQuantum(PixelWand *, const Quantum)
     * }
     */
    public static MethodHandle PixelSetMagentaQuantum$handle() {
        return PixelSetMagentaQuantum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetMagentaQuantum(PixelWand *, const Quantum)
     * }
     */
    public static MemorySegment PixelSetMagentaQuantum$address() {
        return PixelSetMagentaQuantum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetMagentaQuantum(PixelWand *, const Quantum)
     * }
     */
    public static void PixelSetMagentaQuantum(MemorySegment x0, short x1) {
        var mh$ = PixelSetMagentaQuantum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetMagentaQuantum", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetOpacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetOpacity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetOpacity(PixelWand *, const double)
     * }
     */
    public static FunctionDescriptor PixelSetOpacity$descriptor() {
        return PixelSetOpacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetOpacity(PixelWand *, const double)
     * }
     */
    public static MethodHandle PixelSetOpacity$handle() {
        return PixelSetOpacity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetOpacity(PixelWand *, const double)
     * }
     */
    public static MemorySegment PixelSetOpacity$address() {
        return PixelSetOpacity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetOpacity(PixelWand *, const double)
     * }
     */
    public static void PixelSetOpacity(MemorySegment x0, double x1) {
        var mh$ = PixelSetOpacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetOpacity", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetOpacityQuantum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_SHORT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetOpacityQuantum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetOpacityQuantum(PixelWand *, const Quantum)
     * }
     */
    public static FunctionDescriptor PixelSetOpacityQuantum$descriptor() {
        return PixelSetOpacityQuantum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetOpacityQuantum(PixelWand *, const Quantum)
     * }
     */
    public static MethodHandle PixelSetOpacityQuantum$handle() {
        return PixelSetOpacityQuantum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetOpacityQuantum(PixelWand *, const Quantum)
     * }
     */
    public static MemorySegment PixelSetOpacityQuantum$address() {
        return PixelSetOpacityQuantum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetOpacityQuantum(PixelWand *, const Quantum)
     * }
     */
    public static void PixelSetOpacityQuantum(MemorySegment x0, short x1) {
        var mh$ = PixelSetOpacityQuantum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetOpacityQuantum", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetQuantumColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetQuantumColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetQuantumColor(PixelWand *, const PixelPacket *)
     * }
     */
    public static FunctionDescriptor PixelSetQuantumColor$descriptor() {
        return PixelSetQuantumColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetQuantumColor(PixelWand *, const PixelPacket *)
     * }
     */
    public static MethodHandle PixelSetQuantumColor$handle() {
        return PixelSetQuantumColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetQuantumColor(PixelWand *, const PixelPacket *)
     * }
     */
    public static MemorySegment PixelSetQuantumColor$address() {
        return PixelSetQuantumColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetQuantumColor(PixelWand *, const PixelPacket *)
     * }
     */
    public static void PixelSetQuantumColor(MemorySegment x0, MemorySegment x1) {
        var mh$ = PixelSetQuantumColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetQuantumColor", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetRed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetRed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetRed(PixelWand *, const double)
     * }
     */
    public static FunctionDescriptor PixelSetRed$descriptor() {
        return PixelSetRed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetRed(PixelWand *, const double)
     * }
     */
    public static MethodHandle PixelSetRed$handle() {
        return PixelSetRed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetRed(PixelWand *, const double)
     * }
     */
    public static MemorySegment PixelSetRed$address() {
        return PixelSetRed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetRed(PixelWand *, const double)
     * }
     */
    public static void PixelSetRed(MemorySegment x0, double x1) {
        var mh$ = PixelSetRed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetRed", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetRedQuantum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_SHORT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetRedQuantum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetRedQuantum(PixelWand *, const Quantum)
     * }
     */
    public static FunctionDescriptor PixelSetRedQuantum$descriptor() {
        return PixelSetRedQuantum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetRedQuantum(PixelWand *, const Quantum)
     * }
     */
    public static MethodHandle PixelSetRedQuantum$handle() {
        return PixelSetRedQuantum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetRedQuantum(PixelWand *, const Quantum)
     * }
     */
    public static MemorySegment PixelSetRedQuantum$address() {
        return PixelSetRedQuantum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetRedQuantum(PixelWand *, const Quantum)
     * }
     */
    public static void PixelSetRedQuantum(MemorySegment x0, short x1) {
        var mh$ = PixelSetRedQuantum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetRedQuantum", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetYellow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetYellow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetYellow(PixelWand *, const double)
     * }
     */
    public static FunctionDescriptor PixelSetYellow$descriptor() {
        return PixelSetYellow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetYellow(PixelWand *, const double)
     * }
     */
    public static MethodHandle PixelSetYellow$handle() {
        return PixelSetYellow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetYellow(PixelWand *, const double)
     * }
     */
    public static MemorySegment PixelSetYellow$address() {
        return PixelSetYellow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetYellow(PixelWand *, const double)
     * }
     */
    public static void PixelSetYellow(MemorySegment x0, double x1) {
        var mh$ = PixelSetYellow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetYellow", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PixelSetYellowQuantum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_SHORT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("PixelSetYellowQuantum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void PixelSetYellowQuantum(PixelWand *, const Quantum)
     * }
     */
    public static FunctionDescriptor PixelSetYellowQuantum$descriptor() {
        return PixelSetYellowQuantum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void PixelSetYellowQuantum(PixelWand *, const Quantum)
     * }
     */
    public static MethodHandle PixelSetYellowQuantum$handle() {
        return PixelSetYellowQuantum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void PixelSetYellowQuantum(PixelWand *, const Quantum)
     * }
     */
    public static MemorySegment PixelSetYellowQuantum$address() {
        return PixelSetYellowQuantum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void PixelSetYellowQuantum(PixelWand *, const Quantum)
     * }
     */
    public static void PixelSetYellowQuantum(MemorySegment x0, short x1) {
        var mh$ = PixelSetYellowQuantum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PixelSetYellowQuantum", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetClipPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetClipPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *MagickDrawGetClipPath(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetClipPath$descriptor() {
        return MagickDrawGetClipPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *MagickDrawGetClipPath(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetClipPath$handle() {
        return MagickDrawGetClipPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *MagickDrawGetClipPath(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetClipPath$address() {
        return MagickDrawGetClipPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *MagickDrawGetClipPath(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetClipPath(MemorySegment x0) {
        var mh$ = MagickDrawGetClipPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetClipPath", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *MagickDrawGetException(const DrawingWand *, ExceptionType *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetException$descriptor() {
        return MagickDrawGetException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *MagickDrawGetException(const DrawingWand *, ExceptionType *)
     * }
     */
    public static MethodHandle MagickDrawGetException$handle() {
        return MagickDrawGetException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *MagickDrawGetException(const DrawingWand *, ExceptionType *)
     * }
     */
    public static MemorySegment MagickDrawGetException$address() {
        return MagickDrawGetException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *MagickDrawGetException(const DrawingWand *, ExceptionType *)
     * }
     */
    public static MemorySegment MagickDrawGetException(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawGetException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetException", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetFont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *MagickDrawGetFont(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetFont$descriptor() {
        return MagickDrawGetFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *MagickDrawGetFont(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetFont$handle() {
        return MagickDrawGetFont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *MagickDrawGetFont(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetFont$address() {
        return MagickDrawGetFont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *MagickDrawGetFont(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetFont(MemorySegment x0) {
        var mh$ = MagickDrawGetFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetFont", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetFontFamily {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetFontFamily");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *MagickDrawGetFontFamily(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetFontFamily$descriptor() {
        return MagickDrawGetFontFamily.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *MagickDrawGetFontFamily(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetFontFamily$handle() {
        return MagickDrawGetFontFamily.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *MagickDrawGetFontFamily(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetFontFamily$address() {
        return MagickDrawGetFontFamily.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *MagickDrawGetFontFamily(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetFontFamily(MemorySegment x0) {
        var mh$ = MagickDrawGetFontFamily.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetFontFamily", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetTextEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetTextEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *MagickDrawGetTextEncoding(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetTextEncoding$descriptor() {
        return MagickDrawGetTextEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *MagickDrawGetTextEncoding(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetTextEncoding$handle() {
        return MagickDrawGetTextEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *MagickDrawGetTextEncoding(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetTextEncoding$address() {
        return MagickDrawGetTextEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *MagickDrawGetTextEncoding(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetTextEncoding(MemorySegment x0) {
        var mh$ = MagickDrawGetTextEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetTextEncoding", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetClipUnits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetClipUnits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ClipPathUnits MagickDrawGetClipUnits(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetClipUnits$descriptor() {
        return MagickDrawGetClipUnits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ClipPathUnits MagickDrawGetClipUnits(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetClipUnits$handle() {
        return MagickDrawGetClipUnits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ClipPathUnits MagickDrawGetClipUnits(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetClipUnits$address() {
        return MagickDrawGetClipUnits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ClipPathUnits MagickDrawGetClipUnits(const DrawingWand *)
     * }
     */
    public static int MagickDrawGetClipUnits(MemorySegment x0) {
        var mh$ = MagickDrawGetClipUnits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetClipUnits", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetTextDecoration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetTextDecoration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern DecorationType MagickDrawGetTextDecoration(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetTextDecoration$descriptor() {
        return MagickDrawGetTextDecoration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern DecorationType MagickDrawGetTextDecoration(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetTextDecoration$handle() {
        return MagickDrawGetTextDecoration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern DecorationType MagickDrawGetTextDecoration(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetTextDecoration$address() {
        return MagickDrawGetTextDecoration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern DecorationType MagickDrawGetTextDecoration(const DrawingWand *)
     * }
     */
    public static int MagickDrawGetTextDecoration(MemorySegment x0) {
        var mh$ = MagickDrawGetTextDecoration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetTextDecoration", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetFillOpacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetFillOpacity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double MagickDrawGetFillOpacity(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetFillOpacity$descriptor() {
        return MagickDrawGetFillOpacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double MagickDrawGetFillOpacity(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetFillOpacity$handle() {
        return MagickDrawGetFillOpacity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double MagickDrawGetFillOpacity(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetFillOpacity$address() {
        return MagickDrawGetFillOpacity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double MagickDrawGetFillOpacity(const DrawingWand *)
     * }
     */
    public static double MagickDrawGetFillOpacity(MemorySegment x0) {
        var mh$ = MagickDrawGetFillOpacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetFillOpacity", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetFontSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetFontSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double MagickDrawGetFontSize(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetFontSize$descriptor() {
        return MagickDrawGetFontSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double MagickDrawGetFontSize(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetFontSize$handle() {
        return MagickDrawGetFontSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double MagickDrawGetFontSize(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetFontSize$address() {
        return MagickDrawGetFontSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double MagickDrawGetFontSize(const DrawingWand *)
     * }
     */
    public static double MagickDrawGetFontSize(MemorySegment x0) {
        var mh$ = MagickDrawGetFontSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetFontSize", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetStrokeDashArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetStrokeDashArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double *MagickDrawGetStrokeDashArray(const DrawingWand *, unsigned long *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetStrokeDashArray$descriptor() {
        return MagickDrawGetStrokeDashArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double *MagickDrawGetStrokeDashArray(const DrawingWand *, unsigned long *)
     * }
     */
    public static MethodHandle MagickDrawGetStrokeDashArray$handle() {
        return MagickDrawGetStrokeDashArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double *MagickDrawGetStrokeDashArray(const DrawingWand *, unsigned long *)
     * }
     */
    public static MemorySegment MagickDrawGetStrokeDashArray$address() {
        return MagickDrawGetStrokeDashArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double *MagickDrawGetStrokeDashArray(const DrawingWand *, unsigned long *)
     * }
     */
    public static MemorySegment MagickDrawGetStrokeDashArray(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawGetStrokeDashArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetStrokeDashArray", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetStrokeDashOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetStrokeDashOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double MagickDrawGetStrokeDashOffset(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetStrokeDashOffset$descriptor() {
        return MagickDrawGetStrokeDashOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double MagickDrawGetStrokeDashOffset(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetStrokeDashOffset$handle() {
        return MagickDrawGetStrokeDashOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double MagickDrawGetStrokeDashOffset(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetStrokeDashOffset$address() {
        return MagickDrawGetStrokeDashOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double MagickDrawGetStrokeDashOffset(const DrawingWand *)
     * }
     */
    public static double MagickDrawGetStrokeDashOffset(MemorySegment x0) {
        var mh$ = MagickDrawGetStrokeDashOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetStrokeDashOffset", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetStrokeOpacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetStrokeOpacity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double MagickDrawGetStrokeOpacity(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetStrokeOpacity$descriptor() {
        return MagickDrawGetStrokeOpacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double MagickDrawGetStrokeOpacity(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetStrokeOpacity$handle() {
        return MagickDrawGetStrokeOpacity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double MagickDrawGetStrokeOpacity(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetStrokeOpacity$address() {
        return MagickDrawGetStrokeOpacity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double MagickDrawGetStrokeOpacity(const DrawingWand *)
     * }
     */
    public static double MagickDrawGetStrokeOpacity(MemorySegment x0) {
        var mh$ = MagickDrawGetStrokeOpacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetStrokeOpacity", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetStrokeWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetStrokeWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double MagickDrawGetStrokeWidth(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetStrokeWidth$descriptor() {
        return MagickDrawGetStrokeWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double MagickDrawGetStrokeWidth(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetStrokeWidth$handle() {
        return MagickDrawGetStrokeWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double MagickDrawGetStrokeWidth(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetStrokeWidth$address() {
        return MagickDrawGetStrokeWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double MagickDrawGetStrokeWidth(const DrawingWand *)
     * }
     */
    public static double MagickDrawGetStrokeWidth(MemorySegment x0) {
        var mh$ = MagickDrawGetStrokeWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetStrokeWidth", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPeekGraphicContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPeekGraphicContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern DrawInfo *MagickDrawPeekGraphicContext(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawPeekGraphicContext$descriptor() {
        return MagickDrawPeekGraphicContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern DrawInfo *MagickDrawPeekGraphicContext(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawPeekGraphicContext$handle() {
        return MagickDrawPeekGraphicContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern DrawInfo *MagickDrawPeekGraphicContext(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawPeekGraphicContext$address() {
        return MagickDrawPeekGraphicContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern DrawInfo *MagickDrawPeekGraphicContext(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawPeekGraphicContext(MemorySegment x0) {
        var mh$ = MagickDrawPeekGraphicContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPeekGraphicContext", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickCloneDrawingWand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickCloneDrawingWand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern DrawingWand *MagickCloneDrawingWand(const DrawingWand *drawing_wand)
     * }
     */
    public static FunctionDescriptor MagickCloneDrawingWand$descriptor() {
        return MagickCloneDrawingWand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern DrawingWand *MagickCloneDrawingWand(const DrawingWand *drawing_wand)
     * }
     */
    public static MethodHandle MagickCloneDrawingWand$handle() {
        return MagickCloneDrawingWand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern DrawingWand *MagickCloneDrawingWand(const DrawingWand *drawing_wand)
     * }
     */
    public static MemorySegment MagickCloneDrawingWand$address() {
        return MagickCloneDrawingWand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern DrawingWand *MagickCloneDrawingWand(const DrawingWand *drawing_wand)
     * }
     */
    public static MemorySegment MagickCloneDrawingWand(MemorySegment drawing_wand) {
        var mh$ = MagickCloneDrawingWand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickCloneDrawingWand", drawing_wand);
            }
            return (MemorySegment)mh$.invokeExact(drawing_wand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawAllocateWand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawAllocateWand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern DrawingWand *MagickDrawAllocateWand(const DrawInfo *, Image *)
     * }
     */
    public static FunctionDescriptor MagickDrawAllocateWand$descriptor() {
        return MagickDrawAllocateWand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern DrawingWand *MagickDrawAllocateWand(const DrawInfo *, Image *)
     * }
     */
    public static MethodHandle MagickDrawAllocateWand$handle() {
        return MagickDrawAllocateWand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern DrawingWand *MagickDrawAllocateWand(const DrawInfo *, Image *)
     * }
     */
    public static MemorySegment MagickDrawAllocateWand$address() {
        return MagickDrawAllocateWand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern DrawingWand *MagickDrawAllocateWand(const DrawInfo *, Image *)
     * }
     */
    public static MemorySegment MagickDrawAllocateWand(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawAllocateWand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawAllocateWand", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickNewDrawingWand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickNewDrawingWand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern DrawingWand *MagickNewDrawingWand()
     * }
     */
    public static FunctionDescriptor MagickNewDrawingWand$descriptor() {
        return MagickNewDrawingWand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern DrawingWand *MagickNewDrawingWand()
     * }
     */
    public static MethodHandle MagickNewDrawingWand$handle() {
        return MagickNewDrawingWand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern DrawingWand *MagickNewDrawingWand()
     * }
     */
    public static MemorySegment MagickNewDrawingWand$address() {
        return MagickNewDrawingWand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern DrawingWand *MagickNewDrawingWand()
     * }
     */
    public static MemorySegment MagickNewDrawingWand() {
        var mh$ = MagickNewDrawingWand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickNewDrawingWand");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetClipRule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetClipRule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FillRule MagickDrawGetClipRule(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetClipRule$descriptor() {
        return MagickDrawGetClipRule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FillRule MagickDrawGetClipRule(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetClipRule$handle() {
        return MagickDrawGetClipRule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FillRule MagickDrawGetClipRule(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetClipRule$address() {
        return MagickDrawGetClipRule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FillRule MagickDrawGetClipRule(const DrawingWand *)
     * }
     */
    public static int MagickDrawGetClipRule(MemorySegment x0) {
        var mh$ = MagickDrawGetClipRule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetClipRule", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetFillRule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetFillRule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FillRule MagickDrawGetFillRule(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetFillRule$descriptor() {
        return MagickDrawGetFillRule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FillRule MagickDrawGetFillRule(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetFillRule$handle() {
        return MagickDrawGetFillRule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FillRule MagickDrawGetFillRule(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetFillRule$address() {
        return MagickDrawGetFillRule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FillRule MagickDrawGetFillRule(const DrawingWand *)
     * }
     */
    public static int MagickDrawGetFillRule(MemorySegment x0) {
        var mh$ = MagickDrawGetFillRule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetFillRule", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetGravity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetGravity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GravityType MagickDrawGetGravity(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetGravity$descriptor() {
        return MagickDrawGetGravity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GravityType MagickDrawGetGravity(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetGravity$handle() {
        return MagickDrawGetGravity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GravityType MagickDrawGetGravity(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetGravity$address() {
        return MagickDrawGetGravity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GravityType MagickDrawGetGravity(const DrawingWand *)
     * }
     */
    public static int MagickDrawGetGravity(MemorySegment x0) {
        var mh$ = MagickDrawGetGravity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetGravity", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetStrokeLineCap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetStrokeLineCap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern LineCap MagickDrawGetStrokeLineCap(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetStrokeLineCap$descriptor() {
        return MagickDrawGetStrokeLineCap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern LineCap MagickDrawGetStrokeLineCap(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetStrokeLineCap$handle() {
        return MagickDrawGetStrokeLineCap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern LineCap MagickDrawGetStrokeLineCap(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetStrokeLineCap$address() {
        return MagickDrawGetStrokeLineCap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern LineCap MagickDrawGetStrokeLineCap(const DrawingWand *)
     * }
     */
    public static int MagickDrawGetStrokeLineCap(MemorySegment x0) {
        var mh$ = MagickDrawGetStrokeLineCap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetStrokeLineCap", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetStrokeLineJoin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetStrokeLineJoin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern LineJoin MagickDrawGetStrokeLineJoin(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetStrokeLineJoin$descriptor() {
        return MagickDrawGetStrokeLineJoin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern LineJoin MagickDrawGetStrokeLineJoin(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetStrokeLineJoin$handle() {
        return MagickDrawGetStrokeLineJoin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern LineJoin MagickDrawGetStrokeLineJoin(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetStrokeLineJoin$address() {
        return MagickDrawGetStrokeLineJoin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern LineJoin MagickDrawGetStrokeLineJoin(const DrawingWand *)
     * }
     */
    public static int MagickDrawGetStrokeLineJoin(MemorySegment x0) {
        var mh$ = MagickDrawGetStrokeLineJoin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetStrokeLineJoin", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetFontStretch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetFontStretch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern StretchType MagickDrawGetFontStretch(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetFontStretch$descriptor() {
        return MagickDrawGetFontStretch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern StretchType MagickDrawGetFontStretch(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetFontStretch$handle() {
        return MagickDrawGetFontStretch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern StretchType MagickDrawGetFontStretch(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetFontStretch$address() {
        return MagickDrawGetFontStretch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern StretchType MagickDrawGetFontStretch(const DrawingWand *)
     * }
     */
    public static int MagickDrawGetFontStretch(MemorySegment x0) {
        var mh$ = MagickDrawGetFontStretch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetFontStretch", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetFontStyle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetFontStyle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern StyleType MagickDrawGetFontStyle(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetFontStyle$descriptor() {
        return MagickDrawGetFontStyle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern StyleType MagickDrawGetFontStyle(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetFontStyle$handle() {
        return MagickDrawGetFontStyle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern StyleType MagickDrawGetFontStyle(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetFontStyle$address() {
        return MagickDrawGetFontStyle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern StyleType MagickDrawGetFontStyle(const DrawingWand *)
     * }
     */
    public static int MagickDrawGetFontStyle(MemorySegment x0) {
        var mh$ = MagickDrawGetFontStyle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetFontStyle", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawClearException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawClearException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MagickDrawClearException(DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawClearException$descriptor() {
        return MagickDrawClearException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MagickDrawClearException(DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawClearException$handle() {
        return MagickDrawClearException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MagickDrawClearException(DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawClearException$address() {
        return MagickDrawClearException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MagickDrawClearException(DrawingWand *)
     * }
     */
    public static int MagickDrawClearException(MemorySegment x0) {
        var mh$ = MagickDrawClearException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawClearException", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetStrokeAntialias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetStrokeAntialias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MagickDrawGetStrokeAntialias(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetStrokeAntialias$descriptor() {
        return MagickDrawGetStrokeAntialias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MagickDrawGetStrokeAntialias(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetStrokeAntialias$handle() {
        return MagickDrawGetStrokeAntialias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MagickDrawGetStrokeAntialias(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetStrokeAntialias$address() {
        return MagickDrawGetStrokeAntialias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MagickDrawGetStrokeAntialias(const DrawingWand *)
     * }
     */
    public static int MagickDrawGetStrokeAntialias(MemorySegment x0) {
        var mh$ = MagickDrawGetStrokeAntialias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetStrokeAntialias", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetTextAntialias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetTextAntialias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MagickDrawGetTextAntialias(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetTextAntialias$descriptor() {
        return MagickDrawGetTextAntialias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MagickDrawGetTextAntialias(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetTextAntialias$handle() {
        return MagickDrawGetTextAntialias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MagickDrawGetTextAntialias(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetTextAntialias$address() {
        return MagickDrawGetTextAntialias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MagickDrawGetTextAntialias(const DrawingWand *)
     * }
     */
    public static int MagickDrawGetTextAntialias(MemorySegment x0) {
        var mh$ = MagickDrawGetTextAntialias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetTextAntialias", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawRender {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawRender");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int MagickDrawRender(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawRender$descriptor() {
        return MagickDrawRender.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int MagickDrawRender(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawRender$handle() {
        return MagickDrawRender.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int MagickDrawRender(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawRender$address() {
        return MagickDrawRender.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int MagickDrawRender(const DrawingWand *)
     * }
     */
    public static int MagickDrawRender(MemorySegment x0) {
        var mh$ = MagickDrawRender.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawRender", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetFontWeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetFontWeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long MagickDrawGetFontWeight(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetFontWeight$descriptor() {
        return MagickDrawGetFontWeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long MagickDrawGetFontWeight(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetFontWeight$handle() {
        return MagickDrawGetFontWeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long MagickDrawGetFontWeight(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetFontWeight$address() {
        return MagickDrawGetFontWeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long MagickDrawGetFontWeight(const DrawingWand *)
     * }
     */
    public static long MagickDrawGetFontWeight(MemorySegment x0) {
        var mh$ = MagickDrawGetFontWeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetFontWeight", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetStrokeMiterLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetStrokeMiterLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long MagickDrawGetStrokeMiterLimit(const DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetStrokeMiterLimit$descriptor() {
        return MagickDrawGetStrokeMiterLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long MagickDrawGetStrokeMiterLimit(const DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawGetStrokeMiterLimit$handle() {
        return MagickDrawGetStrokeMiterLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long MagickDrawGetStrokeMiterLimit(const DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawGetStrokeMiterLimit$address() {
        return MagickDrawGetStrokeMiterLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long MagickDrawGetStrokeMiterLimit(const DrawingWand *)
     * }
     */
    public static long MagickDrawGetStrokeMiterLimit(MemorySegment x0) {
        var mh$ = MagickDrawGetStrokeMiterLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetStrokeMiterLimit", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawAffine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawAffine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawAffine(DrawingWand *, const AffineMatrix *)
     * }
     */
    public static FunctionDescriptor MagickDrawAffine$descriptor() {
        return MagickDrawAffine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawAffine(DrawingWand *, const AffineMatrix *)
     * }
     */
    public static MethodHandle MagickDrawAffine$handle() {
        return MagickDrawAffine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawAffine(DrawingWand *, const AffineMatrix *)
     * }
     */
    public static MemorySegment MagickDrawAffine$address() {
        return MagickDrawAffine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawAffine(DrawingWand *, const AffineMatrix *)
     * }
     */
    public static void MagickDrawAffine(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawAffine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawAffine", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawAnnotation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawAnnotation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawAnnotation(DrawingWand *, const double, const double, const unsigned char *)
     * }
     */
    public static FunctionDescriptor MagickDrawAnnotation$descriptor() {
        return MagickDrawAnnotation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawAnnotation(DrawingWand *, const double, const double, const unsigned char *)
     * }
     */
    public static MethodHandle MagickDrawAnnotation$handle() {
        return MagickDrawAnnotation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawAnnotation(DrawingWand *, const double, const double, const unsigned char *)
     * }
     */
    public static MemorySegment MagickDrawAnnotation$address() {
        return MagickDrawAnnotation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawAnnotation(DrawingWand *, const double, const double, const unsigned char *)
     * }
     */
    public static void MagickDrawAnnotation(MemorySegment x0, double x1, double x2, MemorySegment x3) {
        var mh$ = MagickDrawAnnotation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawAnnotation", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawArc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawArc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawArc(DrawingWand *, const double, const double, const double, const double, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawArc$descriptor() {
        return MagickDrawArc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawArc(DrawingWand *, const double, const double, const double, const double, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawArc$handle() {
        return MagickDrawArc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawArc(DrawingWand *, const double, const double, const double, const double, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawArc$address() {
        return MagickDrawArc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawArc(DrawingWand *, const double, const double, const double, const double, const double, const double)
     * }
     */
    public static void MagickDrawArc(MemorySegment x0, double x1, double x2, double x3, double x4, double x5, double x6) {
        var mh$ = MagickDrawArc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawArc", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawBezier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawBezier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawBezier(DrawingWand *, const unsigned long, const PointInfo *)
     * }
     */
    public static FunctionDescriptor MagickDrawBezier$descriptor() {
        return MagickDrawBezier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawBezier(DrawingWand *, const unsigned long, const PointInfo *)
     * }
     */
    public static MethodHandle MagickDrawBezier$handle() {
        return MagickDrawBezier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawBezier(DrawingWand *, const unsigned long, const PointInfo *)
     * }
     */
    public static MemorySegment MagickDrawBezier$address() {
        return MagickDrawBezier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawBezier(DrawingWand *, const unsigned long, const PointInfo *)
     * }
     */
    public static void MagickDrawBezier(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = MagickDrawBezier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawBezier", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawCircle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawCircle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawCircle(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawCircle$descriptor() {
        return MagickDrawCircle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawCircle(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawCircle$handle() {
        return MagickDrawCircle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawCircle(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawCircle$address() {
        return MagickDrawCircle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawCircle(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static void MagickDrawCircle(MemorySegment x0, double x1, double x2, double x3, double x4) {
        var mh$ = MagickDrawCircle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawCircle", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawColor(DrawingWand *, const double, const double, const PaintMethod)
     * }
     */
    public static FunctionDescriptor MagickDrawColor$descriptor() {
        return MagickDrawColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawColor(DrawingWand *, const double, const double, const PaintMethod)
     * }
     */
    public static MethodHandle MagickDrawColor$handle() {
        return MagickDrawColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawColor(DrawingWand *, const double, const double, const PaintMethod)
     * }
     */
    public static MemorySegment MagickDrawColor$address() {
        return MagickDrawColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawColor(DrawingWand *, const double, const double, const PaintMethod)
     * }
     */
    public static void MagickDrawColor(MemorySegment x0, double x1, double x2, int x3) {
        var mh$ = MagickDrawColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawColor", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawComment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawComment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawComment(DrawingWand *, const char *)
     * }
     */
    public static FunctionDescriptor MagickDrawComment$descriptor() {
        return MagickDrawComment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawComment(DrawingWand *, const char *)
     * }
     */
    public static MethodHandle MagickDrawComment$handle() {
        return MagickDrawComment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawComment(DrawingWand *, const char *)
     * }
     */
    public static MemorySegment MagickDrawComment$address() {
        return MagickDrawComment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawComment(DrawingWand *, const char *)
     * }
     */
    public static void MagickDrawComment(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawComment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawComment", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDestroyDrawingWand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDestroyDrawingWand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDestroyDrawingWand(DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDestroyDrawingWand$descriptor() {
        return MagickDestroyDrawingWand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDestroyDrawingWand(DrawingWand *)
     * }
     */
    public static MethodHandle MagickDestroyDrawingWand$handle() {
        return MagickDestroyDrawingWand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDestroyDrawingWand(DrawingWand *)
     * }
     */
    public static MemorySegment MagickDestroyDrawingWand$address() {
        return MagickDestroyDrawingWand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDestroyDrawingWand(DrawingWand *)
     * }
     */
    public static void MagickDestroyDrawingWand(MemorySegment x0) {
        var mh$ = MagickDestroyDrawingWand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDestroyDrawingWand", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawEllipse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawEllipse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawEllipse(DrawingWand *, const double, const double, const double, const double, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawEllipse$descriptor() {
        return MagickDrawEllipse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawEllipse(DrawingWand *, const double, const double, const double, const double, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawEllipse$handle() {
        return MagickDrawEllipse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawEllipse(DrawingWand *, const double, const double, const double, const double, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawEllipse$address() {
        return MagickDrawEllipse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawEllipse(DrawingWand *, const double, const double, const double, const double, const double, const double)
     * }
     */
    public static void MagickDrawEllipse(MemorySegment x0, double x1, double x2, double x3, double x4, double x5, double x6) {
        var mh$ = MagickDrawEllipse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawEllipse", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawComposite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawComposite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawComposite(DrawingWand *, const CompositeOperator, const double, const double, const double, const double, const Image *)
     * }
     */
    public static FunctionDescriptor MagickDrawComposite$descriptor() {
        return MagickDrawComposite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawComposite(DrawingWand *, const CompositeOperator, const double, const double, const double, const double, const Image *)
     * }
     */
    public static MethodHandle MagickDrawComposite$handle() {
        return MagickDrawComposite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawComposite(DrawingWand *, const CompositeOperator, const double, const double, const double, const double, const Image *)
     * }
     */
    public static MemorySegment MagickDrawComposite$address() {
        return MagickDrawComposite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawComposite(DrawingWand *, const CompositeOperator, const double, const double, const double, const double, const Image *)
     * }
     */
    public static void MagickDrawComposite(MemorySegment x0, int x1, double x2, double x3, double x4, double x5, MemorySegment x6) {
        var mh$ = MagickDrawComposite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawComposite", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetFillColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetFillColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawGetFillColor(const DrawingWand *, PixelWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetFillColor$descriptor() {
        return MagickDrawGetFillColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawGetFillColor(const DrawingWand *, PixelWand *)
     * }
     */
    public static MethodHandle MagickDrawGetFillColor$handle() {
        return MagickDrawGetFillColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawGetFillColor(const DrawingWand *, PixelWand *)
     * }
     */
    public static MemorySegment MagickDrawGetFillColor$address() {
        return MagickDrawGetFillColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawGetFillColor(const DrawingWand *, PixelWand *)
     * }
     */
    public static void MagickDrawGetFillColor(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawGetFillColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetFillColor", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetStrokeColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetStrokeColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawGetStrokeColor(const DrawingWand *, PixelWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetStrokeColor$descriptor() {
        return MagickDrawGetStrokeColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawGetStrokeColor(const DrawingWand *, PixelWand *)
     * }
     */
    public static MethodHandle MagickDrawGetStrokeColor$handle() {
        return MagickDrawGetStrokeColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawGetStrokeColor(const DrawingWand *, PixelWand *)
     * }
     */
    public static MemorySegment MagickDrawGetStrokeColor$address() {
        return MagickDrawGetStrokeColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawGetStrokeColor(const DrawingWand *, PixelWand *)
     * }
     */
    public static void MagickDrawGetStrokeColor(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawGetStrokeColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetStrokeColor", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawGetTextUnderColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawGetTextUnderColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawGetTextUnderColor(const DrawingWand *, PixelWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawGetTextUnderColor$descriptor() {
        return MagickDrawGetTextUnderColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawGetTextUnderColor(const DrawingWand *, PixelWand *)
     * }
     */
    public static MethodHandle MagickDrawGetTextUnderColor$handle() {
        return MagickDrawGetTextUnderColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawGetTextUnderColor(const DrawingWand *, PixelWand *)
     * }
     */
    public static MemorySegment MagickDrawGetTextUnderColor$address() {
        return MagickDrawGetTextUnderColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawGetTextUnderColor(const DrawingWand *, PixelWand *)
     * }
     */
    public static void MagickDrawGetTextUnderColor(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawGetTextUnderColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawGetTextUnderColor", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawLine(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawLine$descriptor() {
        return MagickDrawLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawLine(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawLine$handle() {
        return MagickDrawLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawLine(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawLine$address() {
        return MagickDrawLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawLine(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static void MagickDrawLine(MemorySegment x0, double x1, double x2, double x3, double x4) {
        var mh$ = MagickDrawLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawLine", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawMatte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawMatte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawMatte(DrawingWand *, const double, const double, const PaintMethod)
     * }
     */
    public static FunctionDescriptor MagickDrawMatte$descriptor() {
        return MagickDrawMatte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawMatte(DrawingWand *, const double, const double, const PaintMethod)
     * }
     */
    public static MethodHandle MagickDrawMatte$handle() {
        return MagickDrawMatte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawMatte(DrawingWand *, const double, const double, const PaintMethod)
     * }
     */
    public static MemorySegment MagickDrawMatte$address() {
        return MagickDrawMatte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawMatte(DrawingWand *, const double, const double, const PaintMethod)
     * }
     */
    public static void MagickDrawMatte(MemorySegment x0, double x1, double x2, int x3) {
        var mh$ = MagickDrawMatte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawMatte", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathClose(DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawPathClose$descriptor() {
        return MagickDrawPathClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathClose(DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawPathClose$handle() {
        return MagickDrawPathClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathClose(DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawPathClose$address() {
        return MagickDrawPathClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathClose(DrawingWand *)
     * }
     */
    public static void MagickDrawPathClose(MemorySegment x0) {
        var mh$ = MagickDrawPathClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathClose", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathCurveToAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathCurveToAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToAbsolute(DrawingWand *, const double, const double, const double, const double, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathCurveToAbsolute$descriptor() {
        return MagickDrawPathCurveToAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToAbsolute(DrawingWand *, const double, const double, const double, const double, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawPathCurveToAbsolute$handle() {
        return MagickDrawPathCurveToAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToAbsolute(DrawingWand *, const double, const double, const double, const double, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawPathCurveToAbsolute$address() {
        return MagickDrawPathCurveToAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToAbsolute(DrawingWand *, const double, const double, const double, const double, const double, const double)
     * }
     */
    public static void MagickDrawPathCurveToAbsolute(MemorySegment x0, double x1, double x2, double x3, double x4, double x5, double x6) {
        var mh$ = MagickDrawPathCurveToAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathCurveToAbsolute", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathCurveToRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathCurveToRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToRelative(DrawingWand *, const double, const double, const double, const double, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathCurveToRelative$descriptor() {
        return MagickDrawPathCurveToRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToRelative(DrawingWand *, const double, const double, const double, const double, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawPathCurveToRelative$handle() {
        return MagickDrawPathCurveToRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToRelative(DrawingWand *, const double, const double, const double, const double, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawPathCurveToRelative$address() {
        return MagickDrawPathCurveToRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToRelative(DrawingWand *, const double, const double, const double, const double, const double, const double)
     * }
     */
    public static void MagickDrawPathCurveToRelative(MemorySegment x0, double x1, double x2, double x3, double x4, double x5, double x6) {
        var mh$ = MagickDrawPathCurveToRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathCurveToRelative", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathCurveToQuadraticBezierAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathCurveToQuadraticBezierAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToQuadraticBezierAbsolute(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathCurveToQuadraticBezierAbsolute$descriptor() {
        return MagickDrawPathCurveToQuadraticBezierAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToQuadraticBezierAbsolute(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawPathCurveToQuadraticBezierAbsolute$handle() {
        return MagickDrawPathCurveToQuadraticBezierAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToQuadraticBezierAbsolute(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawPathCurveToQuadraticBezierAbsolute$address() {
        return MagickDrawPathCurveToQuadraticBezierAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToQuadraticBezierAbsolute(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static void MagickDrawPathCurveToQuadraticBezierAbsolute(MemorySegment x0, double x1, double x2, double x3, double x4) {
        var mh$ = MagickDrawPathCurveToQuadraticBezierAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathCurveToQuadraticBezierAbsolute", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathCurveToQuadraticBezierRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathCurveToQuadraticBezierRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToQuadraticBezierRelative(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathCurveToQuadraticBezierRelative$descriptor() {
        return MagickDrawPathCurveToQuadraticBezierRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToQuadraticBezierRelative(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawPathCurveToQuadraticBezierRelative$handle() {
        return MagickDrawPathCurveToQuadraticBezierRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToQuadraticBezierRelative(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawPathCurveToQuadraticBezierRelative$address() {
        return MagickDrawPathCurveToQuadraticBezierRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToQuadraticBezierRelative(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static void MagickDrawPathCurveToQuadraticBezierRelative(MemorySegment x0, double x1, double x2, double x3, double x4) {
        var mh$ = MagickDrawPathCurveToQuadraticBezierRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathCurveToQuadraticBezierRelative", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathCurveToQuadraticBezierSmoothAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathCurveToQuadraticBezierSmoothAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToQuadraticBezierSmoothAbsolute(DrawingWand *, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathCurveToQuadraticBezierSmoothAbsolute$descriptor() {
        return MagickDrawPathCurveToQuadraticBezierSmoothAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToQuadraticBezierSmoothAbsolute(DrawingWand *, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawPathCurveToQuadraticBezierSmoothAbsolute$handle() {
        return MagickDrawPathCurveToQuadraticBezierSmoothAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToQuadraticBezierSmoothAbsolute(DrawingWand *, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawPathCurveToQuadraticBezierSmoothAbsolute$address() {
        return MagickDrawPathCurveToQuadraticBezierSmoothAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToQuadraticBezierSmoothAbsolute(DrawingWand *, const double, const double)
     * }
     */
    public static void MagickDrawPathCurveToQuadraticBezierSmoothAbsolute(MemorySegment x0, double x1, double x2) {
        var mh$ = MagickDrawPathCurveToQuadraticBezierSmoothAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathCurveToQuadraticBezierSmoothAbsolute", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathCurveToQuadraticBezierSmoothRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathCurveToQuadraticBezierSmoothRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToQuadraticBezierSmoothRelative(DrawingWand *, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathCurveToQuadraticBezierSmoothRelative$descriptor() {
        return MagickDrawPathCurveToQuadraticBezierSmoothRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToQuadraticBezierSmoothRelative(DrawingWand *, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawPathCurveToQuadraticBezierSmoothRelative$handle() {
        return MagickDrawPathCurveToQuadraticBezierSmoothRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToQuadraticBezierSmoothRelative(DrawingWand *, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawPathCurveToQuadraticBezierSmoothRelative$address() {
        return MagickDrawPathCurveToQuadraticBezierSmoothRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToQuadraticBezierSmoothRelative(DrawingWand *, const double, const double)
     * }
     */
    public static void MagickDrawPathCurveToQuadraticBezierSmoothRelative(MemorySegment x0, double x1, double x2) {
        var mh$ = MagickDrawPathCurveToQuadraticBezierSmoothRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathCurveToQuadraticBezierSmoothRelative", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathCurveToSmoothAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathCurveToSmoothAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToSmoothAbsolute(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathCurveToSmoothAbsolute$descriptor() {
        return MagickDrawPathCurveToSmoothAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToSmoothAbsolute(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawPathCurveToSmoothAbsolute$handle() {
        return MagickDrawPathCurveToSmoothAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToSmoothAbsolute(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawPathCurveToSmoothAbsolute$address() {
        return MagickDrawPathCurveToSmoothAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToSmoothAbsolute(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static void MagickDrawPathCurveToSmoothAbsolute(MemorySegment x0, double x1, double x2, double x3, double x4) {
        var mh$ = MagickDrawPathCurveToSmoothAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathCurveToSmoothAbsolute", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathCurveToSmoothRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathCurveToSmoothRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToSmoothRelative(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathCurveToSmoothRelative$descriptor() {
        return MagickDrawPathCurveToSmoothRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToSmoothRelative(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawPathCurveToSmoothRelative$handle() {
        return MagickDrawPathCurveToSmoothRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToSmoothRelative(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawPathCurveToSmoothRelative$address() {
        return MagickDrawPathCurveToSmoothRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathCurveToSmoothRelative(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static void MagickDrawPathCurveToSmoothRelative(MemorySegment x0, double x1, double x2, double x3, double x4) {
        var mh$ = MagickDrawPathCurveToSmoothRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathCurveToSmoothRelative", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathEllipticArcAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathEllipticArcAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathEllipticArcAbsolute(DrawingWand *, const double, const double, const double, unsigned int, unsigned int, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathEllipticArcAbsolute$descriptor() {
        return MagickDrawPathEllipticArcAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathEllipticArcAbsolute(DrawingWand *, const double, const double, const double, unsigned int, unsigned int, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawPathEllipticArcAbsolute$handle() {
        return MagickDrawPathEllipticArcAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathEllipticArcAbsolute(DrawingWand *, const double, const double, const double, unsigned int, unsigned int, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawPathEllipticArcAbsolute$address() {
        return MagickDrawPathEllipticArcAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathEllipticArcAbsolute(DrawingWand *, const double, const double, const double, unsigned int, unsigned int, const double, const double)
     * }
     */
    public static void MagickDrawPathEllipticArcAbsolute(MemorySegment x0, double x1, double x2, double x3, int x4, int x5, double x6, double x7) {
        var mh$ = MagickDrawPathEllipticArcAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathEllipticArcAbsolute", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathEllipticArcRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_INT,
            magick_wand_h.C_INT,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathEllipticArcRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathEllipticArcRelative(DrawingWand *, const double, const double, const double, unsigned int, unsigned int, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathEllipticArcRelative$descriptor() {
        return MagickDrawPathEllipticArcRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathEllipticArcRelative(DrawingWand *, const double, const double, const double, unsigned int, unsigned int, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawPathEllipticArcRelative$handle() {
        return MagickDrawPathEllipticArcRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathEllipticArcRelative(DrawingWand *, const double, const double, const double, unsigned int, unsigned int, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawPathEllipticArcRelative$address() {
        return MagickDrawPathEllipticArcRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathEllipticArcRelative(DrawingWand *, const double, const double, const double, unsigned int, unsigned int, const double, const double)
     * }
     */
    public static void MagickDrawPathEllipticArcRelative(MemorySegment x0, double x1, double x2, double x3, int x4, int x5, double x6, double x7) {
        var mh$ = MagickDrawPathEllipticArcRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathEllipticArcRelative", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathFinish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathFinish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathFinish(DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawPathFinish$descriptor() {
        return MagickDrawPathFinish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathFinish(DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawPathFinish$handle() {
        return MagickDrawPathFinish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathFinish(DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawPathFinish$address() {
        return MagickDrawPathFinish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathFinish(DrawingWand *)
     * }
     */
    public static void MagickDrawPathFinish(MemorySegment x0) {
        var mh$ = MagickDrawPathFinish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathFinish", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathLineToAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathLineToAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToAbsolute(DrawingWand *, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathLineToAbsolute$descriptor() {
        return MagickDrawPathLineToAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToAbsolute(DrawingWand *, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawPathLineToAbsolute$handle() {
        return MagickDrawPathLineToAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToAbsolute(DrawingWand *, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawPathLineToAbsolute$address() {
        return MagickDrawPathLineToAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToAbsolute(DrawingWand *, const double, const double)
     * }
     */
    public static void MagickDrawPathLineToAbsolute(MemorySegment x0, double x1, double x2) {
        var mh$ = MagickDrawPathLineToAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathLineToAbsolute", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathLineToRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathLineToRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToRelative(DrawingWand *, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathLineToRelative$descriptor() {
        return MagickDrawPathLineToRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToRelative(DrawingWand *, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawPathLineToRelative$handle() {
        return MagickDrawPathLineToRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToRelative(DrawingWand *, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawPathLineToRelative$address() {
        return MagickDrawPathLineToRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToRelative(DrawingWand *, const double, const double)
     * }
     */
    public static void MagickDrawPathLineToRelative(MemorySegment x0, double x1, double x2) {
        var mh$ = MagickDrawPathLineToRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathLineToRelative", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathLineToHorizontalAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathLineToHorizontalAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToHorizontalAbsolute(DrawingWand *, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathLineToHorizontalAbsolute$descriptor() {
        return MagickDrawPathLineToHorizontalAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToHorizontalAbsolute(DrawingWand *, const double)
     * }
     */
    public static MethodHandle MagickDrawPathLineToHorizontalAbsolute$handle() {
        return MagickDrawPathLineToHorizontalAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToHorizontalAbsolute(DrawingWand *, const double)
     * }
     */
    public static MemorySegment MagickDrawPathLineToHorizontalAbsolute$address() {
        return MagickDrawPathLineToHorizontalAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToHorizontalAbsolute(DrawingWand *, const double)
     * }
     */
    public static void MagickDrawPathLineToHorizontalAbsolute(MemorySegment x0, double x1) {
        var mh$ = MagickDrawPathLineToHorizontalAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathLineToHorizontalAbsolute", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathLineToHorizontalRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathLineToHorizontalRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToHorizontalRelative(DrawingWand *, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathLineToHorizontalRelative$descriptor() {
        return MagickDrawPathLineToHorizontalRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToHorizontalRelative(DrawingWand *, const double)
     * }
     */
    public static MethodHandle MagickDrawPathLineToHorizontalRelative$handle() {
        return MagickDrawPathLineToHorizontalRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToHorizontalRelative(DrawingWand *, const double)
     * }
     */
    public static MemorySegment MagickDrawPathLineToHorizontalRelative$address() {
        return MagickDrawPathLineToHorizontalRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToHorizontalRelative(DrawingWand *, const double)
     * }
     */
    public static void MagickDrawPathLineToHorizontalRelative(MemorySegment x0, double x1) {
        var mh$ = MagickDrawPathLineToHorizontalRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathLineToHorizontalRelative", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathLineToVerticalAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathLineToVerticalAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToVerticalAbsolute(DrawingWand *, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathLineToVerticalAbsolute$descriptor() {
        return MagickDrawPathLineToVerticalAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToVerticalAbsolute(DrawingWand *, const double)
     * }
     */
    public static MethodHandle MagickDrawPathLineToVerticalAbsolute$handle() {
        return MagickDrawPathLineToVerticalAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToVerticalAbsolute(DrawingWand *, const double)
     * }
     */
    public static MemorySegment MagickDrawPathLineToVerticalAbsolute$address() {
        return MagickDrawPathLineToVerticalAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToVerticalAbsolute(DrawingWand *, const double)
     * }
     */
    public static void MagickDrawPathLineToVerticalAbsolute(MemorySegment x0, double x1) {
        var mh$ = MagickDrawPathLineToVerticalAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathLineToVerticalAbsolute", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathLineToVerticalRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathLineToVerticalRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToVerticalRelative(DrawingWand *, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathLineToVerticalRelative$descriptor() {
        return MagickDrawPathLineToVerticalRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToVerticalRelative(DrawingWand *, const double)
     * }
     */
    public static MethodHandle MagickDrawPathLineToVerticalRelative$handle() {
        return MagickDrawPathLineToVerticalRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToVerticalRelative(DrawingWand *, const double)
     * }
     */
    public static MemorySegment MagickDrawPathLineToVerticalRelative$address() {
        return MagickDrawPathLineToVerticalRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathLineToVerticalRelative(DrawingWand *, const double)
     * }
     */
    public static void MagickDrawPathLineToVerticalRelative(MemorySegment x0, double x1) {
        var mh$ = MagickDrawPathLineToVerticalRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathLineToVerticalRelative", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathMoveToAbsolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathMoveToAbsolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathMoveToAbsolute(DrawingWand *, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathMoveToAbsolute$descriptor() {
        return MagickDrawPathMoveToAbsolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathMoveToAbsolute(DrawingWand *, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawPathMoveToAbsolute$handle() {
        return MagickDrawPathMoveToAbsolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathMoveToAbsolute(DrawingWand *, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawPathMoveToAbsolute$address() {
        return MagickDrawPathMoveToAbsolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathMoveToAbsolute(DrawingWand *, const double, const double)
     * }
     */
    public static void MagickDrawPathMoveToAbsolute(MemorySegment x0, double x1, double x2) {
        var mh$ = MagickDrawPathMoveToAbsolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathMoveToAbsolute", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathMoveToRelative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathMoveToRelative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathMoveToRelative(DrawingWand *, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPathMoveToRelative$descriptor() {
        return MagickDrawPathMoveToRelative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathMoveToRelative(DrawingWand *, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawPathMoveToRelative$handle() {
        return MagickDrawPathMoveToRelative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathMoveToRelative(DrawingWand *, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawPathMoveToRelative$address() {
        return MagickDrawPathMoveToRelative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathMoveToRelative(DrawingWand *, const double, const double)
     * }
     */
    public static void MagickDrawPathMoveToRelative(MemorySegment x0, double x1, double x2) {
        var mh$ = MagickDrawPathMoveToRelative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathMoveToRelative", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPathStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPathStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPathStart(DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawPathStart$descriptor() {
        return MagickDrawPathStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPathStart(DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawPathStart$handle() {
        return MagickDrawPathStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPathStart(DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawPathStart$address() {
        return MagickDrawPathStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPathStart(DrawingWand *)
     * }
     */
    public static void MagickDrawPathStart(MemorySegment x0) {
        var mh$ = MagickDrawPathStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPathStart", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPoint(DrawingWand *, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPoint$descriptor() {
        return MagickDrawPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPoint(DrawingWand *, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawPoint$handle() {
        return MagickDrawPoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPoint(DrawingWand *, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawPoint$address() {
        return MagickDrawPoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPoint(DrawingWand *, const double, const double)
     * }
     */
    public static void MagickDrawPoint(MemorySegment x0, double x1, double x2) {
        var mh$ = MagickDrawPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPoint", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPolygon(DrawingWand *, const unsigned long, const PointInfo *)
     * }
     */
    public static FunctionDescriptor MagickDrawPolygon$descriptor() {
        return MagickDrawPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPolygon(DrawingWand *, const unsigned long, const PointInfo *)
     * }
     */
    public static MethodHandle MagickDrawPolygon$handle() {
        return MagickDrawPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPolygon(DrawingWand *, const unsigned long, const PointInfo *)
     * }
     */
    public static MemorySegment MagickDrawPolygon$address() {
        return MagickDrawPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPolygon(DrawingWand *, const unsigned long, const PointInfo *)
     * }
     */
    public static void MagickDrawPolygon(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = MagickDrawPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPolygon", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPolyline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPolyline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPolyline(DrawingWand *, const unsigned long, const PointInfo *)
     * }
     */
    public static FunctionDescriptor MagickDrawPolyline$descriptor() {
        return MagickDrawPolyline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPolyline(DrawingWand *, const unsigned long, const PointInfo *)
     * }
     */
    public static MethodHandle MagickDrawPolyline$handle() {
        return MagickDrawPolyline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPolyline(DrawingWand *, const unsigned long, const PointInfo *)
     * }
     */
    public static MemorySegment MagickDrawPolyline$address() {
        return MagickDrawPolyline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPolyline(DrawingWand *, const unsigned long, const PointInfo *)
     * }
     */
    public static void MagickDrawPolyline(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = MagickDrawPolyline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPolyline", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPopClipPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPopClipPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPopClipPath(DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawPopClipPath$descriptor() {
        return MagickDrawPopClipPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPopClipPath(DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawPopClipPath$handle() {
        return MagickDrawPopClipPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPopClipPath(DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawPopClipPath$address() {
        return MagickDrawPopClipPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPopClipPath(DrawingWand *)
     * }
     */
    public static void MagickDrawPopClipPath(MemorySegment x0) {
        var mh$ = MagickDrawPopClipPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPopClipPath", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPopDefs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPopDefs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPopDefs(DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawPopDefs$descriptor() {
        return MagickDrawPopDefs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPopDefs(DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawPopDefs$handle() {
        return MagickDrawPopDefs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPopDefs(DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawPopDefs$address() {
        return MagickDrawPopDefs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPopDefs(DrawingWand *)
     * }
     */
    public static void MagickDrawPopDefs(MemorySegment x0) {
        var mh$ = MagickDrawPopDefs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPopDefs", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPopGraphicContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPopGraphicContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPopGraphicContext(DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawPopGraphicContext$descriptor() {
        return MagickDrawPopGraphicContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPopGraphicContext(DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawPopGraphicContext$handle() {
        return MagickDrawPopGraphicContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPopGraphicContext(DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawPopGraphicContext$address() {
        return MagickDrawPopGraphicContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPopGraphicContext(DrawingWand *)
     * }
     */
    public static void MagickDrawPopGraphicContext(MemorySegment x0) {
        var mh$ = MagickDrawPopGraphicContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPopGraphicContext", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPopPattern {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPopPattern");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPopPattern(DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawPopPattern$descriptor() {
        return MagickDrawPopPattern.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPopPattern(DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawPopPattern$handle() {
        return MagickDrawPopPattern.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPopPattern(DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawPopPattern$address() {
        return MagickDrawPopPattern.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPopPattern(DrawingWand *)
     * }
     */
    public static void MagickDrawPopPattern(MemorySegment x0) {
        var mh$ = MagickDrawPopPattern.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPopPattern", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPushClipPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPushClipPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPushClipPath(DrawingWand *, const char *)
     * }
     */
    public static FunctionDescriptor MagickDrawPushClipPath$descriptor() {
        return MagickDrawPushClipPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPushClipPath(DrawingWand *, const char *)
     * }
     */
    public static MethodHandle MagickDrawPushClipPath$handle() {
        return MagickDrawPushClipPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPushClipPath(DrawingWand *, const char *)
     * }
     */
    public static MemorySegment MagickDrawPushClipPath$address() {
        return MagickDrawPushClipPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPushClipPath(DrawingWand *, const char *)
     * }
     */
    public static void MagickDrawPushClipPath(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawPushClipPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPushClipPath", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPushDefs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPushDefs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPushDefs(DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawPushDefs$descriptor() {
        return MagickDrawPushDefs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPushDefs(DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawPushDefs$handle() {
        return MagickDrawPushDefs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPushDefs(DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawPushDefs$address() {
        return MagickDrawPushDefs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPushDefs(DrawingWand *)
     * }
     */
    public static void MagickDrawPushDefs(MemorySegment x0) {
        var mh$ = MagickDrawPushDefs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPushDefs", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPushGraphicContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPushGraphicContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPushGraphicContext(DrawingWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawPushGraphicContext$descriptor() {
        return MagickDrawPushGraphicContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPushGraphicContext(DrawingWand *)
     * }
     */
    public static MethodHandle MagickDrawPushGraphicContext$handle() {
        return MagickDrawPushGraphicContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPushGraphicContext(DrawingWand *)
     * }
     */
    public static MemorySegment MagickDrawPushGraphicContext$address() {
        return MagickDrawPushGraphicContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPushGraphicContext(DrawingWand *)
     * }
     */
    public static void MagickDrawPushGraphicContext(MemorySegment x0) {
        var mh$ = MagickDrawPushGraphicContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPushGraphicContext", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawPushPattern {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawPushPattern");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawPushPattern(DrawingWand *, const char *, const double, const double, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawPushPattern$descriptor() {
        return MagickDrawPushPattern.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawPushPattern(DrawingWand *, const char *, const double, const double, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawPushPattern$handle() {
        return MagickDrawPushPattern.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawPushPattern(DrawingWand *, const char *, const double, const double, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawPushPattern$address() {
        return MagickDrawPushPattern.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawPushPattern(DrawingWand *, const char *, const double, const double, const double, const double)
     * }
     */
    public static void MagickDrawPushPattern(MemorySegment x0, MemorySegment x1, double x2, double x3, double x4, double x5) {
        var mh$ = MagickDrawPushPattern.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawPushPattern", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawRectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawRectangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawRectangle(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawRectangle$descriptor() {
        return MagickDrawRectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawRectangle(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawRectangle$handle() {
        return MagickDrawRectangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawRectangle(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawRectangle$address() {
        return MagickDrawRectangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawRectangle(DrawingWand *, const double, const double, const double, const double)
     * }
     */
    public static void MagickDrawRectangle(MemorySegment x0, double x1, double x2, double x3, double x4) {
        var mh$ = MagickDrawRectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawRectangle", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawRotate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawRotate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawRotate(DrawingWand *, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawRotate$descriptor() {
        return MagickDrawRotate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawRotate(DrawingWand *, const double)
     * }
     */
    public static MethodHandle MagickDrawRotate$handle() {
        return MagickDrawRotate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawRotate(DrawingWand *, const double)
     * }
     */
    public static MemorySegment MagickDrawRotate$address() {
        return MagickDrawRotate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawRotate(DrawingWand *, const double)
     * }
     */
    public static void MagickDrawRotate(MemorySegment x0, double x1) {
        var mh$ = MagickDrawRotate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawRotate", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawRoundRectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawRoundRectangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawRoundRectangle(DrawingWand *, double, double, double, double, double, double)
     * }
     */
    public static FunctionDescriptor MagickDrawRoundRectangle$descriptor() {
        return MagickDrawRoundRectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawRoundRectangle(DrawingWand *, double, double, double, double, double, double)
     * }
     */
    public static MethodHandle MagickDrawRoundRectangle$handle() {
        return MagickDrawRoundRectangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawRoundRectangle(DrawingWand *, double, double, double, double, double, double)
     * }
     */
    public static MemorySegment MagickDrawRoundRectangle$address() {
        return MagickDrawRoundRectangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawRoundRectangle(DrawingWand *, double, double, double, double, double, double)
     * }
     */
    public static void MagickDrawRoundRectangle(MemorySegment x0, double x1, double x2, double x3, double x4, double x5, double x6) {
        var mh$ = MagickDrawRoundRectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawRoundRectangle", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawScale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawScale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawScale(DrawingWand *, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawScale$descriptor() {
        return MagickDrawScale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawScale(DrawingWand *, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawScale$handle() {
        return MagickDrawScale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawScale(DrawingWand *, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawScale$address() {
        return MagickDrawScale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawScale(DrawingWand *, const double, const double)
     * }
     */
    public static void MagickDrawScale(MemorySegment x0, double x1, double x2) {
        var mh$ = MagickDrawScale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawScale", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetClipPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetClipPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetClipPath(DrawingWand *, const char *)
     * }
     */
    public static FunctionDescriptor MagickDrawSetClipPath$descriptor() {
        return MagickDrawSetClipPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetClipPath(DrawingWand *, const char *)
     * }
     */
    public static MethodHandle MagickDrawSetClipPath$handle() {
        return MagickDrawSetClipPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetClipPath(DrawingWand *, const char *)
     * }
     */
    public static MemorySegment MagickDrawSetClipPath$address() {
        return MagickDrawSetClipPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetClipPath(DrawingWand *, const char *)
     * }
     */
    public static void MagickDrawSetClipPath(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawSetClipPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetClipPath", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetClipRule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetClipRule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetClipRule(DrawingWand *, const FillRule)
     * }
     */
    public static FunctionDescriptor MagickDrawSetClipRule$descriptor() {
        return MagickDrawSetClipRule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetClipRule(DrawingWand *, const FillRule)
     * }
     */
    public static MethodHandle MagickDrawSetClipRule$handle() {
        return MagickDrawSetClipRule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetClipRule(DrawingWand *, const FillRule)
     * }
     */
    public static MemorySegment MagickDrawSetClipRule$address() {
        return MagickDrawSetClipRule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetClipRule(DrawingWand *, const FillRule)
     * }
     */
    public static void MagickDrawSetClipRule(MemorySegment x0, int x1) {
        var mh$ = MagickDrawSetClipRule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetClipRule", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetClipUnits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetClipUnits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetClipUnits(DrawingWand *, const ClipPathUnits)
     * }
     */
    public static FunctionDescriptor MagickDrawSetClipUnits$descriptor() {
        return MagickDrawSetClipUnits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetClipUnits(DrawingWand *, const ClipPathUnits)
     * }
     */
    public static MethodHandle MagickDrawSetClipUnits$handle() {
        return MagickDrawSetClipUnits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetClipUnits(DrawingWand *, const ClipPathUnits)
     * }
     */
    public static MemorySegment MagickDrawSetClipUnits$address() {
        return MagickDrawSetClipUnits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetClipUnits(DrawingWand *, const ClipPathUnits)
     * }
     */
    public static void MagickDrawSetClipUnits(MemorySegment x0, int x1) {
        var mh$ = MagickDrawSetClipUnits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetClipUnits", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetFillColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetFillColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFillColor(DrawingWand *, const PixelWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawSetFillColor$descriptor() {
        return MagickDrawSetFillColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFillColor(DrawingWand *, const PixelWand *)
     * }
     */
    public static MethodHandle MagickDrawSetFillColor$handle() {
        return MagickDrawSetFillColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFillColor(DrawingWand *, const PixelWand *)
     * }
     */
    public static MemorySegment MagickDrawSetFillColor$address() {
        return MagickDrawSetFillColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetFillColor(DrawingWand *, const PixelWand *)
     * }
     */
    public static void MagickDrawSetFillColor(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawSetFillColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetFillColor", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetFillOpacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetFillOpacity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFillOpacity(DrawingWand *, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawSetFillOpacity$descriptor() {
        return MagickDrawSetFillOpacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFillOpacity(DrawingWand *, const double)
     * }
     */
    public static MethodHandle MagickDrawSetFillOpacity$handle() {
        return MagickDrawSetFillOpacity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFillOpacity(DrawingWand *, const double)
     * }
     */
    public static MemorySegment MagickDrawSetFillOpacity$address() {
        return MagickDrawSetFillOpacity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetFillOpacity(DrawingWand *, const double)
     * }
     */
    public static void MagickDrawSetFillOpacity(MemorySegment x0, double x1) {
        var mh$ = MagickDrawSetFillOpacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetFillOpacity", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetFillRule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetFillRule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFillRule(DrawingWand *, const FillRule)
     * }
     */
    public static FunctionDescriptor MagickDrawSetFillRule$descriptor() {
        return MagickDrawSetFillRule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFillRule(DrawingWand *, const FillRule)
     * }
     */
    public static MethodHandle MagickDrawSetFillRule$handle() {
        return MagickDrawSetFillRule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFillRule(DrawingWand *, const FillRule)
     * }
     */
    public static MemorySegment MagickDrawSetFillRule$address() {
        return MagickDrawSetFillRule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetFillRule(DrawingWand *, const FillRule)
     * }
     */
    public static void MagickDrawSetFillRule(MemorySegment x0, int x1) {
        var mh$ = MagickDrawSetFillRule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetFillRule", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetFillPatternURL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetFillPatternURL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFillPatternURL(DrawingWand *, const char *)
     * }
     */
    public static FunctionDescriptor MagickDrawSetFillPatternURL$descriptor() {
        return MagickDrawSetFillPatternURL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFillPatternURL(DrawingWand *, const char *)
     * }
     */
    public static MethodHandle MagickDrawSetFillPatternURL$handle() {
        return MagickDrawSetFillPatternURL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFillPatternURL(DrawingWand *, const char *)
     * }
     */
    public static MemorySegment MagickDrawSetFillPatternURL$address() {
        return MagickDrawSetFillPatternURL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetFillPatternURL(DrawingWand *, const char *)
     * }
     */
    public static void MagickDrawSetFillPatternURL(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawSetFillPatternURL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetFillPatternURL", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetFont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFont(DrawingWand *, const char *)
     * }
     */
    public static FunctionDescriptor MagickDrawSetFont$descriptor() {
        return MagickDrawSetFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFont(DrawingWand *, const char *)
     * }
     */
    public static MethodHandle MagickDrawSetFont$handle() {
        return MagickDrawSetFont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFont(DrawingWand *, const char *)
     * }
     */
    public static MemorySegment MagickDrawSetFont$address() {
        return MagickDrawSetFont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetFont(DrawingWand *, const char *)
     * }
     */
    public static void MagickDrawSetFont(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawSetFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetFont", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetFontFamily {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetFontFamily");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFontFamily(DrawingWand *, const char *)
     * }
     */
    public static FunctionDescriptor MagickDrawSetFontFamily$descriptor() {
        return MagickDrawSetFontFamily.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFontFamily(DrawingWand *, const char *)
     * }
     */
    public static MethodHandle MagickDrawSetFontFamily$handle() {
        return MagickDrawSetFontFamily.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFontFamily(DrawingWand *, const char *)
     * }
     */
    public static MemorySegment MagickDrawSetFontFamily$address() {
        return MagickDrawSetFontFamily.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetFontFamily(DrawingWand *, const char *)
     * }
     */
    public static void MagickDrawSetFontFamily(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawSetFontFamily.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetFontFamily", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetFontSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetFontSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFontSize(DrawingWand *, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawSetFontSize$descriptor() {
        return MagickDrawSetFontSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFontSize(DrawingWand *, const double)
     * }
     */
    public static MethodHandle MagickDrawSetFontSize$handle() {
        return MagickDrawSetFontSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFontSize(DrawingWand *, const double)
     * }
     */
    public static MemorySegment MagickDrawSetFontSize$address() {
        return MagickDrawSetFontSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetFontSize(DrawingWand *, const double)
     * }
     */
    public static void MagickDrawSetFontSize(MemorySegment x0, double x1) {
        var mh$ = MagickDrawSetFontSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetFontSize", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetFontStretch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetFontStretch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFontStretch(DrawingWand *, const StretchType)
     * }
     */
    public static FunctionDescriptor MagickDrawSetFontStretch$descriptor() {
        return MagickDrawSetFontStretch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFontStretch(DrawingWand *, const StretchType)
     * }
     */
    public static MethodHandle MagickDrawSetFontStretch$handle() {
        return MagickDrawSetFontStretch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFontStretch(DrawingWand *, const StretchType)
     * }
     */
    public static MemorySegment MagickDrawSetFontStretch$address() {
        return MagickDrawSetFontStretch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetFontStretch(DrawingWand *, const StretchType)
     * }
     */
    public static void MagickDrawSetFontStretch(MemorySegment x0, int x1) {
        var mh$ = MagickDrawSetFontStretch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetFontStretch", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetFontStyle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetFontStyle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFontStyle(DrawingWand *, const StyleType)
     * }
     */
    public static FunctionDescriptor MagickDrawSetFontStyle$descriptor() {
        return MagickDrawSetFontStyle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFontStyle(DrawingWand *, const StyleType)
     * }
     */
    public static MethodHandle MagickDrawSetFontStyle$handle() {
        return MagickDrawSetFontStyle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFontStyle(DrawingWand *, const StyleType)
     * }
     */
    public static MemorySegment MagickDrawSetFontStyle$address() {
        return MagickDrawSetFontStyle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetFontStyle(DrawingWand *, const StyleType)
     * }
     */
    public static void MagickDrawSetFontStyle(MemorySegment x0, int x1) {
        var mh$ = MagickDrawSetFontStyle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetFontStyle", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetFontWeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetFontWeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFontWeight(DrawingWand *, const unsigned long)
     * }
     */
    public static FunctionDescriptor MagickDrawSetFontWeight$descriptor() {
        return MagickDrawSetFontWeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFontWeight(DrawingWand *, const unsigned long)
     * }
     */
    public static MethodHandle MagickDrawSetFontWeight$handle() {
        return MagickDrawSetFontWeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetFontWeight(DrawingWand *, const unsigned long)
     * }
     */
    public static MemorySegment MagickDrawSetFontWeight$address() {
        return MagickDrawSetFontWeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetFontWeight(DrawingWand *, const unsigned long)
     * }
     */
    public static void MagickDrawSetFontWeight(MemorySegment x0, long x1) {
        var mh$ = MagickDrawSetFontWeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetFontWeight", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetGravity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetGravity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetGravity(DrawingWand *, const GravityType)
     * }
     */
    public static FunctionDescriptor MagickDrawSetGravity$descriptor() {
        return MagickDrawSetGravity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetGravity(DrawingWand *, const GravityType)
     * }
     */
    public static MethodHandle MagickDrawSetGravity$handle() {
        return MagickDrawSetGravity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetGravity(DrawingWand *, const GravityType)
     * }
     */
    public static MemorySegment MagickDrawSetGravity$address() {
        return MagickDrawSetGravity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetGravity(DrawingWand *, const GravityType)
     * }
     */
    public static void MagickDrawSetGravity(MemorySegment x0, int x1) {
        var mh$ = MagickDrawSetGravity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetGravity", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSkewX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSkewX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSkewX(DrawingWand *, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawSkewX$descriptor() {
        return MagickDrawSkewX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSkewX(DrawingWand *, const double)
     * }
     */
    public static MethodHandle MagickDrawSkewX$handle() {
        return MagickDrawSkewX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSkewX(DrawingWand *, const double)
     * }
     */
    public static MemorySegment MagickDrawSkewX$address() {
        return MagickDrawSkewX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSkewX(DrawingWand *, const double)
     * }
     */
    public static void MagickDrawSkewX(MemorySegment x0, double x1) {
        var mh$ = MagickDrawSkewX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSkewX", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSkewY {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSkewY");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSkewY(DrawingWand *, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawSkewY$descriptor() {
        return MagickDrawSkewY.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSkewY(DrawingWand *, const double)
     * }
     */
    public static MethodHandle MagickDrawSkewY$handle() {
        return MagickDrawSkewY.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSkewY(DrawingWand *, const double)
     * }
     */
    public static MemorySegment MagickDrawSkewY$address() {
        return MagickDrawSkewY.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSkewY(DrawingWand *, const double)
     * }
     */
    public static void MagickDrawSkewY(MemorySegment x0, double x1) {
        var mh$ = MagickDrawSkewY.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSkewY", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetStrokeAntialias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetStrokeAntialias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeAntialias(DrawingWand *, const unsigned int)
     * }
     */
    public static FunctionDescriptor MagickDrawSetStrokeAntialias$descriptor() {
        return MagickDrawSetStrokeAntialias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeAntialias(DrawingWand *, const unsigned int)
     * }
     */
    public static MethodHandle MagickDrawSetStrokeAntialias$handle() {
        return MagickDrawSetStrokeAntialias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeAntialias(DrawingWand *, const unsigned int)
     * }
     */
    public static MemorySegment MagickDrawSetStrokeAntialias$address() {
        return MagickDrawSetStrokeAntialias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeAntialias(DrawingWand *, const unsigned int)
     * }
     */
    public static void MagickDrawSetStrokeAntialias(MemorySegment x0, int x1) {
        var mh$ = MagickDrawSetStrokeAntialias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetStrokeAntialias", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetStrokeColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetStrokeColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeColor(DrawingWand *, const PixelWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawSetStrokeColor$descriptor() {
        return MagickDrawSetStrokeColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeColor(DrawingWand *, const PixelWand *)
     * }
     */
    public static MethodHandle MagickDrawSetStrokeColor$handle() {
        return MagickDrawSetStrokeColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeColor(DrawingWand *, const PixelWand *)
     * }
     */
    public static MemorySegment MagickDrawSetStrokeColor$address() {
        return MagickDrawSetStrokeColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeColor(DrawingWand *, const PixelWand *)
     * }
     */
    public static void MagickDrawSetStrokeColor(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawSetStrokeColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetStrokeColor", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetStrokeDashArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetStrokeDashArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeDashArray(DrawingWand *, const unsigned long, const double *)
     * }
     */
    public static FunctionDescriptor MagickDrawSetStrokeDashArray$descriptor() {
        return MagickDrawSetStrokeDashArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeDashArray(DrawingWand *, const unsigned long, const double *)
     * }
     */
    public static MethodHandle MagickDrawSetStrokeDashArray$handle() {
        return MagickDrawSetStrokeDashArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeDashArray(DrawingWand *, const unsigned long, const double *)
     * }
     */
    public static MemorySegment MagickDrawSetStrokeDashArray$address() {
        return MagickDrawSetStrokeDashArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeDashArray(DrawingWand *, const unsigned long, const double *)
     * }
     */
    public static void MagickDrawSetStrokeDashArray(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = MagickDrawSetStrokeDashArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetStrokeDashArray", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetStrokeDashOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetStrokeDashOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeDashOffset(DrawingWand *, const double dashoffset)
     * }
     */
    public static FunctionDescriptor MagickDrawSetStrokeDashOffset$descriptor() {
        return MagickDrawSetStrokeDashOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeDashOffset(DrawingWand *, const double dashoffset)
     * }
     */
    public static MethodHandle MagickDrawSetStrokeDashOffset$handle() {
        return MagickDrawSetStrokeDashOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeDashOffset(DrawingWand *, const double dashoffset)
     * }
     */
    public static MemorySegment MagickDrawSetStrokeDashOffset$address() {
        return MagickDrawSetStrokeDashOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeDashOffset(DrawingWand *, const double dashoffset)
     * }
     */
    public static void MagickDrawSetStrokeDashOffset(MemorySegment x0, double dashoffset) {
        var mh$ = MagickDrawSetStrokeDashOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetStrokeDashOffset", x0, dashoffset);
            }
            mh$.invokeExact(x0, dashoffset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetStrokeLineCap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetStrokeLineCap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeLineCap(DrawingWand *, const LineCap)
     * }
     */
    public static FunctionDescriptor MagickDrawSetStrokeLineCap$descriptor() {
        return MagickDrawSetStrokeLineCap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeLineCap(DrawingWand *, const LineCap)
     * }
     */
    public static MethodHandle MagickDrawSetStrokeLineCap$handle() {
        return MagickDrawSetStrokeLineCap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeLineCap(DrawingWand *, const LineCap)
     * }
     */
    public static MemorySegment MagickDrawSetStrokeLineCap$address() {
        return MagickDrawSetStrokeLineCap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeLineCap(DrawingWand *, const LineCap)
     * }
     */
    public static void MagickDrawSetStrokeLineCap(MemorySegment x0, int x1) {
        var mh$ = MagickDrawSetStrokeLineCap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetStrokeLineCap", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetStrokeLineJoin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetStrokeLineJoin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeLineJoin(DrawingWand *, const LineJoin)
     * }
     */
    public static FunctionDescriptor MagickDrawSetStrokeLineJoin$descriptor() {
        return MagickDrawSetStrokeLineJoin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeLineJoin(DrawingWand *, const LineJoin)
     * }
     */
    public static MethodHandle MagickDrawSetStrokeLineJoin$handle() {
        return MagickDrawSetStrokeLineJoin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeLineJoin(DrawingWand *, const LineJoin)
     * }
     */
    public static MemorySegment MagickDrawSetStrokeLineJoin$address() {
        return MagickDrawSetStrokeLineJoin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeLineJoin(DrawingWand *, const LineJoin)
     * }
     */
    public static void MagickDrawSetStrokeLineJoin(MemorySegment x0, int x1) {
        var mh$ = MagickDrawSetStrokeLineJoin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetStrokeLineJoin", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetStrokeMiterLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetStrokeMiterLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeMiterLimit(DrawingWand *, const unsigned long)
     * }
     */
    public static FunctionDescriptor MagickDrawSetStrokeMiterLimit$descriptor() {
        return MagickDrawSetStrokeMiterLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeMiterLimit(DrawingWand *, const unsigned long)
     * }
     */
    public static MethodHandle MagickDrawSetStrokeMiterLimit$handle() {
        return MagickDrawSetStrokeMiterLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeMiterLimit(DrawingWand *, const unsigned long)
     * }
     */
    public static MemorySegment MagickDrawSetStrokeMiterLimit$address() {
        return MagickDrawSetStrokeMiterLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeMiterLimit(DrawingWand *, const unsigned long)
     * }
     */
    public static void MagickDrawSetStrokeMiterLimit(MemorySegment x0, long x1) {
        var mh$ = MagickDrawSetStrokeMiterLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetStrokeMiterLimit", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetStrokeOpacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetStrokeOpacity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeOpacity(DrawingWand *, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawSetStrokeOpacity$descriptor() {
        return MagickDrawSetStrokeOpacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeOpacity(DrawingWand *, const double)
     * }
     */
    public static MethodHandle MagickDrawSetStrokeOpacity$handle() {
        return MagickDrawSetStrokeOpacity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeOpacity(DrawingWand *, const double)
     * }
     */
    public static MemorySegment MagickDrawSetStrokeOpacity$address() {
        return MagickDrawSetStrokeOpacity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeOpacity(DrawingWand *, const double)
     * }
     */
    public static void MagickDrawSetStrokeOpacity(MemorySegment x0, double x1) {
        var mh$ = MagickDrawSetStrokeOpacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetStrokeOpacity", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetStrokePatternURL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetStrokePatternURL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokePatternURL(DrawingWand *, const char *)
     * }
     */
    public static FunctionDescriptor MagickDrawSetStrokePatternURL$descriptor() {
        return MagickDrawSetStrokePatternURL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokePatternURL(DrawingWand *, const char *)
     * }
     */
    public static MethodHandle MagickDrawSetStrokePatternURL$handle() {
        return MagickDrawSetStrokePatternURL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokePatternURL(DrawingWand *, const char *)
     * }
     */
    public static MemorySegment MagickDrawSetStrokePatternURL$address() {
        return MagickDrawSetStrokePatternURL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokePatternURL(DrawingWand *, const char *)
     * }
     */
    public static void MagickDrawSetStrokePatternURL(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawSetStrokePatternURL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetStrokePatternURL", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetStrokeWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetStrokeWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeWidth(DrawingWand *, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawSetStrokeWidth$descriptor() {
        return MagickDrawSetStrokeWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeWidth(DrawingWand *, const double)
     * }
     */
    public static MethodHandle MagickDrawSetStrokeWidth$handle() {
        return MagickDrawSetStrokeWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeWidth(DrawingWand *, const double)
     * }
     */
    public static MemorySegment MagickDrawSetStrokeWidth$address() {
        return MagickDrawSetStrokeWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetStrokeWidth(DrawingWand *, const double)
     * }
     */
    public static void MagickDrawSetStrokeWidth(MemorySegment x0, double x1) {
        var mh$ = MagickDrawSetStrokeWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetStrokeWidth", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetTextAntialias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetTextAntialias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetTextAntialias(DrawingWand *, const unsigned int)
     * }
     */
    public static FunctionDescriptor MagickDrawSetTextAntialias$descriptor() {
        return MagickDrawSetTextAntialias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetTextAntialias(DrawingWand *, const unsigned int)
     * }
     */
    public static MethodHandle MagickDrawSetTextAntialias$handle() {
        return MagickDrawSetTextAntialias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetTextAntialias(DrawingWand *, const unsigned int)
     * }
     */
    public static MemorySegment MagickDrawSetTextAntialias$address() {
        return MagickDrawSetTextAntialias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetTextAntialias(DrawingWand *, const unsigned int)
     * }
     */
    public static void MagickDrawSetTextAntialias(MemorySegment x0, int x1) {
        var mh$ = MagickDrawSetTextAntialias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetTextAntialias", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetTextDecoration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_INT
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetTextDecoration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetTextDecoration(DrawingWand *, const DecorationType)
     * }
     */
    public static FunctionDescriptor MagickDrawSetTextDecoration$descriptor() {
        return MagickDrawSetTextDecoration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetTextDecoration(DrawingWand *, const DecorationType)
     * }
     */
    public static MethodHandle MagickDrawSetTextDecoration$handle() {
        return MagickDrawSetTextDecoration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetTextDecoration(DrawingWand *, const DecorationType)
     * }
     */
    public static MemorySegment MagickDrawSetTextDecoration$address() {
        return MagickDrawSetTextDecoration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetTextDecoration(DrawingWand *, const DecorationType)
     * }
     */
    public static void MagickDrawSetTextDecoration(MemorySegment x0, int x1) {
        var mh$ = MagickDrawSetTextDecoration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetTextDecoration", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetTextEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetTextEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetTextEncoding(DrawingWand *, const char *)
     * }
     */
    public static FunctionDescriptor MagickDrawSetTextEncoding$descriptor() {
        return MagickDrawSetTextEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetTextEncoding(DrawingWand *, const char *)
     * }
     */
    public static MethodHandle MagickDrawSetTextEncoding$handle() {
        return MagickDrawSetTextEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetTextEncoding(DrawingWand *, const char *)
     * }
     */
    public static MemorySegment MagickDrawSetTextEncoding$address() {
        return MagickDrawSetTextEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetTextEncoding(DrawingWand *, const char *)
     * }
     */
    public static void MagickDrawSetTextEncoding(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawSetTextEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetTextEncoding", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetTextUnderColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetTextUnderColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetTextUnderColor(DrawingWand *, const PixelWand *)
     * }
     */
    public static FunctionDescriptor MagickDrawSetTextUnderColor$descriptor() {
        return MagickDrawSetTextUnderColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetTextUnderColor(DrawingWand *, const PixelWand *)
     * }
     */
    public static MethodHandle MagickDrawSetTextUnderColor$handle() {
        return MagickDrawSetTextUnderColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetTextUnderColor(DrawingWand *, const PixelWand *)
     * }
     */
    public static MemorySegment MagickDrawSetTextUnderColor$address() {
        return MagickDrawSetTextUnderColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetTextUnderColor(DrawingWand *, const PixelWand *)
     * }
     */
    public static void MagickDrawSetTextUnderColor(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickDrawSetTextUnderColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetTextUnderColor", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawSetViewbox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawSetViewbox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawSetViewbox(DrawingWand *, unsigned long, unsigned long, unsigned long, unsigned long)
     * }
     */
    public static FunctionDescriptor MagickDrawSetViewbox$descriptor() {
        return MagickDrawSetViewbox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawSetViewbox(DrawingWand *, unsigned long, unsigned long, unsigned long, unsigned long)
     * }
     */
    public static MethodHandle MagickDrawSetViewbox$handle() {
        return MagickDrawSetViewbox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawSetViewbox(DrawingWand *, unsigned long, unsigned long, unsigned long, unsigned long)
     * }
     */
    public static MemorySegment MagickDrawSetViewbox$address() {
        return MagickDrawSetViewbox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawSetViewbox(DrawingWand *, unsigned long, unsigned long, unsigned long, unsigned long)
     * }
     */
    public static void MagickDrawSetViewbox(MemorySegment x0, long x1, long x2, long x3, long x4) {
        var mh$ = MagickDrawSetViewbox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawSetViewbox", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDrawTranslate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDrawTranslate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void MagickDrawTranslate(DrawingWand *, const double, const double)
     * }
     */
    public static FunctionDescriptor MagickDrawTranslate$descriptor() {
        return MagickDrawTranslate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void MagickDrawTranslate(DrawingWand *, const double, const double)
     * }
     */
    public static MethodHandle MagickDrawTranslate$handle() {
        return MagickDrawTranslate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void MagickDrawTranslate(DrawingWand *, const double, const double)
     * }
     */
    public static MemorySegment MagickDrawTranslate$address() {
        return MagickDrawTranslate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void MagickDrawTranslate(DrawingWand *, const double, const double)
     * }
     */
    public static void MagickDrawTranslate(MemorySegment x0, double x1, double x2) {
        var mh$ = MagickDrawTranslate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDrawTranslate", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int FormatMagickString(char *, const size_t, const char *, ...)
     * }
     */
    public static class FormatMagickString {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                magick_wand_h.C_INT,
                magick_wand_h.C_POINTER,
                magick_wand_h.C_LONG,
                magick_wand_h.C_POINTER
            );
        private static final MemorySegment ADDR = magick_wand_h.findOrThrow("FormatMagickString");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private FormatMagickString(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int FormatMagickString(char *, const size_t, const char *, ...)
         * }
         */
        public static FormatMagickString makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new FormatMagickString(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, long x1, MemorySegment x2, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("FormatMagickString", x0, x1, x2, x3);
                }
                return (int) spreader.invokeExact(x0, x1, x2, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class CopyMagickString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_LONG,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_LONG
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("CopyMagickString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t CopyMagickString(char *, const char *, const size_t)
     * }
     */
    public static FunctionDescriptor CopyMagickString$descriptor() {
        return CopyMagickString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t CopyMagickString(char *, const char *, const size_t)
     * }
     */
    public static MethodHandle CopyMagickString$handle() {
        return CopyMagickString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t CopyMagickString(char *, const char *, const size_t)
     * }
     */
    public static MemorySegment CopyMagickString$address() {
        return CopyMagickString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t CopyMagickString(char *, const char *, const size_t)
     * }
     */
    public static long CopyMagickString(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = CopyMagickString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyMagickString", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickDescribeImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickDescribeImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *MagickDescribeImage(MagickWand *)
     * }
     */
    public static FunctionDescriptor MagickDescribeImage$descriptor() {
        return MagickDescribeImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *MagickDescribeImage(MagickWand *)
     * }
     */
    public static MethodHandle MagickDescribeImage$handle() {
        return MagickDescribeImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *MagickDescribeImage(MagickWand *)
     * }
     */
    public static MemorySegment MagickDescribeImage$address() {
        return MagickDescribeImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *MagickDescribeImage(MagickWand *)
     * }
     */
    public static MemorySegment MagickDescribeImage(MemorySegment x0) {
        var mh$ = MagickDescribeImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickDescribeImage", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetConfigureInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetConfigureInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *MagickGetConfigureInfo(MagickWand *, const char *)
     * }
     */
    public static FunctionDescriptor MagickGetConfigureInfo$descriptor() {
        return MagickGetConfigureInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *MagickGetConfigureInfo(MagickWand *, const char *)
     * }
     */
    public static MethodHandle MagickGetConfigureInfo$handle() {
        return MagickGetConfigureInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *MagickGetConfigureInfo(MagickWand *, const char *)
     * }
     */
    public static MemorySegment MagickGetConfigureInfo$address() {
        return MagickGetConfigureInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *MagickGetConfigureInfo(MagickWand *, const char *)
     * }
     */
    public static MemorySegment MagickGetConfigureInfo(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickGetConfigureInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetConfigureInfo", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *MagickGetException(const MagickWand *, ExceptionType *)
     * }
     */
    public static FunctionDescriptor MagickGetException$descriptor() {
        return MagickGetException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *MagickGetException(const MagickWand *, ExceptionType *)
     * }
     */
    public static MethodHandle MagickGetException$handle() {
        return MagickGetException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *MagickGetException(const MagickWand *, ExceptionType *)
     * }
     */
    public static MemorySegment MagickGetException$address() {
        return MagickGetException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *MagickGetException(const MagickWand *, ExceptionType *)
     * }
     */
    public static MemorySegment MagickGetException(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickGetException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetException", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetFilename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetFilename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *MagickGetFilename(const MagickWand *)
     * }
     */
    public static FunctionDescriptor MagickGetFilename$descriptor() {
        return MagickGetFilename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *MagickGetFilename(const MagickWand *)
     * }
     */
    public static MethodHandle MagickGetFilename$handle() {
        return MagickGetFilename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *MagickGetFilename(const MagickWand *)
     * }
     */
    public static MemorySegment MagickGetFilename$address() {
        return MagickGetFilename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *MagickGetFilename(const MagickWand *)
     * }
     */
    public static MemorySegment MagickGetFilename(MemorySegment x0) {
        var mh$ = MagickGetFilename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetFilename", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetImageAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetImageAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *MagickGetImageAttribute(MagickWand *, const char *)
     * }
     */
    public static FunctionDescriptor MagickGetImageAttribute$descriptor() {
        return MagickGetImageAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *MagickGetImageAttribute(MagickWand *, const char *)
     * }
     */
    public static MethodHandle MagickGetImageAttribute$handle() {
        return MagickGetImageAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *MagickGetImageAttribute(MagickWand *, const char *)
     * }
     */
    public static MemorySegment MagickGetImageAttribute$address() {
        return MagickGetImageAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *MagickGetImageAttribute(MagickWand *, const char *)
     * }
     */
    public static MemorySegment MagickGetImageAttribute(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickGetImageAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetImageAttribute", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetImageFilename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetImageFilename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *MagickGetImageFilename(MagickWand *)
     * }
     */
    public static FunctionDescriptor MagickGetImageFilename$descriptor() {
        return MagickGetImageFilename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *MagickGetImageFilename(MagickWand *)
     * }
     */
    public static MethodHandle MagickGetImageFilename$handle() {
        return MagickGetImageFilename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *MagickGetImageFilename(MagickWand *)
     * }
     */
    public static MemorySegment MagickGetImageFilename$address() {
        return MagickGetImageFilename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *MagickGetImageFilename(MagickWand *)
     * }
     */
    public static MemorySegment MagickGetImageFilename(MemorySegment x0) {
        var mh$ = MagickGetImageFilename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetImageFilename", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetImageFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetImageFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *MagickGetImageFormat(MagickWand *)
     * }
     */
    public static FunctionDescriptor MagickGetImageFormat$descriptor() {
        return MagickGetImageFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *MagickGetImageFormat(MagickWand *)
     * }
     */
    public static MethodHandle MagickGetImageFormat$handle() {
        return MagickGetImageFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *MagickGetImageFormat(MagickWand *)
     * }
     */
    public static MemorySegment MagickGetImageFormat$address() {
        return MagickGetImageFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *MagickGetImageFormat(MagickWand *)
     * }
     */
    public static MemorySegment MagickGetImageFormat(MemorySegment x0) {
        var mh$ = MagickGetImageFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetImageFormat", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetImageSignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetImageSignature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *MagickGetImageSignature(MagickWand *)
     * }
     */
    public static FunctionDescriptor MagickGetImageSignature$descriptor() {
        return MagickGetImageSignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *MagickGetImageSignature(MagickWand *)
     * }
     */
    public static MethodHandle MagickGetImageSignature$handle() {
        return MagickGetImageSignature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *MagickGetImageSignature(MagickWand *)
     * }
     */
    public static MemorySegment MagickGetImageSignature$address() {
        return MagickGetImageSignature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *MagickGetImageSignature(MagickWand *)
     * }
     */
    public static MemorySegment MagickGetImageSignature(MemorySegment x0) {
        var mh$ = MagickGetImageSignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetImageSignature", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickQueryFonts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickQueryFonts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char **MagickQueryFonts(const char *, unsigned long *)
     * }
     */
    public static FunctionDescriptor MagickQueryFonts$descriptor() {
        return MagickQueryFonts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char **MagickQueryFonts(const char *, unsigned long *)
     * }
     */
    public static MethodHandle MagickQueryFonts$handle() {
        return MagickQueryFonts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char **MagickQueryFonts(const char *, unsigned long *)
     * }
     */
    public static MemorySegment MagickQueryFonts$address() {
        return MagickQueryFonts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char **MagickQueryFonts(const char *, unsigned long *)
     * }
     */
    public static MemorySegment MagickQueryFonts(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickQueryFonts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickQueryFonts", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickQueryFormats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickQueryFormats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char **MagickQueryFormats(const char *, unsigned long *)
     * }
     */
    public static FunctionDescriptor MagickQueryFormats$descriptor() {
        return MagickQueryFormats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char **MagickQueryFormats(const char *, unsigned long *)
     * }
     */
    public static MethodHandle MagickQueryFormats$handle() {
        return MagickQueryFormats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char **MagickQueryFormats(const char *, unsigned long *)
     * }
     */
    public static MemorySegment MagickQueryFormats$address() {
        return MagickQueryFormats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char **MagickQueryFormats(const char *, unsigned long *)
     * }
     */
    public static MemorySegment MagickQueryFormats(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickQueryFormats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickQueryFormats", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetImageCompose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetImageCompose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern CompositeOperator MagickGetImageCompose(MagickWand *)
     * }
     */
    public static FunctionDescriptor MagickGetImageCompose$descriptor() {
        return MagickGetImageCompose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern CompositeOperator MagickGetImageCompose(MagickWand *)
     * }
     */
    public static MethodHandle MagickGetImageCompose$handle() {
        return MagickGetImageCompose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern CompositeOperator MagickGetImageCompose(MagickWand *)
     * }
     */
    public static MemorySegment MagickGetImageCompose$address() {
        return MagickGetImageCompose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern CompositeOperator MagickGetImageCompose(MagickWand *)
     * }
     */
    public static int MagickGetImageCompose(MemorySegment x0) {
        var mh$ = MagickGetImageCompose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetImageCompose", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetImageColorspace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetImageColorspace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ColorspaceType MagickGetImageColorspace(MagickWand *)
     * }
     */
    public static FunctionDescriptor MagickGetImageColorspace$descriptor() {
        return MagickGetImageColorspace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ColorspaceType MagickGetImageColorspace(MagickWand *)
     * }
     */
    public static MethodHandle MagickGetImageColorspace$handle() {
        return MagickGetImageColorspace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ColorspaceType MagickGetImageColorspace(MagickWand *)
     * }
     */
    public static MemorySegment MagickGetImageColorspace$address() {
        return MagickGetImageColorspace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ColorspaceType MagickGetImageColorspace(MagickWand *)
     * }
     */
    public static int MagickGetImageColorspace(MemorySegment x0) {
        var mh$ = MagickGetImageColorspace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetImageColorspace", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetImageCompression {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetImageCompression");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern CompressionType MagickGetImageCompression(MagickWand *)
     * }
     */
    public static FunctionDescriptor MagickGetImageCompression$descriptor() {
        return MagickGetImageCompression.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern CompressionType MagickGetImageCompression(MagickWand *)
     * }
     */
    public static MethodHandle MagickGetImageCompression$handle() {
        return MagickGetImageCompression.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern CompressionType MagickGetImageCompression(MagickWand *)
     * }
     */
    public static MemorySegment MagickGetImageCompression$address() {
        return MagickGetImageCompression.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern CompressionType MagickGetImageCompression(MagickWand *)
     * }
     */
    public static int MagickGetImageCompression(MemorySegment x0) {
        var mh$ = MagickGetImageCompression.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetImageCompression", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetCopyright {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetCopyright");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *MagickGetCopyright()
     * }
     */
    public static FunctionDescriptor MagickGetCopyright$descriptor() {
        return MagickGetCopyright.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *MagickGetCopyright()
     * }
     */
    public static MethodHandle MagickGetCopyright$handle() {
        return MagickGetCopyright.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *MagickGetCopyright()
     * }
     */
    public static MemorySegment MagickGetCopyright$address() {
        return MagickGetCopyright.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *MagickGetCopyright()
     * }
     */
    public static MemorySegment MagickGetCopyright() {
        var mh$ = MagickGetCopyright.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetCopyright");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetHomeURL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetHomeURL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *MagickGetHomeURL()
     * }
     */
    public static FunctionDescriptor MagickGetHomeURL$descriptor() {
        return MagickGetHomeURL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *MagickGetHomeURL()
     * }
     */
    public static MethodHandle MagickGetHomeURL$handle() {
        return MagickGetHomeURL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *MagickGetHomeURL()
     * }
     */
    public static MemorySegment MagickGetHomeURL$address() {
        return MagickGetHomeURL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *MagickGetHomeURL()
     * }
     */
    public static MemorySegment MagickGetHomeURL() {
        var mh$ = MagickGetHomeURL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetHomeURL");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetImageGeometry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetImageGeometry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *MagickGetImageGeometry(MagickWand *)
     * }
     */
    public static FunctionDescriptor MagickGetImageGeometry$descriptor() {
        return MagickGetImageGeometry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *MagickGetImageGeometry(MagickWand *)
     * }
     */
    public static MethodHandle MagickGetImageGeometry$handle() {
        return MagickGetImageGeometry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *MagickGetImageGeometry(MagickWand *)
     * }
     */
    public static MemorySegment MagickGetImageGeometry$address() {
        return MagickGetImageGeometry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *MagickGetImageGeometry(MagickWand *)
     * }
     */
    public static MemorySegment MagickGetImageGeometry(MemorySegment x0) {
        var mh$ = MagickGetImageGeometry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetImageGeometry", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetPackageName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetPackageName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *MagickGetPackageName()
     * }
     */
    public static FunctionDescriptor MagickGetPackageName$descriptor() {
        return MagickGetPackageName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *MagickGetPackageName()
     * }
     */
    public static MethodHandle MagickGetPackageName$handle() {
        return MagickGetPackageName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *MagickGetPackageName()
     * }
     */
    public static MemorySegment MagickGetPackageName$address() {
        return MagickGetPackageName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *MagickGetPackageName()
     * }
     */
    public static MemorySegment MagickGetPackageName() {
        var mh$ = MagickGetPackageName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetPackageName");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetQuantumDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetQuantumDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *MagickGetQuantumDepth(unsigned long *)
     * }
     */
    public static FunctionDescriptor MagickGetQuantumDepth$descriptor() {
        return MagickGetQuantumDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *MagickGetQuantumDepth(unsigned long *)
     * }
     */
    public static MethodHandle MagickGetQuantumDepth$handle() {
        return MagickGetQuantumDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *MagickGetQuantumDepth(unsigned long *)
     * }
     */
    public static MemorySegment MagickGetQuantumDepth$address() {
        return MagickGetQuantumDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *MagickGetQuantumDepth(unsigned long *)
     * }
     */
    public static MemorySegment MagickGetQuantumDepth(MemorySegment x0) {
        var mh$ = MagickGetQuantumDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetQuantumDepth", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetReleaseDate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER    );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetReleaseDate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *MagickGetReleaseDate()
     * }
     */
    public static FunctionDescriptor MagickGetReleaseDate$descriptor() {
        return MagickGetReleaseDate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *MagickGetReleaseDate()
     * }
     */
    public static MethodHandle MagickGetReleaseDate$handle() {
        return MagickGetReleaseDate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *MagickGetReleaseDate()
     * }
     */
    public static MemorySegment MagickGetReleaseDate$address() {
        return MagickGetReleaseDate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *MagickGetReleaseDate()
     * }
     */
    public static MemorySegment MagickGetReleaseDate() {
        var mh$ = MagickGetReleaseDate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetReleaseDate");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *MagickGetVersion(unsigned long *)
     * }
     */
    public static FunctionDescriptor MagickGetVersion$descriptor() {
        return MagickGetVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *MagickGetVersion(unsigned long *)
     * }
     */
    public static MethodHandle MagickGetVersion$handle() {
        return MagickGetVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *MagickGetVersion(unsigned long *)
     * }
     */
    public static MemorySegment MagickGetVersion$address() {
        return MagickGetVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *MagickGetVersion(unsigned long *)
     * }
     */
    public static MemorySegment MagickGetVersion(MemorySegment x0) {
        var mh$ = MagickGetVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetVersion", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetImageDispose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetImageDispose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern DisposeType MagickGetImageDispose(MagickWand *)
     * }
     */
    public static FunctionDescriptor MagickGetImageDispose$descriptor() {
        return MagickGetImageDispose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern DisposeType MagickGetImageDispose(MagickWand *)
     * }
     */
    public static MethodHandle MagickGetImageDispose$handle() {
        return MagickGetImageDispose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern DisposeType MagickGetImageDispose(MagickWand *)
     * }
     */
    public static MemorySegment MagickGetImageDispose$address() {
        return MagickGetImageDispose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern DisposeType MagickGetImageDispose(MagickWand *)
     * }
     */
    public static int MagickGetImageDispose(MemorySegment x0) {
        var mh$ = MagickGetImageDispose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetImageDispose", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetImageGamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetImageGamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double MagickGetImageGamma(MagickWand *)
     * }
     */
    public static FunctionDescriptor MagickGetImageGamma$descriptor() {
        return MagickGetImageGamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double MagickGetImageGamma(MagickWand *)
     * }
     */
    public static MethodHandle MagickGetImageGamma$handle() {
        return MagickGetImageGamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double MagickGetImageGamma(MagickWand *)
     * }
     */
    public static MemorySegment MagickGetImageGamma$address() {
        return MagickGetImageGamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double MagickGetImageGamma(MagickWand *)
     * }
     */
    public static double MagickGetImageGamma(MemorySegment x0) {
        var mh$ = MagickGetImageGamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetImageGamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetImageFuzz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_DOUBLE,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetImageFuzz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double MagickGetImageFuzz(MagickWand *)
     * }
     */
    public static FunctionDescriptor MagickGetImageFuzz$descriptor() {
        return MagickGetImageFuzz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double MagickGetImageFuzz(MagickWand *)
     * }
     */
    public static MethodHandle MagickGetImageFuzz$handle() {
        return MagickGetImageFuzz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double MagickGetImageFuzz(MagickWand *)
     * }
     */
    public static MemorySegment MagickGetImageFuzz$address() {
        return MagickGetImageFuzz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double MagickGetImageFuzz(MagickWand *)
     * }
     */
    public static double MagickGetImageFuzz(MemorySegment x0) {
        var mh$ = MagickGetImageFuzz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetImageFuzz", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetSamplingFactors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetSamplingFactors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double *MagickGetSamplingFactors(MagickWand *, unsigned long *)
     * }
     */
    public static FunctionDescriptor MagickGetSamplingFactors$descriptor() {
        return MagickGetSamplingFactors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double *MagickGetSamplingFactors(MagickWand *, unsigned long *)
     * }
     */
    public static MethodHandle MagickGetSamplingFactors$handle() {
        return MagickGetSamplingFactors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double *MagickGetSamplingFactors(MagickWand *, unsigned long *)
     * }
     */
    public static MemorySegment MagickGetSamplingFactors$address() {
        return MagickGetSamplingFactors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double *MagickGetSamplingFactors(MagickWand *, unsigned long *)
     * }
     */
    public static MemorySegment MagickGetSamplingFactors(MemorySegment x0, MemorySegment x1) {
        var mh$ = MagickGetSamplingFactors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetSamplingFactors", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickQueryFontMetrics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickQueryFontMetrics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double *MagickQueryFontMetrics(MagickWand *, const DrawingWand *, const char *)
     * }
     */
    public static FunctionDescriptor MagickQueryFontMetrics$descriptor() {
        return MagickQueryFontMetrics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double *MagickQueryFontMetrics(MagickWand *, const DrawingWand *, const char *)
     * }
     */
    public static MethodHandle MagickQueryFontMetrics$handle() {
        return MagickQueryFontMetrics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double *MagickQueryFontMetrics(MagickWand *, const DrawingWand *, const char *)
     * }
     */
    public static MemorySegment MagickQueryFontMetrics$address() {
        return MagickQueryFontMetrics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double *MagickQueryFontMetrics(MagickWand *, const DrawingWand *, const char *)
     * }
     */
    public static MemorySegment MagickQueryFontMetrics(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = MagickQueryFontMetrics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickQueryFontMetrics", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MagickGetImageGravity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            magick_wand_h.C_INT,
            magick_wand_h.C_POINTER
        );

        public static final MemorySegment ADDR = magick_wand_h.findOrThrow("MagickGetImageGravity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GravityType MagickGetImageGravity(MagickWand *wand)
     * }
     */
    public static FunctionDescriptor MagickGetImageGravity$descriptor() {
        return MagickGetImageGravity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GravityType MagickGetImageGravity(MagickWand *wand)
     * }
     */
    public static MethodHandle MagickGetImageGravity$handle() {
        return MagickGetImageGravity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GravityType MagickGetImageGravity(MagickWand *wand)
     * }
     */
    public static MemorySegment MagickGetImageGravity$address() {
        return MagickGetImageGravity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GravityType MagickGetImageGravity(MagickWand *wand)
     * }
     */
    public static int MagickGetImageGravity(MemorySegment wand) {
        var mh$ = MagickGetImageGravity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MagickGetImageGravity", wand);
            }
            return (int)mh$.invokeExact(wand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

